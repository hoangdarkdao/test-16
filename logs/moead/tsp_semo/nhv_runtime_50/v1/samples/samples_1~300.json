[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825579027546039,
            1.1650115251541138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825579027546039,
            1.1650115251541138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825579027546039,
            1.1650115251541138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Evaluate improvement potential: select solution with the worst objective (most room for improvement)\n    worst_obj_idx = np.argmax([sum(obj) for obj in archive_objectives])\n    base_solution = archive_solutions[worst_obj_idx].copy()\n\n    # Hybrid local search: combine edge exchange with segment reordering\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge exchange (2-opt-like but with a twist)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reordering (reverse a random segment)\n    if np.random.rand() < 0.5:  # 50% chance to apply segment reordering\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[k:l+1]\n        new_solution[k:l+1] = segment[::-1]\n\n    # Ensure feasibility: verify no node is missing or duplicated\n    if len(set(new_solution)) != n:\n        # Fallback to simpler edge exchange if segment reordering breaks feasibility\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9218729433531517,
            1.98958820104599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Evaluate improvement potential: select solution with the worst objective (most room for improvement)\n    worst_obj_idx = np.argmax([sum(obj) for obj in archive_objectives])\n    base_solution = archive_solutions[worst_obj_idx].copy()\n\n    # Hybrid local search: combine edge exchange with segment reordering\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge exchange (2-opt-like but with a twist)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reordering (reverse a random segment)\n    if np.random.rand() < 0.5:  # 50% chance to apply segment reordering\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[k:l+1]\n        new_solution[k:l+1] = segment[::-1]\n\n    # Ensure feasibility: verify no node is missing or duplicated\n    if len(set(new_solution)) != n:\n        # Fallback to simpler edge exchange if segment reordering breaks feasibility\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel local search heuristic that intelligently selects a solution from the archive based on its Pareto dominance and objective diversity, then applies a hybrid 2-opt and edge exchange operator with adaptive segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (np.sum(x[1]), -np.prod(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with edge exchange\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Segment reversal between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge exchange between j and k\n    if k > j:\n        new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8293700996850417,
            3.7784639596939087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (np.sum(x[1]), -np.prod(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with edge exchange\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Segment reversal between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge exchange between j and k\n    if k > j:\n        new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines a randomized edge insertion with a multi-objective aware segment reversal, prioritizing solutions with high crowding distance in the objective space to ensure diverse exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(sorted_obj) - 1):\n                distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    if j - i > 1:\n        segment = new_solution[i+1:j].copy()\n        np.random.shuffle(segment)\n        new_solution[i+1:j] = segment\n\n    # Step 2: Multi-objective aware segment reversal\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1].copy()\n\n    # Evaluate segment reversal in both objectives\n    def evaluate_segment(s):\n        cost1 = distance_matrix_1[s[-1], s[0]] if len(s) > 1 else 0\n        cost2 = distance_matrix_2[s[-1], s[0]] if len(s) > 1 else 0\n        for k in range(len(s)-1):\n            cost1 += distance_matrix_1[s[k], s[k+1]]\n            cost2 += distance_matrix_2[s[k], s[k+1]]\n        return (cost1, cost2)\n\n    original_cost = evaluate_segment(segment)\n    reversed_cost = evaluate_segment(segment[::-1])\n\n    # Accept reversal if it improves at least one objective\n    if (reversed_cost[0] <= original_cost[0] and reversed_cost[1] < original_cost[1]) or \\\n       (reversed_cost[0] < original_cost[0] and reversed_cost[1] <= original_cost[1]):\n        new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7340972665390681,
            2.2446362376213074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(sorted_obj) - 1):\n                distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    if j - i > 1:\n        segment = new_solution[i+1:j].copy()\n        np.random.shuffle(segment)\n        new_solution[i+1:j] = segment\n\n    # Step 2: Multi-objective aware segment reversal\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1].copy()\n\n    # Evaluate segment reversal in both objectives\n    def evaluate_segment(s):\n        cost1 = distance_matrix_1[s[-1], s[0]] if len(s) > 1 else 0\n        cost2 = distance_matrix_2[s[-1], s[0]] if len(s) > 1 else 0\n        for k in range(len(s)-1):\n            cost1 += distance_matrix_1[s[k], s[k+1]]\n            cost2 += distance_matrix_2[s[k], s[k+1]]\n        return (cost1, cost2)\n\n    original_cost = evaluate_segment(segment)\n    reversed_cost = evaluate_segment(segment[::-1])\n\n    # Accept reversal if it improves at least one objective\n    if (reversed_cost[0] <= original_cost[0] and reversed_cost[1] < original_cost[1]) or \\\n       (reversed_cost[0] < original_cost[0] and reversed_cost[1] <= original_cost[1]):\n        new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This heuristic function selects a high-quality solution from the archive by prioritizing those with low objective values in both spaces, then applies a novel local search combining segment reversal and node insertion with distance-aware selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objective values\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal with distance-aware node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Find a node to insert with minimal combined distance impact\n    node_to_insert = random.choice(new_solution)\n    best_pos = 0\n    min_distance = float('inf')\n\n    for i in range(n):\n        if i == 0:\n            d1 = distance_matrix_1[new_solution[-1], new_solution[i]] + distance_matrix_1[new_solution[i], node_to_insert]\n            d2 = distance_matrix_2[new_solution[-1], new_solution[i]] + distance_matrix_2[new_solution[i], node_to_insert]\n        else:\n            d1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], node_to_insert]\n            d2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], node_to_insert]\n\n        total_distance = d1 + d2\n        if total_distance < min_distance:\n            min_distance = total_distance\n            best_pos = i\n\n    # Insert the node at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], [node_to_insert], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9353508214524491,
            0.4042084217071533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objective values\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal with distance-aware node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Find a node to insert with minimal combined distance impact\n    node_to_insert = random.choice(new_solution)\n    best_pos = 0\n    min_distance = float('inf')\n\n    for i in range(n):\n        if i == 0:\n            d1 = distance_matrix_1[new_solution[-1], new_solution[i]] + distance_matrix_1[new_solution[i], node_to_insert]\n            d2 = distance_matrix_2[new_solution[-1], new_solution[i]] + distance_matrix_2[new_solution[i], node_to_insert]\n        else:\n            d1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], node_to_insert]\n            d2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], node_to_insert]\n\n        total_distance = d1 + d2\n        if total_distance < min_distance:\n            min_distance = total_distance\n            best_pos = i\n\n    # Insert the node at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], [node_to_insert], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This heuristic function selects a high-quality solution from the archive by prioritizing those with low objective values in both spaces, then applies a novel local search combining segment reversal and node insertion with distance-aware selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objective values\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal with distance-aware node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Find a node to insert with minimal combined distance impact\n    node_to_insert = random.choice(new_solution)\n    best_pos = 0\n    min_distance = float('inf')\n\n    for i in range(n):\n        if i == 0:\n            d1 = distance_matrix_1[new_solution[-1], new_solution[i]] + distance_matrix_1[new_solution[i], node_to_insert]\n            d2 = distance_matrix_2[new_solution[-1], new_solution[i]] + distance_matrix_2[new_solution[i], node_to_insert]\n        else:\n            d1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], node_to_insert]\n            d2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], node_to_insert]\n\n        total_distance = d1 + d2\n        if total_distance < min_distance:\n            min_distance = total_distance\n            best_pos = i\n\n    # Insert the node at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], [node_to_insert], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9353508214524491,
            0.4042084217071533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objective values\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal with distance-aware node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Find a node to insert with minimal combined distance impact\n    node_to_insert = random.choice(new_solution)\n    best_pos = 0\n    min_distance = float('inf')\n\n    for i in range(n):\n        if i == 0:\n            d1 = distance_matrix_1[new_solution[-1], new_solution[i]] + distance_matrix_1[new_solution[i], node_to_insert]\n            d2 = distance_matrix_2[new_solution[-1], new_solution[i]] + distance_matrix_2[new_solution[i], node_to_insert]\n        else:\n            d1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], node_to_insert]\n            d2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], node_to_insert]\n\n        total_distance = d1 + d2\n        if total_distance < min_distance:\n            min_distance = total_distance\n            best_pos = i\n\n    # Insert the node at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], [node_to_insert], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel local search combining segment inversion and node insertion with a bias toward improving the more dominant objective, while ensuring feasibility through careful position validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Determine which objective is more dominant\n    obj1, obj2 = archive[selected_idx][1]\n    dominant_obj = 1 if obj1 > obj2 else 2\n\n    # Segment inversion with objective bias\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    if dominant_obj == 1:\n        # Invert segment to potentially improve first objective\n        segment = segment[::-1]\n    else:\n        # For second objective, rotate segment instead\n        segment = np.roll(segment, 1)\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Node insertion with distance-based validation\n    node_to_insert = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n    insert_pos = random.randint(0, n-1)\n    if dominant_obj == 1:\n        # Insert after node with smallest distance in first space\n        distances = distance_matrix_1[node_to_insert]\n        insert_pos = np.argmin(distances[new_solution])\n    else:\n        # Insert after node with smallest distance in second space\n        distances = distance_matrix_2[node_to_insert]\n        insert_pos = np.argmin(distances[new_solution])\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.8827732528420116,
            2.0320924520492554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Determine which objective is more dominant\n    obj1, obj2 = archive[selected_idx][1]\n    dominant_obj = 1 if obj1 > obj2 else 2\n\n    # Segment inversion with objective bias\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    if dominant_obj == 1:\n        # Invert segment to potentially improve first objective\n        segment = segment[::-1]\n    else:\n        # For second objective, rotate segment instead\n        segment = np.roll(segment, 1)\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Node insertion with distance-based validation\n    node_to_insert = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n    insert_pos = random.randint(0, n-1)\n    if dominant_obj == 1:\n        # Insert after node with smallest distance in first space\n        distances = distance_matrix_1[node_to_insert]\n        insert_pos = np.argmin(distances[new_solution])\n    else:\n        # Insert after node with smallest distance in second space\n        distances = distance_matrix_2[node_to_insert]\n        insert_pos = np.argmin(distances[new_solution])\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search combining segment inversion and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a combination of objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objective values and diversity\n        score = (obj1 + obj2) * (1 + random.random())  # Randomized selection to avoid local optima\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + adaptive edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a segment and invert it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1][::-1]  # Invert the segment\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Step 2: Adaptive edge insertion based on distance matrices\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Choose the better edge insertion based on combined distance\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if dist1 + dist2 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]]:\n            # Perform the insertion\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9392027182785339,
            1.960600733757019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a combination of objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objective values and diversity\n        score = (obj1 + obj2) * (1 + random.random())  # Randomized selection to avoid local optima\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + adaptive edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a segment and invert it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1][::-1]  # Invert the segment\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Step 2: Adaptive edge insertion based on distance matrices\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Choose the better edge insertion based on combined distance\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if dist1 + dist2 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]]:\n            # Perform the insertion\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm selects the solution with the highest sum of normalized objective values from the archive, then applies a novel \"clustered segment inversion\" local search that inverts segments based on spatial proximity in both objective spaces, ensuring feasibility through careful node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    max_score = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and calculate score\n        norm_obj1 = obj1 / (distance_matrix_1.sum() + 1e-10)\n        norm_obj2 = obj2 / (distance_matrix_2.sum() + 1e-10)\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Clustered segment inversion\n    # Find two spatial clusters based on both objectives\n    cluster1 = []\n    cluster2 = []\n    for i in range(n):\n        node_id = base_solution[i]\n        x1, y1, x2, y2 = instance[node_id]\n        if (x1 + y1) < (x2 + y2):\n            cluster1.append(i)\n        else:\n            cluster2.append(i)\n\n    # Invert segments within clusters\n    if len(cluster1) > 2:\n        start = random.choice(cluster1)\n        end = random.choice(cluster1)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    if len(cluster2) > 2:\n        start = random.choice(cluster2)\n        end = random.choice(cluster2)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9633656695901401,
            4.524668037891388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    max_score = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and calculate score\n        norm_obj1 = obj1 / (distance_matrix_1.sum() + 1e-10)\n        norm_obj2 = obj2 / (distance_matrix_2.sum() + 1e-10)\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Clustered segment inversion\n    # Find two spatial clusters based on both objectives\n    cluster1 = []\n    cluster2 = []\n    for i in range(n):\n        node_id = base_solution[i]\n        x1, y1, x2, y2 = instance[node_id]\n        if (x1 + y1) < (x2 + y2):\n            cluster1.append(i)\n        else:\n            cluster2.append(i)\n\n    # Invert segments within clusters\n    if len(cluster1) > 2:\n        start = random.choice(cluster1)\n        end = random.choice(cluster1)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    if len(cluster2) > 2:\n        start = random.choice(cluster2)\n        end = random.choice(cluster2)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a novel local search operator that combines segment reversal and position swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values (potential for improvement)\n    selected_idx = np.argmax([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random positions\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9736765965118153,
            2.177077353000641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values (potential for improvement)\n    selected_idx = np.argmax([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random positions\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This heuristic function selects a solution from the archive based on its dominance and diversity, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score based on dominance and crowding distance\n        score = (1 / (obj1 + 1e-6)) * (1 / (obj2 + 1e-6)) + (obj1 + obj2)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9059803020184969,
            2.495366394519806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score based on dominance and crowding distance\n        score = (1 / (obj1 + 1e-6)) * (1 / (obj2 + 1e-6)) + (obj1 + obj2)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search operator that combines segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9185690126025648,
            1.4075640439987183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a hybrid local search combining segment inversion and random node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of objectives and dominance\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = 0.7 * obj1 + 0.3 * obj2  # Weighted combination\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + random reinsertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Randomly reinsert a node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6962036892911336,
            1.720095932483673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of objectives and dominance\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = 0.7 * obj1 + 0.3 * obj2  # Weighted combination\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + random reinsertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Randomly reinsert a node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance rank and applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest dominance rank\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_to_move = random.choice(new_solution)\n    new_solution = np.setdiff1d(new_solution, node_to_move)\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9073432291296124,
            2.1728387475013733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest dominance rank\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_to_move = random.choice(new_solution)\n    new_solution = np.setdiff1d(new_solution, node_to_move)\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This heuristic function selects a solution from the archive based on its dominance rank and applies a novel local search combining segment inversion and node reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance rank (simplified)\n    selected_idx = 0\n    min_rank = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        rank = obj1 + obj2  # Placeholder for actual dominance rank calculation\n        if rank < min_rank:\n            min_rank = rank\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Reinsert a random node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7140961877914868,
            1.9356544017791748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance rank (simplified)\n    selected_idx = 0\n    min_rank = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        rank = obj1 + obj2  # Placeholder for actual dominance rank calculation\n        if rank < min_rank:\n            min_rank = rank\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Reinsert a random node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and dominance, then applies a novel local search combining 3-opt and a dynamic segment inversion to generate a feasible neighbor solution while minimizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective values\n    selected_idx = np.argmin([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Novel local search: 3-opt with dynamic segment inversion\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reconnecting edges\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n\n    # Create new order with dynamic inversion\n    if random.random() > 0.5:\n        segment1 = segment1[::-1]\n\n    new_order = np.concatenate([new_solution[:i], segment1, segment2, segment3])\n\n    # Handle circular case\n    if len(new_order) != n:\n        new_order = np.concatenate([new_order, new_solution[:i]])\n\n    return new_order\n\n",
        "score": [
            -0.6860762275801862,
            2.1737269163131714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective values\n    selected_idx = np.argmin([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Novel local search: 3-opt with dynamic segment inversion\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reconnecting edges\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n\n    # Create new order with dynamic inversion\n    if random.random() > 0.5:\n        segment1 = segment1[::-1]\n\n    new_order = np.concatenate([new_solution[:i], segment1, segment2, segment3])\n\n    # Handle circular case\n    if len(new_order) != n:\n        new_order = np.concatenate([new_order, new_solution[:i]])\n\n    return new_order\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This new heuristic selects a solution from the archive based on a combined score of dominance and diversity, then applies a hybrid local search combining 3-opt and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on combined dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a combined score (dominance + diversity)\n        score = (obj1 + obj2) * (1 + 0.1 * random.random())  # Add randomness to encourage diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + path reversal\n    n = len(base_solution)\n    if n < 5:\n        return base_solution\n\n    # Step 1: Perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8567250988313073,
            2.2884257435798645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on combined dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a combined score (dominance + diversity)\n        score = (obj1 + obj2) * (1 + 0.1 * random.random())  # Add randomness to encourage diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + path reversal\n    n = len(base_solution)\n    if n < 5:\n        return base_solution\n\n    # Step 1: Perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of its objectives and dominance rank, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective and dominance rank\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining objectives and dominance rank\n        score = 0.7 * (obj1 + obj2) + 0.3 * (len(archive) - i)  # Weighted combination\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1][::-1]  # Invert segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node insertion\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i-1)%n or j == (i+1)%n:\n            j = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9605750323810036,
            1.3094431161880493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective and dominance rank\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining objectives and dominance rank\n        score = 0.7 * (obj1 + obj2) + 0.3 * (len(archive) - i)  # Weighted combination\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1][::-1]  # Invert segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node insertion\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i-1)%n or j == (i+1)%n:\n            j = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This heuristic function selects a solution from the archive based on a hybrid score combining objective values and edge diversity, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on hybrid score combining objective values and edge diversity\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate edge diversity score\n        edge_diversity = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        # Hybrid score combining objectives and edge diversity\n        score = -(obj1 + obj2) + 0.5 * edge_diversity\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7687965989757717,
            3.0825114846229553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on hybrid score combining objective values and edge diversity\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate edge diversity score\n        edge_diversity = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        # Hybrid score combining objectives and edge diversity\n        score = -(obj1 + obj2) + 0.5 * edge_diversity\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This heuristic function selects a solution from the archive based on the worst objective value (to encourage diversity), then applies a novel two-phase local search combining adaptive segment reversal and objective-biased edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst objective to encourage diversity\n    selected_idx = 0\n    max_worst_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        worst_obj = max(obj1, obj2)\n        if worst_obj > max_worst_obj:\n            max_worst_obj = worst_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Phase 1: Adaptive segment reversal\n    segment_length = min(4, n // 2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Phase 2: Objective-biased edge insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Choose objective to bias insertion based on relative costs\n        obj1_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        obj2_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        if obj1_cost > obj2_cost:\n            # Insert based on first objective\n            temp = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [temp], new_solution[j+1:]])\n        else:\n            # Insert based on second objective\n            temp = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [temp], new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7976990557584676,
            1.1680417656898499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst objective to encourage diversity\n    selected_idx = 0\n    max_worst_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        worst_obj = max(obj1, obj2)\n        if worst_obj > max_worst_obj:\n            max_worst_obj = worst_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Phase 1: Adaptive segment reversal\n    segment_length = min(4, n // 2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Phase 2: Objective-biased edge insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Choose objective to bias insertion based on relative costs\n        obj1_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        obj2_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        if obj1_cost > obj2_cost:\n            # Insert based on first objective\n            temp = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [temp], new_solution[j+1:]])\n        else:\n            # Insert based on second objective\n            temp = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [temp], new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel local search combining node insertion and segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a node and insert it in a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Randomly reverse a segment of the tour\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9154233529336964,
            1.8144797682762146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a node and insert it in a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Randomly reverse a segment of the tour\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective values, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective values\n    selected_idx = 0\n    max_obj = -1\n    for i, (_, (obj1, obj2)) in enumerate(archive):\n        combined_obj = obj1 + obj2\n        if combined_obj > max_obj:\n            max_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    if pos < len(new_solution)-1:\n        new_solution = np.delete(new_solution, pos+1)\n\n    return new_solution\n\n",
        "score": [
            -0.854410550717828,
            0.2900696396827698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective values\n    selected_idx = 0\n    max_obj = -1\n    for i, (_, (obj1, obj2)) in enumerate(archive):\n        combined_obj = obj1 + obj2\n        if combined_obj > max_obj:\n            max_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    if pos < len(new_solution)-1:\n        new_solution = np.delete(new_solution, pos+1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective values, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective values\n    selected_idx = 0\n    max_obj = -1\n    for i, (_, (obj1, obj2)) in enumerate(archive):\n        combined_obj = obj1 + obj2\n        if combined_obj > max_obj:\n            max_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    if pos < len(new_solution)-1:\n        new_solution = np.delete(new_solution, pos+1)\n\n    return new_solution\n\n",
        "score": [
            -0.854410550717828,
            0.2900696396827698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective values\n    selected_idx = 0\n    max_obj = -1\n    for i, (_, (obj1, obj2)) in enumerate(archive):\n        combined_obj = obj1 + obj2\n        if combined_obj > max_obj:\n            max_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    if pos < len(new_solution)-1:\n        new_solution = np.delete(new_solution, pos+1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective improvement potential, then applies a novel local search combining adaptive segment inversion and cross-space edge optimization to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate improvement potential (simplified)\n        potential = (obj1 + obj2) * (1 - min(obj1, obj2) / max(obj1, obj2))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Adaptive segment inversion\n    segment_size = min(4, n // 3)\n    start = random.randint(0, n - segment_size - 1)\n    end = start + segment_size - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Cross-space edge optimization\n    for _ in range(2):\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Evaluate edge in both spaces\n        edge1 = distance_matrix_1[base_solution[i-1]][base_solution[i]] + distance_matrix_1[base_solution[j]][base_solution[(j+1)%n]]\n        edge2 = distance_matrix_2[base_solution[i-1]][base_solution[i]] + distance_matrix_2[base_solution[j]][base_solution[(j+1)%n]]\n\n        new_edge1 = distance_matrix_1[base_solution[i-1]][base_solution[j]] + distance_matrix_1[base_solution[i]][base_solution[(j+1)%n]]\n        new_edge2 = distance_matrix_2[base_solution[i-1]][base_solution[j]] + distance_matrix_2[base_solution[i]][base_solution[(j+1)%n]]\n\n        # Accept if improves at least one objective\n        if (new_edge1 < edge1 or new_edge2 < edge2) and (new_edge1 <= edge1 or new_edge2 <= edge2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.45352798093274976,
            1.420548677444458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate improvement potential (simplified)\n        potential = (obj1 + obj2) * (1 - min(obj1, obj2) / max(obj1, obj2))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Adaptive segment inversion\n    segment_size = min(4, n // 3)\n    start = random.randint(0, n - segment_size - 1)\n    end = start + segment_size - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Cross-space edge optimization\n    for _ in range(2):\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Evaluate edge in both spaces\n        edge1 = distance_matrix_1[base_solution[i-1]][base_solution[i]] + distance_matrix_1[base_solution[j]][base_solution[(j+1)%n]]\n        edge2 = distance_matrix_2[base_solution[i-1]][base_solution[i]] + distance_matrix_2[base_solution[j]][base_solution[(j+1)%n]]\n\n        new_edge1 = distance_matrix_1[base_solution[i-1]][base_solution[j]] + distance_matrix_1[base_solution[i]][base_solution[(j+1)%n]]\n        new_edge2 = distance_matrix_2[base_solution[i-1]][base_solution[j]] + distance_matrix_2[base_solution[i]][base_solution[(j+1)%n]]\n\n        # Accept if improves at least one objective\n        if (new_edge1 < edge1 or new_edge2 < edge2) and (new_edge1 <= edge1 or new_edge2 <= edge2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This heuristic function selects a solution from the archive based on the diversity of its objectives and applies a novel local search strategy combining node reinsertion with a biased edge selection mechanism to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    obj1, obj2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Novel local search: Biased node reinsertion with edge selection\n    # Step 1: Remove a random node\n    remove_idx = random.randint(0, n-1)\n    removed_node = new_solution[remove_idx]\n    remaining = np.delete(new_solution, remove_idx)\n\n    # Step 2: Select insertion position based on both distance matrices\n    min_cost = float('inf')\n    best_pos = 0\n\n    for i in range(len(remaining)):\n        # Calculate combined cost using both distance matrices\n        if i == 0:\n            cost = (distance_matrix_1[remaining[-1], removed_node] + distance_matrix_1[removed_node, remaining[0]]) + \\\n                   (distance_matrix_2[remaining[-1], removed_node] + distance_matrix_2[removed_node, remaining[0]])\n        else:\n            cost = (distance_matrix_1[remaining[i-1], removed_node] + distance_matrix_1[removed_node, remaining[i]]) + \\\n                   (distance_matrix_2[remaining[i-1], removed_node] + distance_matrix_2[removed_node, remaining[i]])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Insert the removed node at the best position\n    new_solution = np.insert(remaining, best_pos, removed_node)\n\n    # Step 3: Apply biased edge selection (swap nodes if they improve both objectives)\n    for _ in range(2):  # Perform 2 biased swaps\n        i, j = random.sample(range(n), 2)\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 and (new_cost2 - old_cost2) < (obj2/10)) or \\\n           (new_cost2 < old_cost2 and (new_cost1 - old_cost1) < (obj1/10)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9018707935030074,
            1.6029242277145386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    obj1, obj2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Novel local search: Biased node reinsertion with edge selection\n    # Step 1: Remove a random node\n    remove_idx = random.randint(0, n-1)\n    removed_node = new_solution[remove_idx]\n    remaining = np.delete(new_solution, remove_idx)\n\n    # Step 2: Select insertion position based on both distance matrices\n    min_cost = float('inf')\n    best_pos = 0\n\n    for i in range(len(remaining)):\n        # Calculate combined cost using both distance matrices\n        if i == 0:\n            cost = (distance_matrix_1[remaining[-1], removed_node] + distance_matrix_1[removed_node, remaining[0]]) + \\\n                   (distance_matrix_2[remaining[-1], removed_node] + distance_matrix_2[removed_node, remaining[0]])\n        else:\n            cost = (distance_matrix_1[remaining[i-1], removed_node] + distance_matrix_1[removed_node, remaining[i]]) + \\\n                   (distance_matrix_2[remaining[i-1], removed_node] + distance_matrix_2[removed_node, remaining[i]])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Insert the removed node at the best position\n    new_solution = np.insert(remaining, best_pos, removed_node)\n\n    # Step 3: Apply biased edge selection (swap nodes if they improve both objectives)\n    for _ in range(2):  # Perform 2 biased swaps\n        i, j = random.sample(range(n), 2)\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 and (new_cost2 - old_cost2) < (obj2/10)) or \\\n           (new_cost2 < old_cost2 and (new_cost1 - old_cost1) < (obj1/10)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search strategy combining segment inversion and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Step 2: Adaptive edge insertion based on distance matrices\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Calculate combined distance cost\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        # Insert j after i if it improves both objectives\n        if cost1 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] and \\\n           cost2 < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]:\n            new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8697368546467766,
            1.3140091300010681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Step 2: Adaptive edge insertion based on distance matrices\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Calculate combined distance cost\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        # Insert j after i if it improves both objectives\n        if cost1 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] and \\\n           cost2 < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]:\n            new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 3-opt and a novel segment inversion operator to generate a neighbor while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    # Step 1: Perform 3-opt (randomly select 3 edges and reconnect them)\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Step 2: Invert a random segment (novel operator)\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8440047479247701,
            1.504401445388794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    # Step 1: Perform 3-opt (randomly select 3 edges and reconnect them)\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Step 2: Invert a random segment (novel operator)\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This heuristic function selects the most under-explored solution from the archive by prioritizing those with low crowding distance and applies a novel local search combining segment inversion and node insertion based on the combined distance metrics to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most under-explored solution (low crowding distance)\n    selected_idx = 0\n    min_crowding = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Simplified crowding distance\n        if crowding < min_crowding:\n            min_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node from elsewhere in the tour\n    node_to_insert = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node_to_insert)\n    if len(new_solution) > n:\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.6734707690744193,
            1.3677189946174622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most under-explored solution (low crowding distance)\n    selected_idx = 0\n    min_crowding = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Simplified crowding distance\n        if crowding < min_crowding:\n            min_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node from elsewhere in the tour\n    node_to_insert = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node_to_insert)\n    if len(new_solution) > n:\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance and applies a novel hybrid local search combining node insertion and segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best dominance (minimizing both objectives)\n    selected_idx = 0\n    min_dominance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        dominance = obj1 + obj2\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    segment = segment[::-1]  # Reverse the segment\n\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node insertion\n    if n > 3:\n        node = random.choice(new_solution)\n        new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    return new_solution\n\n",
        "score": [
            -0.7762801195361653,
            1.7800597548484802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best dominance (minimizing both objectives)\n    selected_idx = 0\n    min_dominance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        dominance = obj1 + obj2\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    segment = segment[::-1]  # Reverse the segment\n\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node insertion\n    if n > 3:\n        node = random.choice(new_solution)\n        new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid scoring function combining objective values and structural diversity, then applies a novel local search combining segment inversion and node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on hybrid scoring\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Hybrid score: combines objective values and structural diversity\n        diversity = len(set(sol[:len(sol)//2]) & set(sol[len(sol)//2:]))\n        score = -(obj1 * 0.7 + obj2 * 0.3) + diversity * 0.1\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)), pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6340646958633203,
            1.8274924755096436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on hybrid scoring\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Hybrid score: combines objective values and structural diversity\n        diversity = len(set(sol[:len(sol)//2]) & set(sol[len(sol)//2:]))\n        score = -(obj1 * 0.7 + obj2 * 0.3) + diversity * 0.1\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)), pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: node insertion + segment reversal\n    # Step 1: Remove a random node and insert it elsewhere\n    remove_idx = random.randint(0, n-1)\n    node = new_solution[remove_idx]\n    remaining = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8951049298361378,
            1.7168217897415161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: node insertion + segment reversal\n    # Step 1: Remove a random node and insert it elsewhere\n    remove_idx = random.randint(0, n-1)\n    node = new_solution[remove_idx]\n    remaining = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining objective values and diversity, then applies a novel local search combining segment inversion and random edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a hybrid score combining objective values and diversity\n        score = (obj1 + obj2) * (1 + random.random() * 0.5)  # Add some randomness for diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and random edge insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Invert the segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8784419977799749,
            1.4133296012878418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a hybrid score combining objective values and diversity\n        score = (obj1 + obj2) * (1 + random.random() * 0.5)  # Add some randomness for diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and random edge insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Invert the segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel \"multi-objective segment inversion\" local search that reverses segments of the tour while prioritizing edges that improve both objectives, ensuring feasibility through careful segment selection and inversion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective values\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Multi-objective segment inversion\n    while True:\n        # Select a random segment\n        seg_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length - 1\n\n        # Check if inversion improves both objectives\n        old_edges = [\n            (base_solution[start-1], base_solution[start]),\n            (base_solution[end], base_solution[(end+1)%n])\n        ]\n        new_edges = [\n            (base_solution[start-1], base_solution[end]),\n            (base_solution[start], base_solution[(end+1)%n])\n        ]\n\n        # Calculate cost change in both objectives\n        cost_change1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]]) - \\\n                      (distance_matrix_1[old_edges[0]] + distance_matrix_1[old_edges[1]])\n        cost_change2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]]) - \\\n                      (distance_matrix_2[old_edges[0]] + distance_matrix_2[old_edges[1]])\n\n        # If inversion improves both objectives, apply it\n        if cost_change1 < 0 and cost_change2 < 0:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n            break\n\n        # If no improvement found after several attempts, do a random inversion\n        if random.random() < 0.1:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9586715551828913,
            1.2981701493263245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective values\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Multi-objective segment inversion\n    while True:\n        # Select a random segment\n        seg_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length - 1\n\n        # Check if inversion improves both objectives\n        old_edges = [\n            (base_solution[start-1], base_solution[start]),\n            (base_solution[end], base_solution[(end+1)%n])\n        ]\n        new_edges = [\n            (base_solution[start-1], base_solution[end]),\n            (base_solution[start], base_solution[(end+1)%n])\n        ]\n\n        # Calculate cost change in both objectives\n        cost_change1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]]) - \\\n                      (distance_matrix_1[old_edges[0]] + distance_matrix_1[old_edges[1]])\n        cost_change2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]]) - \\\n                      (distance_matrix_2[old_edges[0]] + distance_matrix_2[old_edges[1]])\n\n        # If inversion improves both objectives, apply it\n        if cost_change1 < 0 and cost_change2 < 0:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n            break\n\n        # If no improvement found after several attempts, do a random inversion\n        if random.random() < 0.1:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This heuristic selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a novel 4-opt-like local search operator that simultaneously optimizes both objectives by rearranging four randomly selected edges while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and dominance\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted combination of objectives (can be adjusted)\n        score = 0.6 * obj1 + 0.4 * obj2\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Novel 4-opt-like local search operator\n    # Select 4 distinct random positions\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create new solution by rearranging the segment between a and d\n    segment = new_solution[a:d+1]\n    # Reverse the segment and insert it between a and d\n    new_segment = np.concatenate([segment[:b-a], segment[b-a:c-a+1][::-1], segment[c-a+1:]])\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6875233005076473,
            1.812275767326355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and dominance\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted combination of objectives (can be adjusted)\n        score = 0.6 * obj1 + 0.4 * obj2\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Novel 4-opt-like local search operator\n    # Select 4 distinct random positions\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create new solution by rearranging the segment between a and d\n    segment = new_solution[a:d+1]\n    # Reverse the segment and insert it between a and d\n    new_segment = np.concatenate([segment[:b-a], segment[b-a:c-a+1][::-1], segment[c-a+1:]])\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[d+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This heuristic function selects a solution from the archive based on its Pareto rank and applies a novel local search operator that combines path reversal with node insertion, ensuring feasibility by maintaining a valid tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best Pareto rank (simplified by selecting the one with the lowest sum of objectives)\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: path reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node at a different position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility by removing duplicates\n    unique_solution, indices = np.unique(new_solution, return_index=True)\n    if len(unique_solution) < n:\n        # If duplicates exist, replace them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_solution)\n        for i in range(len(new_solution)):\n            if new_solution[i] in missing_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n    return new_solution\n\n",
        "score": [
            -0.8836614070540104,
            0.3057582974433899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best Pareto rank (simplified by selecting the one with the lowest sum of objectives)\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: path reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node at a different position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility by removing duplicates\n    unique_solution, indices = np.unique(new_solution, return_index=True)\n    if len(unique_solution) < n:\n        # If duplicates exist, replace them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_solution)\n        for i in range(len(new_solution)):\n            if new_solution[i] in missing_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This heuristic function selects a solution from the archive based on its objective values and applies a novel local search operator that combines adaptive segment reversal with constrained edge insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and compute score\n        norm_obj1 = obj1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_obj2 = obj2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Constrained edge insertion\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i-j) <= 1 or abs(i-j) >= n-2:\n            j = random.randint(0, n-1)\n        if i > j:\n            i, j = j, i\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            [new_solution[j]],\n            new_solution[i+1:j],\n            [new_solution[i]],\n            new_solution[j+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8682000635668137,
            5.1942437291145325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and compute score\n        norm_obj1 = obj1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_obj2 = obj2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Constrained edge insertion\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i-j) <= 1 or abs(i-j) >= n-2:\n            j = random.randint(0, n-1)\n        if i > j:\n            i, j = j, i\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            [new_solution[j]],\n            new_solution[i+1:j],\n            [new_solution[i]],\n            new_solution[j+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This heuristic function selects a diverse solution from the archive based on both objective values and solution structure, then applies a novel hybrid local search combining segment inversion and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on both objective values and solution structure\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + adaptive edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive edge insertion based on distance matrices\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Calculate combined distance improvement\n        orig_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_dist < orig_dist:\n            # Perform insertion if it improves the combined distance\n            if i < j:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n            else:\n                segment = new_solution[j:i+1]\n                new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.7738582003588415,
            1.896291434764862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on both objective values and solution structure\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + adaptive edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive edge insertion based on distance matrices\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Calculate combined distance improvement\n        orig_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_dist < orig_dist:\n            # Perform insertion if it improves the combined distance\n            if i < j:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n            else:\n                segment = new_solution[j:i+1]\n                new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This heuristic function selects a solution from the archive based on its objective diversity, then applies a novel local search combining adaptive segment reversal and biased edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Biased edge insertion\n    insertion_point = random.randint(0, n-1)\n    node_to_insert = random.choice(new_solution)\n    new_solution = np.insert(new_solution, insertion_point, node_to_insert)\n\n    # Ensure feasibility by removing duplicate\n    unique_indices = np.unique(new_solution, return_index=True)[1]\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.40513621107996045,
            2.1884191632270813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Biased edge insertion\n    insertion_point = random.randint(0, n-1)\n    node_to_insert = random.choice(new_solution)\n    new_solution = np.insert(new_solution, insertion_point, node_to_insert)\n\n    # Ensure feasibility by removing duplicate\n    unique_indices = np.unique(new_solution, return_index=True)[1]\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This heuristic selects a solution from the archive based on the highest combined objective value, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node in a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9783689533325616,
            2.2278709411621094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node in a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This heuristic function selects a solution from the archive based on its diversity in both objective spaces, then applies a novel local search strategy that combines node insertion with multi-objective-aware edge reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on diversity in objective space\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)  # Measure of diversity between objectives\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: Multi-objective-aware node insertion with edge reversal\n    # Step 1: Select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Step 2: Find best insertion position considering both objectives\n    min_cost = float('inf')\n    best_pos = -1\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx + 1) % n:\n            continue\n\n        # Calculate insertion cost in both objectives\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n        # Combine costs using weighted sum (equal weights for simplicity)\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove node and insert at best position\n        new_solution = np.concatenate([\n            new_solution[:node_idx],\n            new_solution[node_idx+1:]\n        ])\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [node],\n            new_solution[best_pos:]\n        ])\n\n    # Step 3: Edge reversal based on multi-objective improvement\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    # Calculate current and reversed edge costs\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n    # Accept reversal if it improves at least one objective\n    if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n        # Perform edge reversal\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5209065190234458,
            2.1637473106384277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on diversity in objective space\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)  # Measure of diversity between objectives\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: Multi-objective-aware node insertion with edge reversal\n    # Step 1: Select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Step 2: Find best insertion position considering both objectives\n    min_cost = float('inf')\n    best_pos = -1\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx + 1) % n:\n            continue\n\n        # Calculate insertion cost in both objectives\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n        # Combine costs using weighted sum (equal weights for simplicity)\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove node and insert at best position\n        new_solution = np.concatenate([\n            new_solution[:node_idx],\n            new_solution[node_idx+1:]\n        ])\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [node],\n            new_solution[best_pos:]\n        ])\n\n    # Step 3: Edge reversal based on multi-objective improvement\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    # Calculate current and reversed edge costs\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n    # Accept reversal if it improves at least one objective\n    if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n        # Perform edge reversal\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of objectives\n    selected_idx = 0\n    max_weighted_sum = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted_sum = 0.6 * obj1 + 0.4 * obj2  # Weighted combination of objectives\n        if weighted_sum > max_weighted_sum:\n            max_weighted_sum = weighted_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n\n    # Invert the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Insert a randomly selected node at a new position\n    node_to_insert = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.8900858180944606,
            1.9220672845840454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of objectives\n    selected_idx = 0\n    max_weighted_sum = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted_sum = 0.6 * obj1 + 0.4 * obj2  # Weighted combination of objectives\n        if weighted_sum > max_weighted_sum:\n            max_weighted_sum = weighted_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n\n    # Invert the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Insert a randomly selected node at a new position\n    node_to_insert = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search combining node insertion and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node insertion + path reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Remove a random node and insert it at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8555561472051987,
            2.299216568470001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node insertion + path reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Remove a random node and insert it at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel scoring function that combines objective values and solution diversity, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel selection based on objective values and diversity\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining objectives and diversity\n        score = - (obj1 * 0.6 + obj2 * 0.4) * (1 + len(set(sol)) / len(sol))\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]  # Invert segment\n\n    # Insert a random node at a new position\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)[0][0]), pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7491948410095983,
            2.374899208545685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel selection based on objective values and diversity\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining objectives and diversity\n        score = - (obj1 * 0.6 + obj2 * 0.4) * (1 + len(set(sol)) / len(sol))\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]  # Invert segment\n\n    # Insert a random node at a new position\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)[0][0]), pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and solution diversity, then applies a novel local search operator that combines a 3-opt move with a segment inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Combine objectives and add diversity factor\n        score = -(obj1 + obj2) + 0.1 * np.std(sol)\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    # Step 1: Select three random edges and perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([], dtype=int)\n    segment3 = np.concatenate([segment3, new_solution[:a]])\n\n    # Reconnect segments in different order\n    new_order = [segment1, segment2, segment3]\n    random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6791097788543898,
            2.4820922017097473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Combine objectives and add diversity factor\n        score = -(obj1 + obj2) + 0.1 * np.std(sol)\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    # Step 1: Select three random edges and perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([], dtype=int)\n    segment3 = np.concatenate([segment3, new_solution[:a]])\n\n    # Reconnect segments in different order\n    new_order = [segment1, segment2, segment3]\n    random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with high dominance rank and low objective values, then applies a hybrid local search combining 3-opt and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance rank and objective values\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + segment inversion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n-1 else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7098667819116916,
            1.2647442817687988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance rank and objective values\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + segment inversion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n-1 else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and node centrality, then applies a novel local search combining adaptive segment reversal and distance-aware edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective values and centrality\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate centrality score (simplified)\n        centrality = obj1 * 0.3 + obj2 * 0.7  # Weighted combination\n        if centrality < best_score:\n            best_score = centrality\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = max(2, min(5, n // 4))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Distance-aware edge insertion\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        # Calculate distance in both spaces\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if dist1 < distance_matrix_1[new_solution[i-1], new_solution[i]] * 1.2 or dist2 < distance_matrix_2[new_solution[i-1], new_solution[i]] * 1.2:\n            # Insert edge if it's significantly shorter\n            new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:]])\n            if len(new_solution) > n:\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.6212991426561043,
            0.7668756246566772
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective values and centrality\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate centrality score (simplified)\n        centrality = obj1 * 0.3 + obj2 * 0.7  # Weighted combination\n        if centrality < best_score:\n            best_score = centrality\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = max(2, min(5, n // 4))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Distance-aware edge insertion\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        # Calculate distance in both spaces\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if dist1 < distance_matrix_1[new_solution[i-1], new_solution[i]] * 1.2 or dist2 < distance_matrix_2[new_solution[i-1], new_solution[i]] * 1.2:\n            # Insert edge if it's significantly shorter\n            new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:]])\n            if len(new_solution) > n:\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid score combining objective values and dominance rank, then applies a novel local search combining segment reversal and node insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on hybrid score (objective sum + dominance rank)\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        dominance_rank = sum(1 for s, (o1, o2) in archive if (o1 <= obj1 and o2 < obj2) or (o1 < obj1 and o2 <= obj2))\n        score = (obj1 + obj2) / (dominance_rank + 1)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1][::-1]  # Reverse the segment\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Insert a random node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_insert], new_solution[insert_pos:]])\n\n    # Ensure no duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.where(new_solution == -1)[0][0] if -1 in new_solution else random.randint(0, n-1)\n            new_solution[pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.921873802566874,
            4.7969982624053955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on hybrid score (objective sum + dominance rank)\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        dominance_rank = sum(1 for s, (o1, o2) in archive if (o1 <= obj1 and o2 < obj2) or (o1 < obj1 and o2 <= obj2))\n        score = (obj1 + obj2) / (dominance_rank + 1)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1][::-1]  # Reverse the segment\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Insert a random node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_insert], new_solution[insert_pos:]])\n\n    # Ensure no duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.where(new_solution == -1)[0][0] if -1 in new_solution else random.randint(0, n-1)\n            new_solution[pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This heuristic function selects a solution from the archive based on its balance between objective values and applies a novel local search combining path inversion and segment reversal, ensuring feasibility by maintaining tour continuity and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on balanced objective values\n    selected_idx = 0\n    min_balance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        balance = abs(obj1 - obj2)  # Balance between objectives\n        if balance < min_balance:\n            min_balance = balance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: path inversion and segment reversal\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Reverse a different random segment\n    if n >= 4:\n        start2 = random.randint(0, n-3)\n        end2 = random.randint(start2+1, n-2)\n        segment2 = new_solution[start2:end2+1]\n        new_solution[start2:end2+1] = segment2[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9384251567546664,
            2.169889271259308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on balanced objective values\n    selected_idx = 0\n    min_balance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        balance = abs(obj1 - obj2)  # Balance between objectives\n        if balance < min_balance:\n            min_balance = balance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: path inversion and segment reversal\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Reverse a different random segment\n    if n >= 4:\n        start2 = random.randint(0, n-3)\n        end2 = random.randint(start2+1, n-2)\n        segment2 = new_solution[start2:end2+1]\n        new_solution[start2:end2+1] = segment2[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel \"cross-space segment inversion\" operator that reverses a segment of the tour and maps it to the other objective space by swapping coordinates, ensuring feasibility while potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Cross-space segment inversion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Reverse the segment\n    segment = new_solution[start:end+1][::-1]\n\n    # Map to other objective space by swapping coordinates\n    for i in range(start, end+1):\n        node_id = new_solution[i]\n        x1, y1, x2, y2 = instance[node_id]\n        # Swap coordinates between spaces\n        instance[node_id] = [x2, y2, x1, y1]\n\n    # Reconstruct the solution with inverted segment\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9244064224053699,
            2.2828513383865356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Cross-space segment inversion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Reverse the segment\n    segment = new_solution[start:end+1][::-1]\n\n    # Map to other objective space by swapping coordinates\n    for i in range(start, end+1):\n        node_id = new_solution[i]\n        x1, y1, x2, y2 = instance[node_id]\n        # Swap coordinates between spaces\n        instance[node_id] = [x2, y2, x1, y1]\n\n    # Reconstruct the solution with inverted segment\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values (assuming higher values indicate more potential for improvement)\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        total_obj = obj1 + obj2\n        if total_obj > max_obj:\n            max_obj = total_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a random position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.958844989299724,
            2.339113175868988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values (assuming higher values indicate more potential for improvement)\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        total_obj = obj1 + obj2\n        if total_obj > max_obj:\n            max_obj = total_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a random position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic score combining normalized objective values and solution quality, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on dynamic score combining objectives and solution quality\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives\n        norm_obj1 = obj1 / (sum(o[0] for o in [a[1] for a in archive]) / len(archive))\n        norm_obj2 = obj2 / (sum(o[1] for o in [a[1] for a in archive]) / len(archive))\n        # Calculate solution quality (inverse of total tour length)\n        tour_len = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol))) + \\\n                   sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        quality = 1 / tour_len\n        # Dynamic score\n        score = (norm_obj1 + norm_obj2) * quality\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6761659577285304,
            9.567692458629608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on dynamic score combining objectives and solution quality\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives\n        norm_obj1 = obj1 / (sum(o[0] for o in [a[1] for a in archive]) / len(archive))\n        norm_obj2 = obj2 / (sum(o[1] for o in [a[1] for a in archive]) / len(archive))\n        # Calculate solution quality (inverse of total tour length)\n        tour_len = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol))) + \\\n                   sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        quality = 1 / tour_len\n        # Dynamic score\n        score = (norm_obj1 + norm_obj2) * quality\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel local search operator that combines cross-space edge insertion with intra-segment reversal to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (minimizing both objectives)\n    selected_idx = 0\n    min_potential = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate improvement potential (simplified)\n        potential = obj1 + obj2\n        if potential < min_potential:\n            min_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: cross-space edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random edge and insert it in a different position\n    i = random.randint(0, n-2)\n    edge = new_solution[i:i+2]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+2:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], edge, new_solution[insert_pos:]])\n\n    # Step 2: Reverse a random segment to explore different configurations\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.89705985463926,
            2.121375799179077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (minimizing both objectives)\n    selected_idx = 0\n    min_potential = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate improvement potential (simplified)\n        potential = obj1 + obj2\n        if potential < min_potential:\n            min_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: cross-space edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random edge and insert it in a different position\n    i = random.randint(0, n-2)\n    edge = new_solution[i:i+2]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+2:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], edge, new_solution[insert_pos:]])\n\n    # Step 2: Reverse a random segment to explore different configurations\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This heuristic function selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining segment inversion and random inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        combined_obj = obj1 + obj2\n        if combined_obj > max_obj:\n            max_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + random inversion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Perform a random segment inversion\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, min(i+3, n-1))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8750203930090681,
            2.1914555430412292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        combined_obj = obj1 + obj2\n        if combined_obj > max_obj:\n            max_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + random inversion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Perform a random segment inversion\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, min(i+3, n-1))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This heuristic selects a solution with the highest combined crowding distance and objective values, then applies a novel two-stage local search combining adaptive segment reversal and objective-balanced edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined crowding distance and objective values\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining crowding distance and objective values\n        score = obj1 + obj2 + (obj1 * obj2) / (obj1 + obj2 + 1e-6)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Stage 1: Adaptive segment reversal based on objective imbalance\n    obj1_total = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj2_total = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    imbalance = abs(obj1_total - obj2_total) / (obj1_total + obj2_total + 1e-6)\n\n    if imbalance > 0.3:  # If objectives are imbalanced\n        # Select segment to reverse based on which objective is worse\n        if obj1_total > obj2_total:\n            # Reverse segment that would most improve obj2\n            best_improvement = 0\n            best_start = 0\n            best_end = 0\n            for start in range(n):\n                for end in range(start+2, min(start+7, n)):\n                    segment = base_solution[start:end+1]\n                    reversed_segment = segment[::-1]\n                    original_cost = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                    reversed_cost = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n                    improvement = original_cost - reversed_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_start = start\n                        best_end = end\n            if best_improvement > 0:\n                new_solution[best_start:best_end+1] = new_solution[best_start:best_end+1][::-1]\n        else:\n            # Reverse segment that would most improve obj1\n            best_improvement = 0\n            best_start = 0\n            best_end = 0\n            for start in range(n):\n                for end in range(start+2, min(start+7, n)):\n                    segment = base_solution[start:end+1]\n                    reversed_segment = segment[::-1]\n                    original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                    reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n                    improvement = original_cost - reversed_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_start = start\n                        best_end = end\n            if best_improvement > 0:\n                new_solution[best_start:best_end+1] = new_solution[best_start:best_end+1][::-1]\n\n    # Stage 2: Objective-balanced edge insertion\n    for _ in range(3):  # Perform multiple insertions\n        # Find edge that would most balance the objectives\n        best_balance = 0\n        best_i = 0\n        best_j = 0\n        for i in range(n):\n            for j in range(i+2, min(i+7, n)):\n                if j == i+1:\n                    continue\n                # Calculate potential improvement in both objectives\n                original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                improvement1 = original_cost1 - new_cost1\n\n                original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                improvement2 = original_cost2 - new_cost2\n\n                # Calculate balance score\n                balance = min(improvement1, improvement2) / (max(improvement1, improvement2) + 1e-6)\n\n                if balance > best_balance:\n                    best_balance = balance\n                    best_i = i\n                    best_j = j\n\n        if best_balance > 0:\n            # Perform the insertion\n            segment = new_solution[best_i+1:best_j+1]\n            new_solution = np.concatenate([new_solution[:best_i+1], segment[::-1], new_solution[best_j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9581130822977486,
            13.224740862846375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined crowding distance and objective values\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining crowding distance and objective values\n        score = obj1 + obj2 + (obj1 * obj2) / (obj1 + obj2 + 1e-6)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Stage 1: Adaptive segment reversal based on objective imbalance\n    obj1_total = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj2_total = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    imbalance = abs(obj1_total - obj2_total) / (obj1_total + obj2_total + 1e-6)\n\n    if imbalance > 0.3:  # If objectives are imbalanced\n        # Select segment to reverse based on which objective is worse\n        if obj1_total > obj2_total:\n            # Reverse segment that would most improve obj2\n            best_improvement = 0\n            best_start = 0\n            best_end = 0\n            for start in range(n):\n                for end in range(start+2, min(start+7, n)):\n                    segment = base_solution[start:end+1]\n                    reversed_segment = segment[::-1]\n                    original_cost = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                    reversed_cost = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n                    improvement = original_cost - reversed_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_start = start\n                        best_end = end\n            if best_improvement > 0:\n                new_solution[best_start:best_end+1] = new_solution[best_start:best_end+1][::-1]\n        else:\n            # Reverse segment that would most improve obj1\n            best_improvement = 0\n            best_start = 0\n            best_end = 0\n            for start in range(n):\n                for end in range(start+2, min(start+7, n)):\n                    segment = base_solution[start:end+1]\n                    reversed_segment = segment[::-1]\n                    original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                    reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n                    improvement = original_cost - reversed_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_start = start\n                        best_end = end\n            if best_improvement > 0:\n                new_solution[best_start:best_end+1] = new_solution[best_start:best_end+1][::-1]\n\n    # Stage 2: Objective-balanced edge insertion\n    for _ in range(3):  # Perform multiple insertions\n        # Find edge that would most balance the objectives\n        best_balance = 0\n        best_i = 0\n        best_j = 0\n        for i in range(n):\n            for j in range(i+2, min(i+7, n)):\n                if j == i+1:\n                    continue\n                # Calculate potential improvement in both objectives\n                original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                improvement1 = original_cost1 - new_cost1\n\n                original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                improvement2 = original_cost2 - new_cost2\n\n                # Calculate balance score\n                balance = min(improvement1, improvement2) / (max(improvement1, improvement2) + 1e-6)\n\n                if balance > best_balance:\n                    best_balance = balance\n                    best_i = i\n                    best_j = j\n\n        if best_balance > 0:\n            # Perform the insertion\n            segment = new_solution[best_i+1:best_j+1]\n            new_solution = np.concatenate([new_solution[:best_i+1], segment[::-1], new_solution[best_j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel local search combining segment reversal and non-sequential edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal + non-sequential edge insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random edge from elsewhere in the tour\n    i, j = random.sample(range(n), 2)\n    node = new_solution[j]\n    new_solution = np.insert(new_solution, i, node)\n    if i < j:\n        new_solution = np.delete(new_solution, j+1)\n    else:\n        new_solution = np.delete(new_solution, j)\n\n    return new_solution\n\n",
        "score": [
            -0.7993524012796263,
            2.5402753949165344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal + non-sequential edge insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random edge from elsewhere in the tour\n    i, j = random.sample(range(n), 2)\n    node = new_solution[j]\n    new_solution = np.insert(new_solution, i, node)\n    if i < j:\n        new_solution = np.delete(new_solution, j+1)\n    else:\n        new_solution = np.delete(new_solution, j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a combined score (weighted sum of normalized objectives)\n        score = 0.6 * (obj1 / distance_matrix_1.max()) + 0.4 * (obj2 / distance_matrix_2.max())\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9557186277708959,
            4.85713928937912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a combined score (weighted sum of normalized objectives)\n        score = 0.6 * (obj1 / distance_matrix_1.max()) + 0.4 * (obj2 / distance_matrix_2.max())\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9990411789699795,
            1.4024575352668762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9990411789699795,
            1.4024575352668762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest combined objective value, then applies a novel local search that combines segment inversion and node insertion, ensuring feasibility by maintaining the tour's continuity and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9618340076903459,
            1.5866951942443848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value (sum of both objectives), then applies a novel \"multi-objective segment inversion\" operator that inverts a random segment of the tour while considering both distance matrices to ensure balanced improvement across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Multi-objective segment inversion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n    # Decide inversion based on which objective is worse\n    if segment_cost1 > segment_cost2:\n        segment = segment[::-1]  # Invert if first objective is worse\n    else:\n        # For second objective, invert only if segment length is odd\n        if len(segment) % 2 != 0:\n            segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9611870748198375,
            1.688582718372345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Multi-objective segment inversion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n    # Decide inversion based on which objective is worse\n    if segment_cost1 > segment_cost2:\n        segment = segment[::-1]  # Invert if first objective is worse\n    else:\n        # For second objective, invert only if segment length is odd\n        if len(segment) % 2 != 0:\n            segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node at a random position\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure no duplicates (remove first occurrence of duplicate)\n    unique, indices = np.unique(new_solution, return_index=True)\n    if len(unique) < n:\n        duplicate = new_solution[np.where(new_solution == new_solution[indices])[0][1]]\n        new_solution = np.delete(new_solution, np.where(new_solution == duplicate)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.9500253580938407,
            0.33141255378723145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node at a random position\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure no duplicates (remove first occurrence of duplicate)\n    unique, indices = np.unique(new_solution, return_index=True)\n    if len(unique) < n:\n        duplicate = new_solution[np.where(new_solution == new_solution[indices])[0][1]]\n        new_solution = np.delete(new_solution, np.where(new_solution == duplicate)[0][0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining 3-opt and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on weighted objective and dominance\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate dominance rank (simplified)\n        dominated = 0\n        for j, (_, (o1, o2)) in enumerate(archive):\n            if i != j and o1 <= obj1 and o2 <= obj2 and (o1 < obj1 or o2 < obj2):\n                dominated += 1\n        score = (obj1 + obj2) / (dominated + 1)  # Weighted by dominance\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + segment inversion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: 3-opt operation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Step 2: Segment inversion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6398117110898408,
            1.7506985068321228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on weighted objective and dominance\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate dominance rank (simplified)\n        dominated = 0\n        for j, (_, (o1, o2)) in enumerate(archive):\n            if i != j and o1 <= obj1 and o2 <= obj2 and (o1 < obj1 or o2 < obj2):\n                dominated += 1\n        score = (obj1 + obj2) / (dominated + 1)  # Weighted by dominance\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + segment inversion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: 3-opt operation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Step 2: Segment inversion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic selection criterion combining objective values and diversity, then applies a hybrid local search combining node insertion and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a dynamic criterion (combination of objective values and diversity)\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objective values and diversity\n        score = - (obj1 + obj2) * (1 + random.uniform(0, 0.5))  # Encourages exploration of non-dominated solutions\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node insertion + edge reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a node and insert it in a different position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment of the tour\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8558123036523717,
            1.5615779161453247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a dynamic criterion (combination of objective values and diversity)\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objective values and diversity\n        score = - (obj1 + obj2) * (1 + random.uniform(0, 0.5))  # Encourages exploration of non-dominated solutions\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node insertion + edge reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a node and insert it in a different position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment of the tour\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_idx = 0\n    min_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = weights[0] * obj1 + weights[1] * obj2\n        # Adjust score based on dominance rank (simplified)\n        if score < min_score:\n            min_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + node insertion\n    # Step 1: Perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c:]\n\n    # Try different combinations\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n\n    # Step 2: Perform node insertion\n    node = random.choice(new_solution)\n    mask = new_solution != node\n    remaining = new_solution[mask]\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6918525219081985,
            0.16259771585464478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_idx = 0\n    min_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = weights[0] * obj1 + weights[1] * obj2\n        # Adjust score based on dominance rank (simplified)\n        if score < min_score:\n            min_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + node insertion\n    # Step 1: Perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c:]\n\n    # Try different combinations\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n\n    # Step 2: Perform node insertion\n    node = random.choice(new_solution)\n    mask = new_solution != node\n    remaining = new_solution[mask]\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_idx = 0\n    min_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = weights[0] * obj1 + weights[1] * obj2\n        # Adjust score based on dominance rank (simplified)\n        if score < min_score:\n            min_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + node insertion\n    # Step 1: Perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c:]\n\n    # Try different combinations\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n\n    # Step 2: Perform node insertion\n    node = random.choice(new_solution)\n    mask = new_solution != node\n    remaining = new_solution[mask]\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6918525219081985,
            0.16259771585464478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_idx = 0\n    min_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = weights[0] * obj1 + weights[1] * obj2\n        # Adjust score based on dominance rank (simplified)\n        if score < min_score:\n            min_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + node insertion\n    # Step 1: Perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c:]\n\n    # Try different combinations\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n\n    # Step 2: Perform node insertion\n    node = random.choice(new_solution)\n    mask = new_solution != node\n    remaining = new_solution[mask]\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a hybrid local search combining segment inversion and random node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted score with dominance consideration\n        score = -(obj1 * 0.7 + obj2 * 0.3)  # Higher weights for better solutions\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + random node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    segment = segment[::-1]  # Invert the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Randomly insert a node to maintain diversity\n    if n > 3:\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8901607458041505,
            0.22294431924819946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted score with dominance consideration\n        score = -(obj1 * 0.7 + obj2 * 0.3)  # Higher weights for better solutions\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + random node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    segment = segment[::-1]  # Invert the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Randomly insert a node to maintain diversity\n    if n > 3:\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and solution diversity, then applies a novel local search operator that combines node insertion with a dynamic segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search operator: dynamic segment reversal with node insertion\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure no duplicates by removing the original node\n    mask = np.ones(n+1, dtype=bool)\n    _, indices = np.unique(new_solution, return_index=True)\n    mask[indices] = False\n    new_solution = new_solution[mask]\n\n    return new_solution\n\n",
        "score": [
            -0.928966529316405,
            0.13533997535705566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search operator: dynamic segment reversal with node insertion\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure no duplicates by removing the original node\n    mask = np.ones(n+1, dtype=bool)\n    _, indices = np.unique(new_solution, return_index=True)\n    mask[indices] = False\n    new_solution = new_solution[mask]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and solution diversity, then applies a novel local search operator that combines node insertion with a dynamic segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search operator: dynamic segment reversal with node insertion\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure no duplicates by removing the original node\n    mask = np.ones(n+1, dtype=bool)\n    _, indices = np.unique(new_solution, return_index=True)\n    mask[indices] = False\n    new_solution = new_solution[mask]\n\n    return new_solution\n\n",
        "score": [
            -0.928966529316405,
            0.13533997535705566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search operator: dynamic segment reversal with node insertion\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure no duplicates by removing the original node\n    mask = np.ones(n+1, dtype=bool)\n    _, indices = np.unique(new_solution, return_index=True)\n    mask[indices] = False\n    new_solution = new_solution[mask]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel hybrid local search combining segment inversion and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and diversity metrics\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj1 + obj2) * (1 + np.random.rand()) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel hybrid local search: segment inversion + adaptive edge swapping\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Adaptive edge swapping based on distance metrics\n    for _ in range(min(3, n//2)):\n        i = random.randint(0, n-2)\n        j = i + 1\n        # Calculate combined distance in both objectives\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_dist1 + new_dist2) < (dist1 + dist2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8356715985661107,
            2.2839434146881104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and diversity metrics\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj1 + obj2) * (1 + np.random.rand()) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel hybrid local search: segment inversion + adaptive edge swapping\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Adaptive edge swapping based on distance metrics\n    for _ in range(min(3, n//2)):\n        i = random.randint(0, n-2)\n        j = i + 1\n        # Calculate combined distance in both objectives\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_dist1 + new_dist2) < (dist1 + dist2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest average distance improvement potential in both objective spaces, then applies a novel local search operator that combines segment inversion with probabilistic edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average distance improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential improvement (simplified)\n        potential = (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]]) / 2\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion with probabilistic insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]  # Invert segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Probabilistic insertion\n    if random.random() < 0.7:  # 70% chance to insert at random position\n        insert_pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n    else:  # 30% chance to insert at position that minimizes distance increase\n        min_increase = float('inf')\n        best_pos = 0\n        for i in range(len(remaining)):\n            total_increase = 0\n            if i > 0:\n                total_increase += distance_matrix_1[remaining[i-1], segment[0]] + distance_matrix_2[remaining[i-1], segment[0]]\n            if i < len(remaining)-1:\n                total_increase += distance_matrix_1[segment[-1], remaining[i+1]] + distance_matrix_2[segment[-1], remaining[i+1]]\n            if total_increase < min_increase:\n                min_increase = total_increase\n                best_pos = i\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5601645861239974,
            2.74067360162735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average distance improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential improvement (simplified)\n        potential = (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]]) / 2\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion with probabilistic insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]  # Invert segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Probabilistic insertion\n    if random.random() < 0.7:  # 70% chance to insert at random position\n        insert_pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n    else:  # 30% chance to insert at position that minimizes distance increase\n        min_increase = float('inf')\n        best_pos = 0\n        for i in range(len(remaining)):\n            total_increase = 0\n            if i > 0:\n                total_increase += distance_matrix_1[remaining[i-1], segment[0]] + distance_matrix_2[remaining[i-1], segment[0]]\n            if i < len(remaining)-1:\n                total_increase += distance_matrix_1[segment[-1], remaining[i+1]] + distance_matrix_2[segment[-1], remaining[i+1]]\n            if total_increase < min_increase:\n                min_increase = total_increase\n                best_pos = i\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel local search strategy combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential for improvement\n        potential = (obj1 + obj2) / (1 + np.sum(distance_matrix_1[sol[:-1], sol[1:]] + distance_matrix_2[sol[:-1], sol[1:]]))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node elsewhere\n    node_to_move = random.choice(new_solution)\n    mask = new_solution != node_to_move\n    remaining = new_solution[mask]\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node_to_move], remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5837495167080521,
            4.783092617988586
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential for improvement\n        potential = (obj1 + obj2) / (1 + np.sum(distance_matrix_1[sol[:-1], sol[1:]] + distance_matrix_2[sol[:-1], sol[1:]]))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node elsewhere\n    node_to_move = random.choice(new_solution)\n    mask = new_solution != node_to_move\n    remaining = new_solution[mask]\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node_to_move], remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This heuristic function selects a solution from the archive based on its dominance and diversity, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines dominance and diversity\n        score = obj1 + obj2 - (sum(obj1 for _, (o1, _) in archive)/len(archive) + sum(obj2 for _, (_, o2) in archive)/len(archive))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9089205025500524,
            7.42334109544754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines dominance and diversity\n        score = obj1 + obj2 - (sum(obj1 for _, (o1, _) in archive)/len(archive) + sum(obj2 for _, (_, o2) in archive)/len(archive))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of its objective values and a novel local search strategy that combines segment rotation, node relocation, and a biased random walk to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = random.randint(0, len(archive)-1)\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        if obj1 + obj2 < archive[selected_idx][1][0] + archive[selected_idx][1][1]:\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Relocate a node to a position biased by distance\n    node = random.choice(new_solution)\n    current_pos = np.where(new_solution == node)[0][0]\n    new_solution = new_solution[new_solution != node]\n\n    # Calculate insertion positions biased by distance to neighbors\n    insertion_weights = []\n    for i in range(len(new_solution)+1):\n        if i == 0:\n            left = new_solution[-1]\n            right = new_solution[0]\n        elif i == len(new_solution):\n            left = new_solution[-1]\n            right = new_solution[0]\n        else:\n            left = new_solution[i-1]\n            right = new_solution[i]\n\n        # Weight by both objectives\n        weight = (distance_matrix_1[left, node] + distance_matrix_1[node, right] +\n                 distance_matrix_2[left, node] + distance_matrix_2[node, right])\n        insertion_weights.append(1/weight)\n\n    # Normalize weights\n    total = sum(insertion_weights)\n    weights = [w/total for w in insertion_weights]\n\n    insert_pos = random.choices(range(len(new_solution)+1), weights=weights)[0]\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7089991042689952,
            1.8914585709571838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = random.randint(0, len(archive)-1)\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        if obj1 + obj2 < archive[selected_idx][1][0] + archive[selected_idx][1][1]:\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Relocate a node to a position biased by distance\n    node = random.choice(new_solution)\n    current_pos = np.where(new_solution == node)[0][0]\n    new_solution = new_solution[new_solution != node]\n\n    # Calculate insertion positions biased by distance to neighbors\n    insertion_weights = []\n    for i in range(len(new_solution)+1):\n        if i == 0:\n            left = new_solution[-1]\n            right = new_solution[0]\n        elif i == len(new_solution):\n            left = new_solution[-1]\n            right = new_solution[0]\n        else:\n            left = new_solution[i-1]\n            right = new_solution[i]\n\n        # Weight by both objectives\n        weight = (distance_matrix_1[left, node] + distance_matrix_1[node, right] +\n                 distance_matrix_2[left, node] + distance_matrix_2[node, right])\n        insertion_weights.append(1/weight)\n\n    # Normalize weights\n    total = sum(insertion_weights)\n    weights = [w/total for w in insertion_weights]\n\n    insert_pos = random.choices(range(len(new_solution)+1), weights=weights)[0]\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective and dominance\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = weights[0] * obj1 + weights[1] * obj2\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_to_move = random.randint(0, n-1)\n    insert_pos = random.randint(0, n-1)\n    if insert_pos > node_to_move:\n        insert_pos -= 1\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        np.array([new_solution[node_to_move]]),\n        new_solution[:node_to_move],\n        new_solution[node_to_move+1:insert_pos+1],\n        new_solution[insert_pos+1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.8983996768537714,
            0.11887216567993164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective and dominance\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = weights[0] * obj1 + weights[1] * obj2\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_to_move = random.randint(0, n-1)\n    insert_pos = random.randint(0, n-1)\n    if insert_pos > node_to_move:\n        insert_pos -= 1\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        np.array([new_solution[node_to_move]]),\n        new_solution[:node_to_move],\n        new_solution[node_to_move+1:insert_pos+1],\n        new_solution[insert_pos+1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective and dominance\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = weights[0] * obj1 + weights[1] * obj2\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_to_move = random.randint(0, n-1)\n    insert_pos = random.randint(0, n-1)\n    if insert_pos > node_to_move:\n        insert_pos -= 1\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        np.array([new_solution[node_to_move]]),\n        new_solution[:node_to_move],\n        new_solution[node_to_move+1:insert_pos+1],\n        new_solution[insert_pos+1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.8983996768537714,
            0.11887216567993164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective and dominance\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = weights[0] * obj1 + weights[1] * obj2\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_to_move = random.randint(0, n-1)\n    insert_pos = random.randint(0, n-1)\n    if insert_pos > node_to_move:\n        insert_pos -= 1\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        np.array([new_solution[node_to_move]]),\n        new_solution[:node_to_move],\n        new_solution[node_to_move+1:insert_pos+1],\n        new_solution[insert_pos+1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This heuristic function selects a solution from the archive using a hybrid of dominance-based selection and adaptive segment replacement, then applies a novel local search combining random segment reversal and adaptive node swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using dominance-based selection with adaptive threshold\n    selected_idx = 0\n    best_obj = archive[0][1]\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        if obj1 <= best_obj[0] and obj2 <= best_obj[1] and (obj1 < best_obj[0] or obj2 < best_obj[1]):\n            selected_idx = i\n            best_obj = (obj1, obj2)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Random segment reversal with adaptive length\n    segment_length = min(random.randint(2, 5), n-1)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive node swap based on distance matrices\n    swap_pos1, swap_pos2 = random.sample(range(n), 2)\n    node1, node2 = new_solution[swap_pos1], new_solution[swap_pos2]\n\n    # Calculate improvement in both objectives\n    delta1 = (distance_matrix_1[new_solution[swap_pos1-1], node2] + distance_matrix_1[node2, new_solution[(swap_pos1+1)%n]] +\n              distance_matrix_1[new_solution[swap_pos2-1], node1] + distance_matrix_1[node1, new_solution[(swap_pos2+1)%n]]) - \\\n             (distance_matrix_1[new_solution[swap_pos1-1], node1] + distance_matrix_1[node1, new_solution[(swap_pos1+1)%n]] +\n              distance_matrix_1[new_solution[swap_pos2-1], node2] + distance_matrix_1[node2, new_solution[(swap_pos2+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[swap_pos1-1], node2] + distance_matrix_2[node2, new_solution[(swap_pos1+1)%n]] +\n              distance_matrix_2[new_solution[swap_pos2-1], node1] + distance_matrix_2[node1, new_solution[(swap_pos2+1)%n]]) - \\\n             (distance_matrix_2[new_solution[swap_pos1-1], node1] + distance_matrix_2[node1, new_solution[(swap_pos1+1)%n]] +\n              distance_matrix_2[new_solution[swap_pos2-1], node2] + distance_matrix_2[node2, new_solution[(swap_pos2+1)%n]])\n\n    # Only swap if it improves at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.917310916089747,
            1.8530266284942627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using dominance-based selection with adaptive threshold\n    selected_idx = 0\n    best_obj = archive[0][1]\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        if obj1 <= best_obj[0] and obj2 <= best_obj[1] and (obj1 < best_obj[0] or obj2 < best_obj[1]):\n            selected_idx = i\n            best_obj = (obj1, obj2)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Random segment reversal with adaptive length\n    segment_length = min(random.randint(2, 5), n-1)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive node swap based on distance matrices\n    swap_pos1, swap_pos2 = random.sample(range(n), 2)\n    node1, node2 = new_solution[swap_pos1], new_solution[swap_pos2]\n\n    # Calculate improvement in both objectives\n    delta1 = (distance_matrix_1[new_solution[swap_pos1-1], node2] + distance_matrix_1[node2, new_solution[(swap_pos1+1)%n]] +\n              distance_matrix_1[new_solution[swap_pos2-1], node1] + distance_matrix_1[node1, new_solution[(swap_pos2+1)%n]]) - \\\n             (distance_matrix_1[new_solution[swap_pos1-1], node1] + distance_matrix_1[node1, new_solution[(swap_pos1+1)%n]] +\n              distance_matrix_1[new_solution[swap_pos2-1], node2] + distance_matrix_1[node2, new_solution[(swap_pos2+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[swap_pos1-1], node2] + distance_matrix_2[node2, new_solution[(swap_pos1+1)%n]] +\n              distance_matrix_2[new_solution[swap_pos2-1], node1] + distance_matrix_2[node1, new_solution[(swap_pos2+1)%n]]) - \\\n             (distance_matrix_2[new_solution[swap_pos1-1], node1] + distance_matrix_2[node1, new_solution[(swap_pos1+1)%n]] +\n              distance_matrix_2[new_solution[swap_pos2-1], node2] + distance_matrix_2[node2, new_solution[(swap_pos2+1)%n]])\n\n    # Only swap if it improves at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and dominance, then applies a novel local search strategy combining segment inversion and node reinsertion to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = random.randint(0, len(archive)-1)\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        if obj1 <= archive[selected_idx][1][0] and obj2 <= archive[selected_idx][1][1]:\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node reinsertion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7526633701908709,
            2.2400776743888855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = random.randint(0, len(archive)-1)\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        if obj1 <= archive[selected_idx][1][0] and obj2 <= archive[selected_idx][1][1]:\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node reinsertion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance count, then applies a hybrid local search combining node insertion and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance count\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate dominance count (simplified)\n        dominance = sum(1 for (_, (o1, o2)) in archive if (o1 <= obj1 and o2 < obj2) or (o1 < obj1 and o2 <= obj2))\n        score = (0.7 * obj1 + 0.3 * obj2) / (1 + dominance)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node insertion + path reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Insert a random node at a random position\n    node = random.choice(base_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure no duplicates by removing the first occurrence of the node after insertion\n    mask = np.ones(len(new_solution), dtype=bool)\n    mask[np.where(new_solution == node)[0][1:]] = False\n    new_solution = new_solution[mask]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7907443641743546,
            2.146880805492401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance count\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate dominance count (simplified)\n        dominance = sum(1 for (_, (o1, o2)) in archive if (o1 <= obj1 and o2 < obj2) or (o1 < obj1 and o2 <= obj2))\n        score = (0.7 * obj1 + 0.3 * obj2) / (1 + dominance)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node insertion + path reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Insert a random node at a random position\n    node = random.choice(base_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure no duplicates by removing the first occurrence of the node after insertion\n    mask = np.ones(len(new_solution), dtype=bool)\n    mask[np.where(new_solution == node)[0][1:]] = False\n    new_solution = new_solution[mask]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of crowding distance and dominance, then applies a novel local search operator that combines path reversal with adaptive segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining crowding distance and dominance\n        score = (obj1 + obj2) * (1 + 0.1 * (obj1 / obj2 if obj2 != 0 else 1))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: path reversal + adaptive segment insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Adaptive segment insertion based on distance matrices\n    if random.random() < 0.5:\n        # Insert a segment from one objective space\n        segment = new_solution[start:end+1]\n        remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        # Find insertion point with minimal increase in total distance\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(len(remaining)):\n            temp_sol = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8629201866655878,
            5.6792303919792175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining crowding distance and dominance\n        score = (obj1 + obj2) * (1 + 0.1 * (obj1 / obj2 if obj2 != 0 else 1))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: path reversal + adaptive segment insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Adaptive segment insertion based on distance matrices\n    if random.random() < 0.5:\n        # Insert a segment from one objective space\n        segment = new_solution[start:end+1]\n        remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        # Find insertion point with minimal increase in total distance\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(len(remaining)):\n            temp_sol = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This new heuristic selects a solution from the archive based on a combination of dominance rank and objective diversity, then applies a hybrid local search combining node insertion and path reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance rank and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining dominance rank and diversity\n        score = (obj1 + obj2) * (1 + 0.1 * (i % 10))  # Simple diversity factor\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node insertion + path reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Remove a random node and insert it elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.866161096634418,
            2.1207730174064636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance rank and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining dominance rank and diversity\n        score = (obj1 + obj2) * (1 + 0.1 * (i % 10))  # Simple diversity factor\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node insertion + path reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Remove a random node and insert it elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel local search that combines node insertion with a probabilistic segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a node and insert it at another position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 2: With probability 0.5, reverse a random segment\n    if random.random() < 0.5:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9008137348839202,
            2.2294334173202515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a node and insert it at another position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 2: With probability 0.5, reverse a random segment\n    if random.random() < 0.5:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a novel hybrid local search combining 3-opt and segment inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    selected_idx = 0\n    min_obj = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        combined = obj1 + obj2\n        if combined < min_obj:\n            min_obj = combined\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    # Step 1: Perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7438270352142481,
            1.7750043272972107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    selected_idx = 0\n    min_obj = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        combined = obj1 + obj2\n        if combined < min_obj:\n            min_obj = combined\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    # Step 1: Perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This heuristic function selects a solution from the archive based on a novel score combining objective values and diversity, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a novel score combining objectives and diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate a score combining objectives and diversity\n        score = (obj1 + obj2) * (1 + 0.1 * np.std(np.diff(sol)))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]  # Invert the segment\n\n    # Random node insertion\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)[0][0]), pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7999781790403525,
            3.1699039936065674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a novel score combining objectives and diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate a score combining objectives and diversity\n        score = (obj1 + obj2) * (1 + 0.1 * np.std(np.diff(sol)))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]  # Invert the segment\n\n    # Random node insertion\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)[0][0]), pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This heuristic function selects a solution from the archive based on the balance between its objective values and applies a hybrid local search that combines segment rotation and node swapping, ensuring feasibility while exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on balanced objectives\n    selected_idx = 0\n    min_balance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        balance = abs(obj1 - obj2)\n        if balance < min_balance:\n            min_balance = balance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a segment\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:end] = rotated_segment\n\n    # Step 2: Swap two nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8475339449357264,
            1.885836660861969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on balanced objectives\n    selected_idx = 0\n    min_balance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        balance = abs(obj1 - obj2)\n        if balance < min_balance:\n            min_balance = balance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a segment\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:end] = rotated_segment\n\n    # Step 2: Swap two nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining segment reversal, node relocation, and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Segment reversal with adaptive length\n    segment_length = min(random.randint(2, 5), n-1)\n    start = random.randint(0, n-segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Node relocation based on distance improvement\n    if n > 3:\n        node = random.choice(new_solution[1:-1])\n        current_pos = np.where(new_solution == node)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) < 2:\n            new_pos = random.randint(0, n-1)\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 3: Edge exchange with objective-aware selection\n    if n > 4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        a, b = new_solution[i], new_solution[j]\n        cost1 = distance_matrix_1[a, b] + distance_matrix_1[new_solution[i-1], new_solution[j+1]]\n        cost2 = distance_matrix_1[new_solution[i-1], a] + distance_matrix_1[b, new_solution[j+1]]\n        if cost2 < cost1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8544137840231036,
            1.7803441286087036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Segment reversal with adaptive length\n    segment_length = min(random.randint(2, 5), n-1)\n    start = random.randint(0, n-segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Node relocation based on distance improvement\n    if n > 3:\n        node = random.choice(new_solution[1:-1])\n        current_pos = np.where(new_solution == node)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) < 2:\n            new_pos = random.randint(0, n-1)\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 3: Edge exchange with objective-aware selection\n    if n > 4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        a, b = new_solution[i], new_solution[j]\n        cost1 = distance_matrix_1[a, b] + distance_matrix_1[new_solution[i-1], new_solution[j+1]]\n        cost2 = distance_matrix_1[new_solution[i-1], a] + distance_matrix_1[b, new_solution[j+1]]\n        if cost2 < cost1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of dominance ranking and objective diversity, then applies a novel 3-opt* local search that intelligently rearranges three segments of the tour to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank and objective diversity\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)  # Measure of objective diversity\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel 3-opt* local search\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Select three distinct segments\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    new_order = [segment1, segment3, segment2, segment4]\n    if random.random() > 0.5:\n        new_order = [segment1, segment2, segment4, segment3]\n\n    new_solution = np.concatenate(new_order)\n\n    # Ensure the tour remains valid by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.3668371699674,
            2.340887129306793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank and objective diversity\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)  # Measure of objective diversity\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel 3-opt* local search\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Select three distinct segments\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    new_order = [segment1, segment3, segment2, segment4]\n    if random.random() > 0.5:\n        new_order = [segment1, segment2, segment4, segment3]\n\n    new_solution = np.concatenate(new_order)\n\n    # Ensure the tour remains valid by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining node relocation with a biased edge selection strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Identify edges with high combined distance\n    edge_scores = []\n    for i in range(n):\n        node_a = base_solution[i]\n        node_b = base_solution[(i+1)%n]\n        score = distance_matrix_1[node_a, node_b] + distance_matrix_2[node_a, node_b]\n        edge_scores.append((score, i))\n\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n    selected_edge = edge_scores[0][1]\n\n    # Step 2: Relocate the selected edge's nodes to new positions\n    node1, node2 = base_solution[selected_edge], base_solution[(selected_edge+1)%n]\n\n    # Remove the nodes\n    new_solution = new_solution[new_solution != node1]\n    new_solution = new_solution[new_solution != node2]\n\n    # Insert them at new positions\n    insert_pos1 = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos1, node1)\n\n    insert_pos2 = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos2, node2)\n\n    return new_solution\n\n",
        "score": [
            -0.9379531438164441,
            2.5547839403152466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Identify edges with high combined distance\n    edge_scores = []\n    for i in range(n):\n        node_a = base_solution[i]\n        node_b = base_solution[(i+1)%n]\n        score = distance_matrix_1[node_a, node_b] + distance_matrix_2[node_a, node_b]\n        edge_scores.append((score, i))\n\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n    selected_edge = edge_scores[0][1]\n\n    # Step 2: Relocate the selected edge's nodes to new positions\n    node1, node2 = base_solution[selected_edge], base_solution[(selected_edge+1)%n]\n\n    # Remove the nodes\n    new_solution = new_solution[new_solution != node1]\n    new_solution = new_solution[new_solution != node2]\n\n    # Insert them at new positions\n    insert_pos1 = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos1, node1)\n\n    insert_pos2 = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos2, node2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This heuristic function selects a solution from the archive using a novel scoring mechanism that combines objective values with diversity metrics, then applies a hybrid local search combining segment reversal and node relocation to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a novel scoring mechanism\n    scores = []\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity\n        score = (obj1 + obj2) / (1 + np.std(sol))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)  # Select solution with lowest score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Step 1: Reverse a segment of variable length\n    seg_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Step 2: Relocate a node to a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8426640476693447,
            3.0847641229629517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a novel scoring mechanism\n    scores = []\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity\n        score = (obj1 + obj2) / (1 + np.std(sol))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)  # Select solution with lowest score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Step 1: Reverse a segment of variable length\n    seg_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Step 2: Relocate a node to a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest objective value sum, then applies a hybrid local search combining 3-opt and random segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Random segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9191494159645233,
            2.3958374857902527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Random segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining 3-opt and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on normalized objective sum\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and calculate score\n        norm_obj1 = obj1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_obj2 = obj2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + segment inversion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9261529615145365,
            8.697786569595337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on normalized objective sum\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and calculate score\n        norm_obj1 = obj1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_obj2 = obj2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + segment inversion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest sum of normalized objective values, then applies a novel local search combining cyclic permutation of segments and distance-aware node swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives using instance statistics\n        if len(archive) > 1:\n            avg_obj1 = sum(x[1][0] for x in archive) / len(archive)\n            avg_obj2 = sum(x[1][1] for x in archive) / len(archive)\n            score = (obj1 / avg_obj1) + (obj2 / avg_obj2)\n        else:\n            score = obj1 + obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Cyclic permutation of a random segment\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n-segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Distance-aware node swap\n    i = random.randint(0, n-1)\n    j = (i + random.randint(1, min(5, n-1))) % n\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate potential improvement in both objectives\n    current_cost1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]]\n\n    # Apply swap if it improves at least one objective\n    if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9108861768022289,
            9.583397626876831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives using instance statistics\n        if len(archive) > 1:\n            avg_obj1 = sum(x[1][0] for x in archive) / len(archive)\n            avg_obj2 = sum(x[1][1] for x in archive) / len(archive)\n            score = (obj1 / avg_obj1) + (obj2 / avg_obj2)\n        else:\n            score = obj1 + obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Cyclic permutation of a random segment\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n-segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Distance-aware node swap\n    i = random.randint(0, n-1)\n    j = (i + random.randint(1, min(5, n-1))) % n\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate potential improvement in both objectives\n    current_cost1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]]\n\n    # Apply swap if it improves at least one objective\n    if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This heuristic function selects a solution from the archive based on the most balanced objective values (minimizing the difference between the two objectives) and applies a novel \"double-bridge\" local search operator that reconnects four randomly selected edges in a way that preserves tour feasibility, potentially improving both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with most balanced objectives (minimize difference)\n    selected_idx = 0\n    min_diff = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diff = abs(obj1 - obj2)\n        if diff < min_diff:\n            min_diff = diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return base_solution\n\n    # Double-bridge local search\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create two bridges between segments\n    new_solution = np.concatenate([\n        base_solution[:a+1],\n        base_solution[c+1:d+1],\n        base_solution[b+1:c+1],\n        base_solution[a+1:b+1],\n        base_solution[d+1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.8421076654519591,
            1.680503249168396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with most balanced objectives (minimize difference)\n    selected_idx = 0\n    min_diff = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diff = abs(obj1 - obj2)\n        if diff < min_diff:\n            min_diff = diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return base_solution\n\n    # Double-bridge local search\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create two bridges between segments\n    new_solution = np.concatenate([\n        base_solution[:a+1],\n        base_solution[c+1:d+1],\n        base_solution[b+1:c+1],\n        base_solution[a+1:b+1],\n        base_solution[d+1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal, node relocation, and edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search\n    # 1. Segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 2. Node relocation\n    if n > 3:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # 3. Edge swap\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.905516481262681,
            2.193118095397949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search\n    # 1. Segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 2. Node relocation\n    if n > 3:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # 3. Edge swap\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment reversal and node reinsertion with distance-aware positioning to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a segment with high total distance in both spaces\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    total_dist1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    total_dist2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    if total_dist1 + total_dist2 > 0:  # Reverse if segment has high total distance\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a node at a position that minimizes both distances\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    best_pos = 0\n    min_total_dist = float('inf')\n    for pos in range(len(new_solution)):\n        if pos > 0:\n            prev_node = new_solution[pos-1]\n        else:\n            prev_node = new_solution[-1]\n        next_node = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n        total_dist = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                     distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        if total_dist < min_total_dist:\n            min_total_dist = total_dist\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9555481858813109,
            1.9735807180404663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a segment with high total distance in both spaces\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    total_dist1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    total_dist2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    if total_dist1 + total_dist2 > 0:  # Reverse if segment has high total distance\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a node at a position that minimizes both distances\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    best_pos = 0\n    min_total_dist = float('inf')\n    for pos in range(len(new_solution)):\n        if pos > 0:\n            prev_node = new_solution[pos-1]\n        else:\n            prev_node = new_solution[-1]\n        next_node = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n        total_dist = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                     distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        if total_dist < min_total_dist:\n            min_total_dist = total_dist\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This heuristic selects a solution from the archive based on its objective values and applies a novel local search combining adaptive segment reversal and cross-space edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective values (prioritize balanced solutions)\n    selected_idx = 0\n    min_diff = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diff = abs(obj1 - obj2)\n        if diff < min_diff:\n            min_diff = diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Cross-space edge insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Choose which space's distance to consider\n        if random.random() < 0.5:\n            dist_matrix = distance_matrix_1\n        else:\n            dist_matrix = distance_matrix_2\n\n        # Find the best insertion point based on cross-space distance\n        best_pos = -1\n        min_dist = float('inf')\n        for pos in range(n):\n            if pos == i or pos == (i + 1) % n:\n                continue\n            d = dist_matrix[new_solution[i], new_solution[pos]] + dist_matrix[new_solution[(i+1)%n], new_solution[(pos+1)%n]]\n            if d < min_dist:\n                min_dist = d\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the insertion\n            if best_pos > i:\n                segment = new_solution[i:best_pos]\n                new_solution = np.concatenate([new_solution[:i], new_solution[best_pos:], segment])\n            else:\n                segment = new_solution[i:]\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:i]])\n\n    return new_solution\n\n",
        "score": [
            -0.9531229822346736,
            2.0118250250816345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective values (prioritize balanced solutions)\n    selected_idx = 0\n    min_diff = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diff = abs(obj1 - obj2)\n        if diff < min_diff:\n            min_diff = diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Cross-space edge insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Choose which space's distance to consider\n        if random.random() < 0.5:\n            dist_matrix = distance_matrix_1\n        else:\n            dist_matrix = distance_matrix_2\n\n        # Find the best insertion point based on cross-space distance\n        best_pos = -1\n        min_dist = float('inf')\n        for pos in range(n):\n            if pos == i or pos == (i + 1) % n:\n                continue\n            d = dist_matrix[new_solution[i], new_solution[pos]] + dist_matrix[new_solution[(i+1)%n], new_solution[(pos+1)%n]]\n            if d < min_dist:\n                min_dist = d\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the insertion\n            if best_pos > i:\n                segment = new_solution[i:best_pos]\n                new_solution = np.concatenate([new_solution[:i], new_solution[best_pos:], segment])\n            else:\n                segment = new_solution[i:]\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:i]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining node reordering within clusters and partial path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Cluster nodes based on spatial proximity in both objective spaces\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        prev_node = base_solution[i-1]\n        curr_node = base_solution[i]\n        dist1 = distance_matrix_1[prev_node, curr_node]\n        dist2 = distance_matrix_2[prev_node, curr_node]\n        if dist1 < 1.5 * np.mean(distance_matrix_1) or dist2 < 1.5 * np.mean(distance_matrix_2):\n            current_cluster.append(curr_node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [curr_node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Step 2: Reorder nodes within clusters\n    for cluster in clusters:\n        if len(cluster) > 2:\n            start = base_solution.tolist().index(cluster[0])\n            end = base_solution.tolist().index(cluster[-1])\n            segment = new_solution[start:end+1]\n            np.random.shuffle(segment)\n            new_solution[start:end+1] = segment\n\n    # Step 3: Reverse a random segment to introduce diversity\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7796412305167044,
            2.5757025480270386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Cluster nodes based on spatial proximity in both objective spaces\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        prev_node = base_solution[i-1]\n        curr_node = base_solution[i]\n        dist1 = distance_matrix_1[prev_node, curr_node]\n        dist2 = distance_matrix_2[prev_node, curr_node]\n        if dist1 < 1.5 * np.mean(distance_matrix_1) or dist2 < 1.5 * np.mean(distance_matrix_2):\n            current_cluster.append(curr_node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [curr_node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Step 2: Reorder nodes within clusters\n    for cluster in clusters:\n        if len(cluster) > 2:\n            start = base_solution.tolist().index(cluster[0])\n            end = base_solution.tolist().index(cluster[-1])\n            segment = new_solution[start:end+1]\n            np.random.shuffle(segment)\n            new_solution[start:end+1] = segment\n\n    # Step 3: Reverse a random segment to introduce diversity\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This heuristic function selects a promising solution from the archive based on both objective values and dominance, then applies a novel local search combining node reordering and segment crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance and objective values\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reorder nodes based on alternating distance in both objectives\n    nodes = new_solution.copy()\n    current_node = nodes[0]\n    reordered = [current_node]\n    remaining_nodes = set(nodes[1:])\n\n    while remaining_nodes:\n        next_node = None\n        min_total_dist = float('inf')\n\n        for candidate in remaining_nodes:\n            dist1 = distance_matrix_1[current_node, candidate]\n            dist2 = distance_matrix_2[current_node, candidate]\n            total_dist = dist1 + dist2\n\n            if total_dist < min_total_dist:\n                min_total_dist = total_dist\n                next_node = candidate\n\n        reordered.append(next_node)\n        remaining_nodes.remove(next_node)\n        current_node = next_node\n\n    # Step 2: Perform segment crossover between original and reordered solutions\n    crossover_point = random.randint(1, n-2)\n    new_solution = np.concatenate([reordered[:crossover_point], base_solution[crossover_point:]])\n\n    # Ensure all nodes are included exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [node for node in base_solution if node not in unique_nodes]\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution[:n]\n\n",
        "score": [
            -0.789086110868552,
            2.8134838938713074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance and objective values\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reorder nodes based on alternating distance in both objectives\n    nodes = new_solution.copy()\n    current_node = nodes[0]\n    reordered = [current_node]\n    remaining_nodes = set(nodes[1:])\n\n    while remaining_nodes:\n        next_node = None\n        min_total_dist = float('inf')\n\n        for candidate in remaining_nodes:\n            dist1 = distance_matrix_1[current_node, candidate]\n            dist2 = distance_matrix_2[current_node, candidate]\n            total_dist = dist1 + dist2\n\n            if total_dist < min_total_dist:\n                min_total_dist = total_dist\n                next_node = candidate\n\n        reordered.append(next_node)\n        remaining_nodes.remove(next_node)\n        current_node = next_node\n\n    # Step 2: Perform segment crossover between original and reordered solutions\n    crossover_point = random.randint(1, n-2)\n    new_solution = np.concatenate([reordered[:crossover_point], base_solution[crossover_point:]])\n\n    # Ensure all nodes are included exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [node for node in base_solution if node not in unique_nodes]\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution[:n]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This heuristic function selects a solution from the archive based on a novel scoring mechanism combining objective values and solution diversity, then applies a hybrid local search combining segment reversal and insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a novel scoring mechanism\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines normalized objective values and solution diversity\n        score = (1 - obj1 / (obj1 + obj2 + 1e-6)) * (1 - obj2 / (obj1 + obj2 + 1e-6)) * len(set(sol))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random segment at a different position\n    if n > 3:\n        new_start = random.randint(0, n-2)\n        new_end = random.randint(new_start+1, min(new_start+3, n-1))\n        segment = new_solution[new_start:new_end+1]\n        remaining = np.concatenate([new_solution[:new_start], new_solution[new_end+1:]])\n        insert_pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7694970583282604,
            2.196651875972748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a novel scoring mechanism\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines normalized objective values and solution diversity\n        score = (1 - obj1 / (obj1 + obj2 + 1e-6)) * (1 - obj2 / (obj1 + obj2 + 1e-6)) * len(set(sol))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random segment at a different position\n    if n > 3:\n        new_start = random.randint(0, n-2)\n        new_end = random.randint(new_start+1, min(new_start+3, n-1))\n        segment = new_solution[new_start:new_end+1]\n        remaining = np.concatenate([new_solution[:new_start], new_solution[new_end+1:]])\n        insert_pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining node reordering based on objective-aware node ranking and segment inversion with objective-guided selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rank nodes based on their contribution to both objectives\n    node_ranking = []\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1) % n]\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        score = cost1 + cost2\n        node_ranking.append((score, i))\n\n    # Sort nodes by their score (lower is better)\n    node_ranking.sort(key=lambda x: x[0])\n    low_rank_nodes = [i for (score, i) in node_ranking[:max(2, n//4)]]\n\n    # Step 2: Invert a segment containing low-ranking nodes\n    if low_rank_nodes:\n        start_idx = random.choice(low_rank_nodes)\n        end_idx = random.randint(start_idx, min(start_idx + 5, n-1))\n        new_solution[start_idx:end_idx+1] = new_solution[start_idx:end_idx+1][::-1]\n\n    # Step 3: Reorder nodes based on objective-aware ranking\n    reorder_start = random.randint(0, n-1)\n    reorder_end = random.randint(reorder_start, min(reorder_start + 5, n-1))\n    segment = new_solution[reorder_start:reorder_end+1]\n    segment_sorted = sorted(segment, key=lambda x: (distance_matrix_1[x, x] + distance_matrix_2[x, x]))\n    new_solution[reorder_start:reorder_end+1] = segment_sorted\n\n    return new_solution\n\n",
        "score": [
            -0.8962124491467535,
            1.3184130787849426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rank nodes based on their contribution to both objectives\n    node_ranking = []\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1) % n]\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        score = cost1 + cost2\n        node_ranking.append((score, i))\n\n    # Sort nodes by their score (lower is better)\n    node_ranking.sort(key=lambda x: x[0])\n    low_rank_nodes = [i for (score, i) in node_ranking[:max(2, n//4)]]\n\n    # Step 2: Invert a segment containing low-ranking nodes\n    if low_rank_nodes:\n        start_idx = random.choice(low_rank_nodes)\n        end_idx = random.randint(start_idx, min(start_idx + 5, n-1))\n        new_solution[start_idx:end_idx+1] = new_solution[start_idx:end_idx+1][::-1]\n\n    # Step 3: Reorder nodes based on objective-aware ranking\n    reorder_start = random.randint(0, n-1)\n    reorder_end = random.randint(reorder_start, min(reorder_start + 5, n-1))\n    segment = new_solution[reorder_start:reorder_end+1]\n    segment_sorted = sorted(segment, key=lambda x: (distance_matrix_1[x, x] + distance_matrix_2[x, x]))\n    new_solution[reorder_start:reorder_end+1] = segment_sorted\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and dominance, then applies a hybrid local search combining node insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective values and dominance\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Remove a random node and insert it elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    remaining = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6627689103742733,
            1.2320462465286255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective values and dominance\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Remove a random node and insert it elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    remaining = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment reversal and node relocation with a bias toward improving both objectives by considering the combined effect of the two distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a segment with a bias toward improving both objectives\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the segment reversal impact on both objectives\n    original_cost1 = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[new_solution[(start-1)%n], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]]\n    new_cost1 = distance_matrix_1[reversed_segment[0], reversed_segment[-1]] + distance_matrix_1[new_solution[(start-1)%n], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(end+1)%n]]\n    if new_cost1 < original_cost1:\n        new_solution[start:end+1] = reversed_segment\n\n    # Step 2: Relocate a node to the position that minimizes the combined distance in both spaces\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n\n    best_pos = 0\n    min_combined_cost = float('inf')\n    for i in range(len(new_solution)):\n        cost1 = distance_matrix_1[new_solution[(i-1)%len(new_solution)], node] + distance_matrix_1[node, new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[(i-1)%len(new_solution)], node] + distance_matrix_2[node, new_solution[i]]\n        combined_cost = cost1 + cost2\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            best_pos = i\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8976907806942069,
            1.4667715430259705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a segment with a bias toward improving both objectives\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the segment reversal impact on both objectives\n    original_cost1 = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[new_solution[(start-1)%n], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]]\n    new_cost1 = distance_matrix_1[reversed_segment[0], reversed_segment[-1]] + distance_matrix_1[new_solution[(start-1)%n], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(end+1)%n]]\n    if new_cost1 < original_cost1:\n        new_solution[start:end+1] = reversed_segment\n\n    # Step 2: Relocate a node to the position that minimizes the combined distance in both spaces\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n\n    best_pos = 0\n    min_combined_cost = float('inf')\n    for i in range(len(new_solution)):\n        cost1 = distance_matrix_1[new_solution[(i-1)%len(new_solution)], node] + distance_matrix_1[node, new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[(i-1)%len(new_solution)], node] + distance_matrix_2[node, new_solution[i]]\n        combined_cost = cost1 + cost2\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            best_pos = i\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0062261850180043,
            1.614782691001892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0062261850180043,
            1.614782691001892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This heuristic selects a solution from the archive based on its dominance count and applies a novel local search combining segment rotation and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest dominance count (simplified by selecting the one with highest sum of objectives)\n    selected_idx = 0\n    max_dominance = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        dominance = obj1 + obj2\n        if dominance > max_dominance:\n            max_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment to the right by 1 position\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.820303952120226,
            2.194728136062622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest dominance count (simplified by selecting the one with highest sum of objectives)\n    selected_idx = 0\n    max_dominance = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        dominance = obj1 + obj2\n        if dominance > max_dominance:\n            max_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment to the right by 1 position\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment reversal with a probabilistic node swap based on distance improvement in both objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node swap based on distance improvement\n    for _ in range(2):  # Perform up to 2 swaps\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new distances for both objectives\n        prev_node_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        prev_node_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_node_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        # Current distances\n        dist1_current = distance_matrix_1[prev_node_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_node_i] + \\\n                        distance_matrix_1[prev_node_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_node_j]\n        dist2_current = distance_matrix_2[prev_node_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_node_i] + \\\n                        distance_matrix_2[prev_node_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_node_j]\n\n        # New distances if swapped\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        dist1_new = distance_matrix_1[prev_node_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_node_i] + \\\n                    distance_matrix_1[prev_node_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_node_j]\n        dist2_new = distance_matrix_2[prev_node_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_node_i] + \\\n                    distance_matrix_2[prev_node_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_node_j]\n\n        # Accept swap if both objectives improve or with probability if one improves\n        if (dist1_new + dist2_new) < (dist1_current + dist2_current):\n            pass  # Keep the swap\n        elif random.random() < 0.3:  # 30% chance to accept worse solution\n            pass\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Revert swap\n\n    return new_solution\n\n",
        "score": [
            -0.8686331811528701,
            2.3326918482780457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node swap based on distance improvement\n    for _ in range(2):  # Perform up to 2 swaps\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new distances for both objectives\n        prev_node_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        prev_node_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_node_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        # Current distances\n        dist1_current = distance_matrix_1[prev_node_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_node_i] + \\\n                        distance_matrix_1[prev_node_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_node_j]\n        dist2_current = distance_matrix_2[prev_node_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_node_i] + \\\n                        distance_matrix_2[prev_node_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_node_j]\n\n        # New distances if swapped\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        dist1_new = distance_matrix_1[prev_node_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_node_i] + \\\n                    distance_matrix_1[prev_node_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_node_j]\n        dist2_new = distance_matrix_2[prev_node_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_node_i] + \\\n                    distance_matrix_2[prev_node_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_node_j]\n\n        # Accept swap if both objectives improve or with probability if one improves\n        if (dist1_new + dist2_new) < (dist1_current + dist2_current):\n            pass  # Keep the swap\n        elif random.random() < 0.3:  # 30% chance to accept worse solution\n            pass\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Revert swap\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This heuristic selects a solution from the archive with the highest combined objective value, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    return new_solution\n\n",
        "score": [
            -0.9303913829440247,
            2.1993322372436523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search operator that combines segment inversion and node insertion, guided by a multi-objective improvement heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9827556906602883,
            1.2146247625350952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and node insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity measures, then applies a novel local search operator that combines path inversion and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objectives and diversity\n        score = (obj1 + obj2) * (1 + 0.1 * random.random())  # Add randomness to explore\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: path inversion and node reinsertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Step 2: Reinsert a random node at a new position\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8990847633383459,
            1.2303078174591064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objectives and diversity\n        score = (obj1 + obj2) * (1 + 0.1 * random.random())  # Add randomness to explore\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: path inversion and node reinsertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Step 2: Reinsert a random node at a new position\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel hybrid local search combining node insertion with a dynamic segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel hybrid local search: Node insertion with dynamic segment reversal\n    # Step 1: Remove a random node and store it\n    remove_pos = random.randint(0, n-1)\n    removed_node = new_solution[remove_pos]\n    new_solution = np.delete(new_solution, remove_pos)\n\n    # Step 2: Find optimal insertion position based on both distance matrices\n    min_cost = float('inf')\n    best_pos = 0\n    for pos in range(n-1):\n        cost1 = distance_matrix_1[new_solution[pos-1], removed_node] + distance_matrix_1[removed_node, new_solution[pos]] - distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        cost2 = distance_matrix_2[new_solution[pos-1], removed_node] + distance_matrix_2[removed_node, new_solution[pos]] - distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Step 3: Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 4: Reverse a random segment to create diversity\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8825904305070422,
            1.827103078365326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel hybrid local search: Node insertion with dynamic segment reversal\n    # Step 1: Remove a random node and store it\n    remove_pos = random.randint(0, n-1)\n    removed_node = new_solution[remove_pos]\n    new_solution = np.delete(new_solution, remove_pos)\n\n    # Step 2: Find optimal insertion position based on both distance matrices\n    min_cost = float('inf')\n    best_pos = 0\n    for pos in range(n-1):\n        cost1 = distance_matrix_1[new_solution[pos-1], removed_node] + distance_matrix_1[removed_node, new_solution[pos]] - distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        cost2 = distance_matrix_2[new_solution[pos-1], removed_node] + distance_matrix_2[removed_node, new_solution[pos]] - distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Step 3: Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 4: Reverse a random segment to create diversity\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment reversal with optimal node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    if len(archive) > 1:\n        # With 30% probability, select the solution with the highest combined objective value\n        if random.random() < 0.3:\n            selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n        # Otherwise, with 70% probability, select a random solution\n        else:\n            selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Find the best insertion position for a randomly selected node\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(len(new_solution)+1):\n        temp_solution = np.insert(new_solution.copy(), pos, node)\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[i-1]][temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1]][temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8549772226253534,
            11.524288058280945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    if len(archive) > 1:\n        # With 30% probability, select the solution with the highest combined objective value\n        if random.random() < 0.3:\n            selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n        # Otherwise, with 70% probability, select a random solution\n        else:\n            selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Find the best insertion position for a randomly selected node\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(len(new_solution)+1):\n        temp_solution = np.insert(new_solution.copy(), pos, node)\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[i-1]][temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1]][temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This heuristic function selects a promising solution from the archive using a combination of crowding distance and dominance relation, then applies a novel local search that combines segment rotation and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance\n        crowding = obj1 + obj2\n        # Calculate dominance score (number of solutions it dominates)\n        dominates = sum(1 for (_, (o1, o2)) in archive if (o1 > obj1 and o2 > obj2))\n        score = crowding + dominates * 10\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    shift = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6050323928196015,
            1.3201835751533508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance\n        crowding = obj1 + obj2\n        # Calculate dominance score (number of solutions it dominates)\n        dominates = sum(1 for (_, (o1, o2)) in archive if (o1 > obj1 and o2 > obj2))\n        score = crowding + dominates * 10\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    shift = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel local search strategy that combines segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    new_solution = new_solution[new_solution != node]  # Remove duplicate\n\n    return new_solution\n\n",
        "score": [
            -0.8853089265350859,
            0.3612983226776123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    new_solution = new_solution[new_solution != node]  # Remove duplicate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This new algorithm selects a promising solution from the archive based on a hybrid score combining objective values and solution diversity, then applies a novel local search combining segment rotation and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with hybrid score\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Hybrid score combining objective values and solution diversity\n        diversity = len(set(sol))\n        score = (obj1 + obj2) * diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9317879931585136,
            3.3949065804481506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with hybrid score\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Hybrid score combining objective values and solution diversity\n        diversity = len(set(sol))\n        score = (obj1 + obj2) * diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and multi-node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reorder a random subset of nodes\n    k = random.randint(2, min(5, n))\n    indices = random.sample(range(n), k)\n    subset = new_solution[indices]\n    random.shuffle(subset)\n    new_solution[indices] = subset\n\n    return new_solution\n\n",
        "score": [
            -0.8991672218806368,
            1.8046897053718567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reorder a random subset of nodes\n    k = random.randint(2, min(5, n))\n    indices = random.sample(range(n), k)\n    subset = new_solution[indices]\n    random.shuffle(subset)\n    new_solution[indices] = subset\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This heuristic function selects a solution from the archive based on a novel hybrid score combining normalized objective values and archive diversity, then applies a segment inversion and node insertion local search to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hybrid score for selection\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n\n    min_obj1, max_obj1 = min(obj1_values), max(obj1_values)\n    min_obj2, max_obj2 = min(obj2_values), max(obj2_values)\n\n    scores = []\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        normalized_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        normalized_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        diversity = len(set(archive[i][0])) / len(archive[i][0])\n        score = 0.6 * (normalized_obj1 + normalized_obj2) + 0.4 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Apply segment inversion\n    start = random.randint(0, n-3)\n    end = random.randint(start+2, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = j if j < len(new_solution) else len(new_solution)-1\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9416119564264993,
            4.642823755741119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hybrid score for selection\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n\n    min_obj1, max_obj1 = min(obj1_values), max(obj1_values)\n    min_obj2, max_obj2 = min(obj2_values), max(obj2_values)\n\n    scores = []\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        normalized_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        normalized_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        diversity = len(set(archive[i][0])) / len(archive[i][0])\n        score = 0.6 * (normalized_obj1 + normalized_obj2) + 0.4 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Apply segment inversion\n    start = random.randint(0, n-3)\n    end = random.randint(start+2, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = j if j < len(new_solution) else len(new_solution)-1\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This heuristic function selects a solution from the archive based on a weighted combination of objective values and applies a novel local search combining segment inversion and node insertion to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of objectives\n    selected_idx = 0\n    max_weighted_sum = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted_sum = 0.6 * obj1 + 0.4 * obj2\n        if weighted_sum > max_weighted_sum:\n            max_weighted_sum = weighted_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_insert], new_solution[insert_pos:]])\n\n    # Ensure no duplicates and all nodes are included\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n    if len(missing_nodes) > 0:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution[:n]  # Ensure correct length\n\n",
        "score": [
            -0.8326016383909898,
            0.6192519068717957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of objectives\n    selected_idx = 0\n    max_weighted_sum = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted_sum = 0.6 * obj1 + 0.4 * obj2\n        if weighted_sum > max_weighted_sum:\n            max_weighted_sum = weighted_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_insert], new_solution[insert_pos:]])\n\n    # Ensure no duplicates and all nodes are included\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n    if len(missing_nodes) > 0:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution[:n]  # Ensure correct length\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This heuristic function selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a novel local search combining node insertion with path reversal and edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score as weighted sum of objectives plus diversity\n        score = 0.4 * obj1 + 0.4 * obj2 + 0.2 * (len(set(sol)) / len(sol))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Novel local search: node insertion with path reversal and edge flipping\n    # Step 1: Remove a random segment and insert it in reverse order\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    # Step 2: Flip a random edge\n    flip_pos = random.randint(0, n-2)\n    new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Step 3: Perform a node insertion\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    remaining = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8710818313544408,
            3.088746964931488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score as weighted sum of objectives plus diversity\n        score = 0.4 * obj1 + 0.4 * obj2 + 0.2 * (len(set(sol)) / len(sol))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Novel local search: node insertion with path reversal and edge flipping\n    # Step 1: Remove a random segment and insert it in reverse order\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    # Step 2: Flip a random edge\n    flip_pos = random.randint(0, n-2)\n    new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Step 3: Perform a node insertion\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    remaining = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This heuristic function selects a solution from the archive based on its objective values, then applies a novel local search combining node insertion with a smart segment reversal and edge rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on the sum of objectives (simplified selection)\n    selected_idx = np.argmax([obj1 + obj2 for (_, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Rotate a segment by a random amount\n    rotate_start = random.randint(0, n-2)\n    rotate_end = random.randint(rotate_start+1, min(rotate_start+4, n-1))\n    segment = new_solution[rotate_start:rotate_end+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n    new_solution[rotate_start:rotate_end+1] = rotated_segment\n\n    # Step 3: Insert a random node at a new position\n    node_to_move = random.randint(0, n-1)\n    node_value = new_solution[node_to_move]\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node_value)\n\n    return new_solution\n\n",
        "score": [
            -0.9130765493329572,
            2.1062586903572083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on the sum of objectives (simplified selection)\n    selected_idx = np.argmax([obj1 + obj2 for (_, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Rotate a segment by a random amount\n    rotate_start = random.randint(0, n-2)\n    rotate_end = random.randint(rotate_start+1, min(rotate_start+4, n-1))\n    segment = new_solution[rotate_start:rotate_end+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n    new_solution[rotate_start:rotate_end+1] = rotated_segment\n\n    # Step 3: Insert a random node at a new position\n    node_to_move = random.randint(0, n-1)\n    node_value = new_solution[node_to_move]\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node_value)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This heuristic function selects a solution from the archive based on a hybrid score combining objective values and solution quality metrics, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        n = len(sol)\n        score = (obj1 + obj2) / (1 + (obj1 * obj2) / (n * 1000))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Step 2: Insert a random node at a new position\n    i, j = random.sample(range(n), 2)\n    node = new_solution[i]\n    new_sol = np.delete(new_solution, i)\n    new_sol = np.insert(new_sol, j, node)\n\n    return new_sol\n\n",
        "score": [
            -0.8792688831237074,
            2.5448427200317383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        n = len(sol)\n        score = (obj1 + obj2) / (1 + (obj1 * obj2) / (n * 1000))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Step 2: Insert a random node at a new position\n    i, j = random.sample(range(n), 2)\n    node = new_solution[i]\n    new_sol = np.delete(new_solution, i)\n    new_sol = np.insert(new_sol, j, node)\n\n    return new_sol\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Step 2: Insert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9305979005305485,
            1.8638244271278381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Step 2: Insert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This heuristic function selects a solution from the archive based on its dominance rank and applies a novel local search combining segment inversion and adaptive edge insertion to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + adaptive edge insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_segment = np.flip(segment)\n\n    # Adaptive edge insertion\n    best_pos = -1\n    min_cost = float('inf')\n    for i in range(n):\n        if i >= start and i <= end:\n            continue\n        # Calculate cost for both objectives\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i]\n        cost1 = distance_matrix_1[prev_node, new_segment[0]] + distance_matrix_1[new_segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, new_segment[0]] + distance_matrix_2[new_segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], new_segment, new_solution[best_pos:]])\n        # Remove inserted segment from original position\n        new_solution = np.delete(new_solution, np.s_[start:end+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7307255000035615,
            1.7490243911743164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + adaptive edge insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_segment = np.flip(segment)\n\n    # Adaptive edge insertion\n    best_pos = -1\n    min_cost = float('inf')\n    for i in range(n):\n        if i >= start and i <= end:\n            continue\n        # Calculate cost for both objectives\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i]\n        cost1 = distance_matrix_1[prev_node, new_segment[0]] + distance_matrix_1[new_segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, new_segment[0]] + distance_matrix_2[new_segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], new_segment, new_solution[best_pos:]])\n        # Remove inserted segment from original position\n        new_solution = np.delete(new_solution, np.s_[start:end+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9549330538921952,
            1.8367250561714172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and dominance, then applies a novel local search combining node reordering and partial path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = obj1 + obj2 - 0.5 * min(obj1, obj2)  # Balance between objectives\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reorder a segment based on distance in one objective space\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n\n    # Choose which objective space to use for sorting\n    if random.random() < 0.5:\n        # Sort by distance in first objective space\n        segment = sorted(segment, key=lambda x: sum(distance_matrix_1[x, segment]))\n    else:\n        # Sort by distance in second objective space\n        segment = sorted(segment, key=lambda x: sum(distance_matrix_2[x, segment]))\n\n    new_solution[start:end+1] = segment\n\n    # Step 2: Reverse a random segment to create a break\n    reverse_start = random.randint(0, n-2)\n    reverse_end = random.randint(reverse_start+1, min(reverse_start+5, n-1))\n    new_solution[reverse_start:reverse_end+1] = new_solution[reverse_start:reverse_end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7629079163591354,
            2.2192875742912292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = obj1 + obj2 - 0.5 * min(obj1, obj2)  # Balance between objectives\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reorder a segment based on distance in one objective space\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n\n    # Choose which objective space to use for sorting\n    if random.random() < 0.5:\n        # Sort by distance in first objective space\n        segment = sorted(segment, key=lambda x: sum(distance_matrix_1[x, segment]))\n    else:\n        # Sort by distance in second objective space\n        segment = sorted(segment, key=lambda x: sum(distance_matrix_2[x, segment]))\n\n    new_solution[start:end+1] = segment\n\n    # Step 2: Reverse a random segment to create a break\n    reverse_start = random.randint(0, n-2)\n    reverse_end = random.randint(reverse_start+1, min(reverse_start+5, n-1))\n    new_solution[reverse_start:reverse_end+1] = new_solution[reverse_start:reverse_end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This new heuristic selects a solution from the archive based on its normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to prioritize solutions with better balance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:new_pos+1], [node]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:node_pos], new_solution[node_pos+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9133404885104508,
            0.9865229725837708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to prioritize solutions with better balance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:new_pos+1], [node]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:node_pos], new_solution[node_pos+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and cross-exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + cross-exchange\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a cross-exchange between two segments\n    if n >= 6:\n        split1 = random.randint(1, n-4)\n        split2 = random.randint(split1+1, n-3)\n        segment1 = new_solution[:split1]\n        segment2 = new_solution[split1:split2]\n        segment3 = new_solution[split2:]\n        new_solution = np.concatenate([segment1, segment3, segment2])\n\n    return new_solution\n\n",
        "score": [
            -0.9904945264583767,
            1.6241399049758911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + cross-exchange\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a cross-exchange between two segments\n    if n >= 6:\n        split1 = random.randint(1, n-4)\n        split2 = random.randint(split1+1, n-3)\n        segment1 = new_solution[:split1]\n        segment2 = new_solution[split1:split2]\n        segment3 = new_solution[split2:]\n        new_solution = np.concatenate([segment1, segment3, segment2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal and node insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective combination and dominance rank\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted sum of objectives with dominance consideration\n        score = -0.7 * obj1 - 0.3 * obj2 + (len(archive) - i) * 0.05  # Prioritize better solutions and later ones\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node at a new position\n    node_to_move = random.randint(0, n-1)\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_to_move:\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:new_pos+1], [new_solution[node_to_move]], new_solution[new_pos+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], [new_solution[node_to_move]], new_solution[new_pos:node_to_move], new_solution[node_to_move+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8719909528751342,
            1.8113104104995728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective combination and dominance rank\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted sum of objectives with dominance consideration\n        score = -0.7 * obj1 - 0.3 * obj2 + (len(archive) - i) * 0.05  # Prioritize better solutions and later ones\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node at a new position\n    node_to_move = random.randint(0, n-1)\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_to_move:\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:new_pos+1], [new_solution[node_to_move]], new_solution[new_pos+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], [new_solution[node_to_move]], new_solution[new_pos:node_to_move], new_solution[node_to_move+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This heuristic function selects a solution from the archive based on the combination of objective values and diversity, then applies a novel local search combining segment inversion and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity (simplified)\n        score = (obj1 + obj2) * (1 + 0.1 * (i % 5))  # Adds slight diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node at another position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9287434875920453,
            1.8977490663528442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity (simplified)\n        score = (obj1 + obj2) * (1 + 0.1 * (i % 5))  # Adds slight diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node at another position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This algorithm selects a solution with the highest combined objective values, then applies a novel hybrid local search combining segment inversion and position-based swapping to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective values\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Perform position-based swapping\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8961365926167372,
            1.898991048336029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective values\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Perform position-based swapping\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This heuristic selects a solution with the highest combined objective value from the archive, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        total_obj = obj1 + obj2\n        if total_obj > max_obj:\n            max_obj = total_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9676511922616573,
            1.4041128754615784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        total_obj = obj1 + obj2\n        if total_obj > max_obj:\n            max_obj = total_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement, using a combination of dominance and diversity metrics, then applies a novel local search operator that performs a multi-segment exchange and adaptive edge insertion to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining dominance and diversity\n        score = (obj1 + obj2) * (1 + 1/(1 + obj1 + obj2))  # Combines objective values with diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: multi-segment exchange with adaptive insertion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select two random segments and exchange them\n    seg1_start = random.randint(0, n-4)\n    seg1_end = random.randint(seg1_start+1, min(seg1_start+4, n-3))\n    seg2_start = random.randint(seg1_end+1, n-2)\n    seg2_end = random.randint(seg2_start+1, min(seg2_start+4, n-1))\n\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end+1:seg2_start],\n        seg1,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Step 2: Adaptive edge insertion based on distance matrices\n    for _ in range(2):  # Perform 2 adaptive insertions\n        # Select a node to insert\n        insert_node = random.choice(new_solution)\n\n        # Find best insertion point based on both distance matrices\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)-1):\n            a = new_solution[i]\n            b = new_solution[(i+1) % len(new_solution)]\n            cost = (distance_matrix_1[a, insert_node] + distance_matrix_1[insert_node, b] - distance_matrix_1[a, b]) + \\\n                   (distance_matrix_2[a, insert_node] + distance_matrix_2[insert_node, b] - distance_matrix_2[a, b])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = i+1\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, insert_node)\n\n    return new_solution\n\n",
        "score": [
            -0.8911767375737957,
            0.6745628118515015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining dominance and diversity\n        score = (obj1 + obj2) * (1 + 1/(1 + obj1 + obj2))  # Combines objective values with diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: multi-segment exchange with adaptive insertion\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select two random segments and exchange them\n    seg1_start = random.randint(0, n-4)\n    seg1_end = random.randint(seg1_start+1, min(seg1_start+4, n-3))\n    seg2_start = random.randint(seg1_end+1, n-2)\n    seg2_end = random.randint(seg2_start+1, min(seg2_start+4, n-1))\n\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end+1:seg2_start],\n        seg1,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Step 2: Adaptive edge insertion based on distance matrices\n    for _ in range(2):  # Perform 2 adaptive insertions\n        # Select a node to insert\n        insert_node = random.choice(new_solution)\n\n        # Find best insertion point based on both distance matrices\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)-1):\n            a = new_solution[i]\n            b = new_solution[(i+1) % len(new_solution)]\n            cost = (distance_matrix_1[a, insert_node] + distance_matrix_1[insert_node, b] - distance_matrix_1[a, b]) + \\\n                   (distance_matrix_2[a, insert_node] + distance_matrix_2[insert_node, b] - distance_matrix_2[a, b])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = i+1\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, insert_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with high crowding distance and applies a novel local search strategy combining edge reversal and node insertion, ensuring feasibility by maintaining valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Simplified crowding distance\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: edge reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a randomly selected node in a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9306230793751051,
            1.3927103877067566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Simplified crowding distance\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: edge reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a randomly selected node in a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with highest combined objective\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8531804271148071,
            1.3687646389007568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with highest combined objective\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This new algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        combined_obj = obj1 + obj2\n        if combined_obj > max_obj:\n            max_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    node_to_move = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_move]\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8990725586168629,
            1.9585654735565186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        combined_obj = obj1 + obj2\n        if combined_obj > max_obj:\n            max_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    node_to_move = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_move]\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining node insertion with adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Remove a random node and insert it at a new position\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    remaining = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a segment with adaptive length based on solution size\n    segment_length = min(random.randint(2, 4), n-2)\n    start = random.randint(0, n-1-segment_length)\n    end = start + segment_length\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8666054599971189,
            2.2835784554481506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Remove a random node and insert it at a new position\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    remaining = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a segment with adaptive length based on solution size\n    segment_length = min(random.randint(2, 4), n-2)\n    start = random.randint(0, n-1-segment_length)\n    end = start + segment_length\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined score of normalized objective values and diversity, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for selection\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity = np.linalg.norm(normalized, axis=1)\n    scores = normalized[:, 0] * normalized[:, 1] * diversity\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == i+1 or j == i-1:\n        j = random.randint(0, n-1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7668723414512304,
            1.5501260161399841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for selection\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity = np.linalg.norm(normalized, axis=1)\n    scores = normalized[:, 0] * normalized[:, 1] * diversity\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == i+1 or j == i-1:\n        j = random.randint(0, n-1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This heuristic function selects a solution from the archive based on its combined objective values and distance to other solutions, then applies a novel local search combining segment inversion and node reinsertion to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate diversity score (distance to other solutions)\n        diversity = sum(np.linalg.norm(np.array(obj1, obj2) - np.array(o1, o2)) for (_, (o1, o2)) in archive if i != i)\n        score = obj1 + obj2 + diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node reinsertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8895790213633485,
            2.3814488649368286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate diversity score (distance to other solutions)\n        diversity = sum(np.linalg.norm(np.array(obj1, obj2) - np.array(o1, o2)) for (_, (o1, o2)) in archive if i != i)\n        score = obj1 + obj2 + diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node reinsertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This heuristic function selects a solution from the archive using a hybrid of objective-based and diversity-aware selection, then applies a novel local search combining segment reversal, node insertion, and objective-aware edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high crowding distance and low objective values\n    selected_idx = 0\n    max_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        score = crowding - (obj1 + obj2) / 2  # Balance between diversity and objective quality\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Local search operator: segment reversal with objective-aware edge selection\n    if random.random() < 0.5:\n        # Step 1: Select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n\n        # Step 2: Reverse the segment and evaluate the change in both objectives\n        reversed_segment = new_solution[start:end+1][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end+1] = reversed_segment\n\n        # Calculate the change in objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Accept the reversal if it improves at least one objective\n        if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n            new_solution = temp_solution\n\n    # Step 3: Node insertion based on objective-aware distance\n    else:\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find the best insertion point based on combined distance in both objectives\n        best_pos = node_idx\n        min_dist = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n                continue\n\n            # Calculate the cost of inserting the node at this position\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            combined_dist = dist1 + dist2\n\n            if combined_dist < min_dist:\n                min_dist = combined_dist\n                best_pos = pos\n\n        # Insert the node at the best position\n        if best_pos != node_idx:\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.862993897756496,
            2.1763421297073364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high crowding distance and low objective values\n    selected_idx = 0\n    max_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        score = crowding - (obj1 + obj2) / 2  # Balance between diversity and objective quality\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Local search operator: segment reversal with objective-aware edge selection\n    if random.random() < 0.5:\n        # Step 1: Select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n\n        # Step 2: Reverse the segment and evaluate the change in both objectives\n        reversed_segment = new_solution[start:end+1][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end+1] = reversed_segment\n\n        # Calculate the change in objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Accept the reversal if it improves at least one objective\n        if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n            new_solution = temp_solution\n\n    # Step 3: Node insertion based on objective-aware distance\n    else:\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find the best insertion point based on combined distance in both objectives\n        best_pos = node_idx\n        min_dist = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n                continue\n\n            # Calculate the cost of inserting the node at this position\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            combined_dist = dist1 + dist2\n\n            if combined_dist < min_dist:\n                min_dist = combined_dist\n                best_pos = pos\n\n        # Insert the node at the best position\n        if best_pos != node_idx:\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.903723414805947,
            1.6955585479736328
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        total_obj = obj1 + obj2\n        if total_obj > max_obj:\n            max_obj = total_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_pos = random.randint(0, n-1)\n    insert_pos = random.randint(0, n-1)\n    if node_pos != insert_pos:\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8407505334540822,
            1.9428005814552307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        total_obj = obj1 + obj2\n        if total_obj > max_obj:\n            max_obj = total_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_pos = random.randint(0, n-1)\n    insert_pos = random.randint(0, n-1)\n    if node_pos != insert_pos:\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This heuristic function selects a solution from the archive based on a weighted combination of objective values and applies a novel local search combining segment reversal, node insertion, and a multi-objective aware edge reallocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective value\n    selected_idx = 0\n    best_value = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted_value = 0.7 * obj1 + 0.3 * obj2  # Weighted combination of objectives\n        if weighted_value < best_value:\n            best_value = weighted_value\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node at a different position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 3: Multi-objective aware edge reallocation\n    for _ in range(2):  # Perform 2 iterations\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, min(i+5, n-1))\n\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if improves at least one objective\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.548152798820134,
            1.9920899271965027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective value\n    selected_idx = 0\n    best_value = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted_value = 0.7 * obj1 + 0.3 * obj2  # Weighted combination of objectives\n        if weighted_value < best_value:\n            best_value = weighted_value\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node at a different position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 3: Multi-objective aware edge reallocation\n    for _ in range(2):  # Perform 2 iterations\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, min(i+5, n-1))\n\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if improves at least one objective\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    insert_pos = random.randint(0, n-1)\n    if insert_pos != 0 and insert_pos != n-1:\n        node = new_solution[insert_pos]\n        new_solution = np.concatenate([new_solution[:insert_pos], new_solution[insert_pos+1:]])\n        new_insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, new_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8754764556507237,
            1.6383320093154907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    insert_pos = random.randint(0, n-1)\n    if insert_pos != 0 and insert_pos != n-1:\n        node = new_solution[insert_pos]\n        new_solution = np.concatenate([new_solution[:insert_pos], new_solution[insert_pos+1:]])\n        new_insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, new_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with high variance in objective values, then applies a hybrid local search combining random segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance\n    selected_idx = 0\n    max_variance = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        variance = abs(obj1 - obj2)\n        if variance > max_variance:\n            max_variance = variance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]  # Reverse segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node insertion\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.4549526692576453,
            1.5150588154792786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance\n    selected_idx = 0\n    max_variance = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        variance = abs(obj1 - obj2)\n        if variance > max_variance:\n            max_variance = variance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]  # Reverse segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node insertion\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8902284070709134,
            1.9236640334129333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel 'double-bridge' local search operator that combines two non-adjacent segments and reinserts them in a way that preserves feasibility while potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objectives and diversity\n        score = (obj1 + obj2) * (1 + np.random.uniform(0, 0.5))  # Add some randomness\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 6:\n        return base_solution\n\n    # Double-bridge local search\n    # Select two non-overlapping segments\n    seg1_start = random.randint(0, n-4)\n    seg1_end = random.randint(seg1_start+1, min(seg1_start+3, n-3))\n    seg2_start = random.randint(seg1_end+1, n-2)\n    seg2_end = random.randint(seg2_start+1, min(seg2_start+3, n-1))\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create remaining sequence\n    remaining = np.concatenate([\n        new_solution[:seg1_start],\n        new_solution[seg1_end+1:seg2_start],\n        new_solution[seg2_end+1:]\n    ])\n\n    # Insert segments in reverse order\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([\n        remaining[:insert_pos],\n        seg2,\n        seg1,\n        remaining[insert_pos:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.8797104491490735,
            2.778269052505493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objectives and diversity\n        score = (obj1 + obj2) * (1 + np.random.uniform(0, 0.5))  # Add some randomness\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 6:\n        return base_solution\n\n    # Double-bridge local search\n    # Select two non-overlapping segments\n    seg1_start = random.randint(0, n-4)\n    seg1_end = random.randint(seg1_start+1, min(seg1_start+3, n-3))\n    seg2_start = random.randint(seg1_end+1, n-2)\n    seg2_end = random.randint(seg2_start+1, min(seg2_start+3, n-1))\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create remaining sequence\n    remaining = np.concatenate([\n        new_solution[:seg1_start],\n        new_solution[seg1_end+1:seg2_start],\n        new_solution[seg2_end+1:]\n    ])\n\n    # Insert segments in reverse order\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([\n        remaining[:insert_pos],\n        seg2,\n        seg1,\n        remaining[insert_pos:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with balanced objective values (neither too extreme in either objective), then applies a novel local search combining segment inversion and cross-swap operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = 0\n    min_balance_diff = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        balance_diff = abs(obj1 - obj2)\n        if balance_diff < min_balance_diff:\n            min_balance_diff = balance_diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Cross-swap two non-adjacent edges\n    a, b, c, d = random.sample(range(n), 4)\n    if abs(a - b) > 1 and abs(c - d) > 1:\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.635367137990386,
            1.7188191413879395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = 0\n    min_balance_diff = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        balance_diff = abs(obj1 - obj2)\n        if balance_diff < min_balance_diff:\n            min_balance_diff = balance_diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Cross-swap two non-adjacent edges\n    a, b, c, d = random.sample(range(n), 4)\n    if abs(a - b) > 1 and abs(c - d) > 1:\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity measures, then applies a hybrid local search combining segment reversal and node insertion to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    max_score = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = (obj1 + obj2) / (1 + len(archive) - i)  # Normalize by position to encourage diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    i, j = random.sample(range(n), 2)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5754539564279638,
            1.931271493434906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    max_score = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = (obj1 + obj2) / (1 + len(archive) - i)  # Normalize by position to encourage diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    i, j = random.sample(range(n), 2)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This heuristic function selects a solution from the archive based on its dominance count and applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance count\n    dominance_counts = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj_i = archive[i][1]\n                obj_j = archive[j][1]\n                if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7615029735066831,
            1.4631057381629944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance count\n    dominance_counts = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj_i = archive[i][1]\n                obj_j = archive[j][1]\n                if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search operator that combines segment reversal and node insertion based on the combined distance metrics from both objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal and node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate combined distance for insertion points\n    insertion_scores = []\n    for i in range(len(new_solution)):\n        if i < start or i > end:\n            node_before = new_solution[i-1] if i > 0 else new_solution[-1]\n            node_after = new_solution[i] if i < len(new_solution) else new_solution[0]\n            dist1 = distance_matrix_1[node_before, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], node_after]\n            dist2 = distance_matrix_2[node_before, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], node_after]\n            insertion_scores.append((dist1 + dist2, i))\n\n    if not insertion_scores:\n        return base_solution\n\n    best_insert_pos = min(insertion_scores, key=lambda x: x[0])[1]\n\n    # Apply segment reversal and insertion\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    new_solution = np.concatenate([remaining[:best_insert_pos], reversed_segment, remaining[best_insert_pos:]])\n\n    # Additional node insertion based on combined distance\n    if random.random() < 0.5:\n        node_to_insert = random.choice(new_solution)\n        mask = np.ones(n, dtype=bool)\n        mask[new_solution == node_to_insert] = False\n        candidates = new_solution[mask]\n\n        best_insert = None\n        min_dist = float('inf')\n\n        for i in range(len(new_solution)):\n            if new_solution[i] != node_to_insert:\n                node_before = new_solution[i-1] if i > 0 else new_solution[-1]\n                node_after = new_solution[i] if i < len(new_solution) else new_solution[0]\n                dist1 = distance_matrix_1[node_before, node_to_insert] + distance_matrix_1[node_to_insert, node_after] - distance_matrix_1[node_before, node_after]\n                dist2 = distance_matrix_2[node_before, node_to_insert] + distance_matrix_2[node_to_insert, node_after] - distance_matrix_2[node_before, node_after]\n                total_dist = dist1 + dist2\n\n                if total_dist < min_dist:\n                    min_dist = total_dist\n                    best_insert = i\n\n        if best_insert is not None:\n            new_solution = np.insert(new_solution, best_insert, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.9347099435930637,
            1.83710515499115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal and node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate combined distance for insertion points\n    insertion_scores = []\n    for i in range(len(new_solution)):\n        if i < start or i > end:\n            node_before = new_solution[i-1] if i > 0 else new_solution[-1]\n            node_after = new_solution[i] if i < len(new_solution) else new_solution[0]\n            dist1 = distance_matrix_1[node_before, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], node_after]\n            dist2 = distance_matrix_2[node_before, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], node_after]\n            insertion_scores.append((dist1 + dist2, i))\n\n    if not insertion_scores:\n        return base_solution\n\n    best_insert_pos = min(insertion_scores, key=lambda x: x[0])[1]\n\n    # Apply segment reversal and insertion\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    new_solution = np.concatenate([remaining[:best_insert_pos], reversed_segment, remaining[best_insert_pos:]])\n\n    # Additional node insertion based on combined distance\n    if random.random() < 0.5:\n        node_to_insert = random.choice(new_solution)\n        mask = np.ones(n, dtype=bool)\n        mask[new_solution == node_to_insert] = False\n        candidates = new_solution[mask]\n\n        best_insert = None\n        min_dist = float('inf')\n\n        for i in range(len(new_solution)):\n            if new_solution[i] != node_to_insert:\n                node_before = new_solution[i-1] if i > 0 else new_solution[-1]\n                node_after = new_solution[i] if i < len(new_solution) else new_solution[0]\n                dist1 = distance_matrix_1[node_before, node_to_insert] + distance_matrix_1[node_to_insert, node_after] - distance_matrix_1[node_before, node_after]\n                dist2 = distance_matrix_2[node_before, node_to_insert] + distance_matrix_2[node_to_insert, node_after] - distance_matrix_2[node_before, node_after]\n                total_dist = dist1 + dist2\n\n                if total_dist < min_dist:\n                    min_dist = total_dist\n                    best_insert = i\n\n        if best_insert is not None:\n            new_solution = np.insert(new_solution, best_insert, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This heuristic function selects a solution from the archive based on the worst objective value in either space, then applies a novel \"objective-balanced segment inversion and swap\" operator that inverts a segment of the tour and swaps nodes between segments while maintaining feasibility, aiming to improve both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst objective in either space\n    selected_idx = 0\n    worst_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        current_worst = max(obj1, obj2)\n        if current_worst > worst_obj:\n            worst_obj = current_worst\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Objective-balanced segment inversion and swap\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Select another segment and swap nodes between them\n    if n > 4:\n        other_start = random.randint(0, n-3)\n        other_end = random.randint(other_start+1, min(other_start+5, n-2))\n        if other_start != start and other_end != end:\n            # Ensure segments don't overlap\n            segment1 = new_solution[start:end+1]\n            segment2 = new_solution[other_start:other_end+1]\n            # Swap nodes between segments\n            swap_pos1 = random.randint(0, len(segment1)-1)\n            swap_pos2 = random.randint(0, len(segment2)-1)\n            new_solution[start+swap_pos1], new_solution[other_start+swap_pos2] = new_solution[other_start+swap_pos2], new_solution[start+swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.8726940903174155,
            2.2277220487594604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst objective in either space\n    selected_idx = 0\n    worst_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        current_worst = max(obj1, obj2)\n        if current_worst > worst_obj:\n            worst_obj = current_worst\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Objective-balanced segment inversion and swap\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Select another segment and swap nodes between them\n    if n > 4:\n        other_start = random.randint(0, n-3)\n        other_end = random.randint(other_start+1, min(other_start+5, n-2))\n        if other_start != start and other_end != end:\n            # Ensure segments don't overlap\n            segment1 = new_solution[start:end+1]\n            segment2 = new_solution[other_start:other_end+1]\n            # Swap nodes between segments\n            swap_pos1 = random.randint(0, len(segment1)-1)\n            swap_pos2 = random.randint(0, len(segment2)-1)\n            new_solution[start+swap_pos1], new_solution[other_start+swap_pos2] = new_solution[other_start+swap_pos2], new_solution[start+swap_pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and dominance, then applies a hybrid local search combining path reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective values (prioritize lower objectives)\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: path reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7225162114064205,
            2.2345581650733948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective values (prioritize lower objectives)\n    selected_idx = 0\n    min_obj_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        obj_sum = obj1 + obj2\n        if obj_sum < min_obj_sum:\n            min_obj_sum = obj_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: path reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = (obj1 + obj2) * (1 + random.uniform(0, 0.5))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    node_pos = random.randint(0, n-1)\n    insert_pos = random.randint(0, n-1)\n    while insert_pos == node_pos or insert_pos == node_pos+1 or insert_pos == node_pos-1:\n        insert_pos = random.randint(0, n-1)\n\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8934988323678758,
            1.9776508808135986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = (obj1 + obj2) * (1 + random.uniform(0, 0.5))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    node_pos = random.randint(0, n-1)\n    insert_pos = random.randint(0, n-1)\n    while insert_pos == node_pos or insert_pos == node_pos+1 or insert_pos == node_pos-1:\n        insert_pos = random.randint(0, n-1)\n\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This heuristic function selects a solution from the archive based on a novel scoring mechanism combining objective values and solution diversity, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on a novel scoring mechanism\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        score = (obj1 * 0.7 + obj2 * 0.3) * (1 + 0.1 * len(set(sol)))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Segment reversal\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.813843531982841,
            2.41697096824646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on a novel scoring mechanism\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        score = (obj1 * 0.7 + obj2 * 0.3) * (1 + 0.1 * len(set(sol)))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Segment reversal\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance, then applies a novel hybrid local search combining segment inversion and node insertion to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on combined objective values\n    selected_idx = 0\n    min_combined = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        combined = obj1 + obj2\n        if combined < min_combined:\n            min_combined = combined\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a different position\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    insert_pos = random.randint(0, n-1)\n    if insert_pos > node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:insert_pos+1], [node], new_solution[insert_pos+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:node_pos], new_solution[node_pos+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9031358832176068,
            2.1794744729995728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on combined objective values\n    selected_idx = 0\n    min_combined = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        combined = obj1 + obj2\n        if combined < min_combined:\n            min_combined = combined\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a different position\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    insert_pos = random.randint(0, n-1)\n    if insert_pos > node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:insert_pos+1], [node], new_solution[insert_pos+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:node_pos], new_solution[node_pos+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance relationships, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on weighted objective values and dominance\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score (weighted combination of objectives)\n        score = -0.7 * obj1 - 0.3 * obj2\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + node insertion\n    # Step 1: 3-opt operation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([], dtype=int)\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7939957757087406,
            0.22838646173477173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on weighted objective values and dominance\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score (weighted combination of objectives)\n        score = -0.7 * obj1 - 0.3 * obj2\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + node insertion\n    # Step 1: 3-opt operation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([], dtype=int)\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This heuristic function selects a promising solution from the archive based on a combination of objective values and dominance, then applies a novel local search combining segment inversion and node reinsertion with a focus on balancing both objectives to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = 0\n    min_balance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        balance = abs(obj1 - obj2)\n        if balance < min_balance:\n            min_balance = balance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.595806239275405,
            2.263277590274811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = 0\n    min_balance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        balance = abs(obj1 - obj2)\n        if balance < min_balance:\n            min_balance = balance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid scoring function combining objective values and node centrality, then applies a novel local search operator that combines 3-opt with a constrained segment inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid scoring function combining objective values and node centrality\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate centrality as average distance to neighbors\n        centrality = 0\n        for i in range(len(sol)):\n            prev_node = sol[i-1]\n            next_node = sol[(i+1)%len(sol)]\n            centrality += distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]\n        centrality /= len(sol)\n\n        # Hybrid score: inverse of combined objectives plus centrality\n        score = 1 / (obj1 + obj2 + 1) + centrality\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Novel local search: 3-opt with constrained segment inversion\n    # Select three random edges to break\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create three possible reconnections\n    candidates = [\n        np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[c:b-1:-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b], new_solution[c:a-1:-1], new_solution[b:c], new_solution[a:]])\n    ]\n\n    # Select the best candidate based on combined objective improvement\n    best_candidate = new_solution\n    min_cost = float('inf')\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate\n\n    return best_candidate\n\n",
        "score": [
            -0.6257923145509016,
            13.049211740493774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid scoring function combining objective values and node centrality\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate centrality as average distance to neighbors\n        centrality = 0\n        for i in range(len(sol)):\n            prev_node = sol[i-1]\n            next_node = sol[(i+1)%len(sol)]\n            centrality += distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]\n        centrality /= len(sol)\n\n        # Hybrid score: inverse of combined objectives plus centrality\n        score = 1 / (obj1 + obj2 + 1) + centrality\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Novel local search: 3-opt with constrained segment inversion\n    # Select three random edges to break\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create three possible reconnections\n    candidates = [\n        np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[c:b-1:-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b], new_solution[c:a-1:-1], new_solution[b:c], new_solution[a:]])\n    ]\n\n    # Select the best candidate based on combined objective improvement\n    best_candidate = new_solution\n    min_cost = float('inf')\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm selects a solution with high crowding distance and applies a novel segment inversion and node insertion strategy, where a random segment is inverted and reinserted at a different position, followed by inserting a randomly selected node at a new location to explore improved solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment and reinsert it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], inverted_segment, remaining[insert_pos:]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_to_insert = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.8005518260348701,
            1.9201350212097168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment and reinsert it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], inverted_segment, remaining[insert_pos:]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_to_insert = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = (obj1 - obj2) ** 2  # Measure of diversity between objectives\n        score = (obj1 + obj2) * (1 + diversity / (obj1 + obj2 + 1e-6))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node in a different position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.39062817219419266,
            1.879654884338379
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = (obj1 - obj2) ** 2  # Measure of diversity between objectives\n        score = (obj1 + obj2) * (1 + diversity / (obj1 + obj2 + 1e-6))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node in a different position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This heuristic function selects a solution from the archive based on the sum of normalized objective values, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at another position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9022908001750976,
            1.3499042391777039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at another position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This heuristic function selects a solution from the archive using a novel adaptive selection strategy that combines objective diversity and solution quality, then applies a unique local search operator that performs a combination of path inversion and node reinsertion with a bias towards improving the objective with the higher variance in the archive, ensuring feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection based on objective diversity and quality\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances) if np.random.random() > 0.5 else np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive local search: path inversion + biased node reinsertion\n    if np.random.random() > 0.5:\n        # Path inversion\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Biased node reinsertion\n        node = random.choice(base_solution)\n        pos = np.where(base_solution == node)[0][0]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8097959782137549,
            1.874222993850708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection based on objective diversity and quality\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances) if np.random.random() > 0.5 else np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive local search: path inversion + biased node reinsertion\n    if np.random.random() > 0.5:\n        # Path inversion\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Biased node reinsertion\n        node = random.choice(base_solution)\n        pos = np.where(base_solution == node)[0][0]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This heuristic function selects a diverse solution from the archive by considering both crowding distance and objective space balance, then applies a novel local search combining segment inversion and adaptive edge insertion to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on crowding distance and objective balance\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = (obj1 + obj2) / (abs(obj1 - obj2) + 1)  # Balance between objectives\n        if crowding > best_score:\n            best_score = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + adaptive edge insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Adaptive edge insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Insert node i after node j\n        new_solution = np.concatenate([\n            new_solution[:j+1],\n            np.array([new_solution[i]]),\n            new_solution[j+1:i] if i > j else new_solution[j+1:i],\n            new_solution[i+1:] if i < j else new_solution[i:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8816522765668449,
            0.35745370388031006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on crowding distance and objective balance\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = (obj1 + obj2) / (abs(obj1 - obj2) + 1)  # Balance between objectives\n        if crowding > best_score:\n            best_score = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + adaptive edge insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Adaptive edge insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Insert node i after node j\n        new_solution = np.concatenate([\n            new_solution[:j+1],\n            np.array([new_solution[i]]),\n            new_solution[j+1:i] if i > j else new_solution[j+1:i],\n            new_solution[i+1:] if i < j else new_solution[i:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining alternating segment reversal and node insertion with distance-aware selection to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective and distance-aware selection\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = obj1 + obj2 + random.uniform(0, 0.1) * (obj1 * obj2)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Alternating segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    if random.random() < 0.5:\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Distance-aware node insertion\n    i = random.randint(0, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = random.randint(0, n-2)\n\n    # Find position that minimizes combined distance increase\n    min_cost = float('inf')\n    best_pos = insert_pos\n    for pos in range(max(0, insert_pos-2), min(n-1, insert_pos+2)):\n        prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n        cost = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] + \\\n               distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9776103468738107,
            1.7978425025939941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective and distance-aware selection\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = obj1 + obj2 + random.uniform(0, 0.1) * (obj1 * obj2)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Alternating segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    if random.random() < 0.5:\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Distance-aware node insertion\n    i = random.randint(0, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = random.randint(0, n-2)\n\n    # Find position that minimizes combined distance increase\n    min_cost = float('inf')\n    best_pos = insert_pos\n    for pos in range(max(0, insert_pos-2), min(n-1, insert_pos+2)):\n        prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n        cost = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] + \\\n               distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.012794274207559,
            2.059691548347473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.012794274207559,
            2.059691548347473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment inversion and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = (obj1 + obj2) * (1 + random.uniform(0, 0.1))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8259417960577332,
            2.0674044489860535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = (obj1 + obj2) * (1 + random.uniform(0, 0.1))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        total_obj = obj1 + obj2\n        if total_obj > max_obj:\n            max_obj = total_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9805397941925417,
            2.3771756887435913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_obj = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        total_obj = obj1 + obj2\n        if total_obj > max_obj:\n            max_obj = total_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This heuristic function selects a solution from the archive based on the minimum sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with minimum normalized objective sum\n    min_norm = float('inf')\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm = (obj1 / distance_matrix_1.max()) + (obj2 / distance_matrix_2.max())\n        if norm < min_norm:\n            min_norm = norm\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at another position\n    i, j = random.sample(range(n), 2)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6067284865783616,
            2.622797191143036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with minimum normalized objective sum\n    min_norm = float('inf')\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm = (obj1 / distance_matrix_1.max()) + (obj2 / distance_matrix_2.max())\n        if norm < min_norm:\n            min_norm = norm\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at another position\n    i, j = random.sample(range(n), 2)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This heuristic function selects a solution from the archive based on a novel score combining objective values and solution diversity, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = sum(abs(sol[j] - archive[(i+1)%len(archive)][0][j]) for j in range(len(sol)))\n        score = (obj1 + obj2) * (1 + diversity/len(sol))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8075294825568238,
            7.295608222484589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = sum(abs(sol[j] - archive[(i+1)%len(archive)][0][j]) for j in range(len(sol)))\n        score = (obj1 + obj2) * (1 + diversity/len(sol))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized objective values, then applies a hybrid local search combining a 3-opt move with a segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on normalized objective values\n    selected_idx = 0\n    min_norm = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm = (obj1 + obj2) / (distance_matrix_1.sum() + distance_matrix_2.sum())\n        if norm < min_norm:\n            min_norm = norm\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt move + segment inversion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[a:b+1] = new_segment\n\n    # Perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7259206178220747,
            2.021895945072174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on normalized objective values\n    selected_idx = 0\n    min_norm = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm = (obj1 + obj2) / (distance_matrix_1.sum() + distance_matrix_2.sum())\n        if norm < min_norm:\n            min_norm = norm\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt move + segment inversion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[a:b+1] = new_segment\n\n    # Perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel local search combining node insertion, segment reversal, and cost-aware edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and solution quality\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random node and insert it at a better position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Calculate potential insertion positions\n    candidates = []\n    for i in range(n):\n        if i != node_idx and i != (node_idx - 1) % n:\n            # Calculate cost change for inserting node after position i\n            prev_node = new_solution[i]\n            next_node = new_solution[(i+1) % n]\n            old_cost = distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]\n            new_cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            gain = old_cost - new_cost\n            candidates.append((i, gain))\n\n    if candidates:\n        # Select position with maximum gain\n        best_pos, _ = max(candidates, key=lambda x: x[1])\n        # Remove node from current position\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        # Insert node at best position\n        new_solution = np.concatenate([new_solution[:best_pos+1], [node], new_solution[best_pos+1:]])\n\n    # Step 2: Reverse a random segment if it improves both objectives\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost change\n    prev_node = new_solution[(start-1) % n]\n    next_node = new_solution[(end+1) % n]\n    old_cost = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] + \\\n               distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n    new_cost = distance_matrix_1[prev_node, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_node] + \\\n               distance_matrix_2[prev_node, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_node]\n\n    if new_cost < old_cost:\n        new_solution[start:end+1] = reversed_segment\n\n    # Step 3: Perform cost-aware edge swapping\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate cost change\n    a, b, c, d = new_solution[i], new_solution[j], new_solution[(i+1)%n], new_solution[(j-1)%n]\n    old_cost = distance_matrix_1[a, b] + distance_matrix_1[c, d] + \\\n               distance_matrix_2[a, b] + distance_matrix_2[c, d]\n    new_cost = distance_matrix_1[a, c] + distance_matrix_1[b, d] + \\\n               distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n    if new_cost < old_cost:\n        # Perform the swap\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.843676393746871,
            2.7035641074180603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and solution quality\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random node and insert it at a better position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Calculate potential insertion positions\n    candidates = []\n    for i in range(n):\n        if i != node_idx and i != (node_idx - 1) % n:\n            # Calculate cost change for inserting node after position i\n            prev_node = new_solution[i]\n            next_node = new_solution[(i+1) % n]\n            old_cost = distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]\n            new_cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            gain = old_cost - new_cost\n            candidates.append((i, gain))\n\n    if candidates:\n        # Select position with maximum gain\n        best_pos, _ = max(candidates, key=lambda x: x[1])\n        # Remove node from current position\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        # Insert node at best position\n        new_solution = np.concatenate([new_solution[:best_pos+1], [node], new_solution[best_pos+1:]])\n\n    # Step 2: Reverse a random segment if it improves both objectives\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost change\n    prev_node = new_solution[(start-1) % n]\n    next_node = new_solution[(end+1) % n]\n    old_cost = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] + \\\n               distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n    new_cost = distance_matrix_1[prev_node, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_node] + \\\n               distance_matrix_2[prev_node, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_node]\n\n    if new_cost < old_cost:\n        new_solution[start:end+1] = reversed_segment\n\n    # Step 3: Perform cost-aware edge swapping\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate cost change\n    a, b, c, d = new_solution[i], new_solution[j], new_solution[(i+1)%n], new_solution[(j-1)%n]\n    old_cost = distance_matrix_1[a, b] + distance_matrix_1[c, d] + \\\n               distance_matrix_2[a, b] + distance_matrix_2[c, d]\n    new_cost = distance_matrix_1[a, c] + distance_matrix_1[b, d] + \\\n               distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n    if new_cost < old_cost:\n        # Perform the swap\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This heuristic function selects a solution from the archive using a combination of dominance rank and objective space similarity to prioritize solutions with diverse trade-offs, then applies a novel hybrid local search combining segment inversion and cross-space edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective space\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel hybrid local search: segment inversion + cross-space edge insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Cross-space edge insertion\n    # Find the best edge from the first objective space to insert in the second\n    best_pos = -1\n    best_gain = 0\n\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):\n            # Calculate gain based on both objectives\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + \\\n                          distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + \\\n                      distance_matrix_1[new_solution[i], new_solution[j-1]]\n            gain = current_cost - new_cost\n\n            # Also consider the second objective\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                           distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                       distance_matrix_2[new_solution[i], new_solution[j-1]]\n            gain2 = current_cost2 - new_cost2\n\n            # Combined gain metric\n            combined_gain = gain + gain2\n\n            if combined_gain > best_gain:\n                best_gain = combined_gain\n                best_pos = i\n\n    if best_pos != -1:\n        # Perform the edge insertion\n        i = best_pos\n        j = (i + 1) % n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5105705252199368,
            4.2558265924453735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective space\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel hybrid local search: segment inversion + cross-space edge insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Cross-space edge insertion\n    # Find the best edge from the first objective space to insert in the second\n    best_pos = -1\n    best_gain = 0\n\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):\n            # Calculate gain based on both objectives\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + \\\n                          distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + \\\n                      distance_matrix_1[new_solution[i], new_solution[j-1]]\n            gain = current_cost - new_cost\n\n            # Also consider the second objective\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                           distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                       distance_matrix_2[new_solution[i], new_solution[j-1]]\n            gain2 = current_cost2 - new_cost2\n\n            # Combined gain metric\n            combined_gain = gain + gain2\n\n            if combined_gain > best_gain:\n                best_gain = combined_gain\n                best_pos = i\n\n    if best_pos != -1:\n        # Perform the edge insertion\n        i = best_pos\n        j = (i + 1) % n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and their diversity in the archive, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objectives and diversity\n    weights = [0.7, 0.3]  # Weight for first objective is higher\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining objective values and diversity\n        diversity = 1.0 / (1 + np.sum(np.abs(np.array([obj1, obj2]) - np.array([x[1][0] for x in archive]).mean(axis=0))))\n        score = weights[0] * obj1 + weights[1] * obj2 + diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal and node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.8012244203962908,
            10.01386684179306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objectives and diversity\n    weights = [0.7, 0.3]  # Weight for first objective is higher\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining objective values and diversity\n        diversity = 1.0 / (1 + np.sum(np.abs(np.array([obj1, obj2]) - np.array([x[1][0] for x in archive]).mean(axis=0))))\n        score = weights[0] * obj1 + weights[1] * obj2 + diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment reversal and node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment rotation and node swapping with adjacent nodes to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, shift=random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap a random node with its adjacent node\n    pos = random.randint(0, n-2)\n    new_solution[pos], new_solution[pos+1] = new_solution[pos+1], new_solution[pos]\n\n    return new_solution\n\n",
        "score": [
            -0.9783025016179646,
            2.0958492755889893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, shift=random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap a random node with its adjacent node\n    pos = random.randint(0, n-2)\n    new_solution[pos], new_solution[pos+1] = new_solution[pos+1], new_solution[pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_pos = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Exchange two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment inversion and node insertion with position optimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = (obj1 + obj2) * (1 + random.random())  # Add randomness for diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at an optimized position\n    node_to_move = random.choice(new_solution)\n    mask = new_solution != node_to_move\n    remaining = new_solution[mask]\n\n    # Evaluate insertion positions based on both distance matrices\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(len(remaining)):\n        candidate = np.insert(remaining, pos, node_to_move)\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.5355815670642261,
            14.300321698188782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = (obj1 + obj2) * (1 + random.random())  # Add randomness for diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at an optimized position\n    node_to_move = random.choice(new_solution)\n    mask = new_solution != node_to_move\n    remaining = new_solution[mask]\n\n    # Evaluate insertion positions based on both distance matrices\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(len(remaining)):\n        candidate = np.insert(remaining, pos, node_to_move)\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of dominance rank and objective diversity, then applies a hybrid local search combining partial path reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity and dominance\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity\n        score = (obj1 + obj2) / (1 + abs(obj1 - obj2))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: partial path reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_pos = random.randint(0, n-1)\n    mask = new_solution != node\n    new_solution = np.concatenate([new_solution[mask][:new_pos], [node], new_solution[mask][new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.871229553537497,
            1.3732253313064575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity and dominance\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity\n        score = (obj1 + obj2) / (1 + abs(obj1 - obj2))\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: partial path reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_pos = random.randint(0, n-1)\n    mask = new_solution != node\n    new_solution = np.concatenate([new_solution[mask][:new_pos], [node], new_solution[mask][new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest product of normalized objectives, then applies a hybrid local search combining segment rotation and node swapping with distance-aware selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two nodes with highest distance difference\n    max_diff = -1\n    swap_i, swap_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            dist_diff = abs(distance_matrix_1[node_i, node_j] - distance_matrix_2[node_i, node_j])\n            if dist_diff > max_diff:\n                max_diff = dist_diff\n                swap_i, swap_j = i, j\n    new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n",
        "score": [
            -0.8624885260691174,
            4.908144235610962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two nodes with highest distance difference\n    max_diff = -1\n    swap_i, swap_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            dist_diff = abs(distance_matrix_1[node_i, node_j] - distance_matrix_2[node_i, node_j])\n            if dist_diff > max_diff:\n                max_diff = dist_diff\n                swap_i, swap_j = i, j\n    new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest combined improvement potential in both objectives, then applies a hybrid local search combining segment rotation and node swapping with distance-aware selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    max_potential = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential based on both objectives\n        potential = obj1 * obj2  # Product of objectives as improvement potential metric\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a segment by a random amount\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    segment = np.roll(segment, rotate_amount)\n    new_solution[start:end+1] = segment\n\n    # Step 2: Distance-aware node swap\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Select the swap that improves both objectives more\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or \\\n           (random.random() < 0.3):  # 30% chance to accept if not strictly better\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9187188474593351,
            1.3729423880577087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    max_potential = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential based on both objectives\n        potential = obj1 * obj2  # Product of objectives as improvement potential metric\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a segment by a random amount\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    segment = np.roll(segment, rotate_amount)\n    new_solution[start:end+1] = segment\n\n    # Step 2: Distance-aware node swap\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Select the swap that improves both objectives more\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or \\\n           (random.random() < 0.3):  # 30% chance to accept if not strictly better\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This heuristic function selects a solution with the lowest combined objective value from the archive, then applies a novel segment inversion and cross-exchange local search to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Perform a cross-exchange between two random segments\n    i1, i2 = sorted(random.sample(range(n), 2))\n    j1, j2 = sorted(random.sample(range(n), 2))\n    if i1 == i2 or j1 == j2:\n        return new_solution\n\n    segment1 = new_solution[i1:i2+1]\n    segment2 = new_solution[j1:j2+1]\n    new_solution = np.concatenate([\n        new_solution[:i1], segment2, new_solution[i2+1:j1], segment1, new_solution[j2+1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.622407653663216,
            0.5113434791564941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Perform a cross-exchange between two random segments\n    i1, i2 = sorted(random.sample(range(n), 2))\n    j1, j2 = sorted(random.sample(range(n), 2))\n    if i1 == i2 or j1 == j2:\n        return new_solution\n\n    segment1 = new_solution[i1:i2+1]\n    segment2 = new_solution[j1:j2+1]\n    new_solution = np.concatenate([\n        new_solution[:i1], segment2, new_solution[i2+1:j1], segment1, new_solution[j2+1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    selected_idx = 0\n    best_score = float('-inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a combined score (weighted sum of objectives)\n        score = -0.6 * obj1 - 0.4 * obj2  # Higher weights for better solutions\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6877790184102464,
            1.5671634674072266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    selected_idx = 0\n    best_score = float('-inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a combined score (weighted sum of objectives)\n        score = -0.6 * obj1 - 0.4 * obj2  # Higher weights for better solutions\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search strategy that combines segment inversion and crossover-like operations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.choice([i for i in range(len(archive)) if archive[i][1][0] + archive[i][1][1] > sum(obj[0] + obj[1] for _, obj in archive) / len(archive)])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and crossover-like operation\n    # Step 1: Select and invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a crossover-like operation with another random segment\n    other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n    crossover_start = random.randint(0, n-2)\n    crossover_end = random.randint(crossover_start+1, n-1)\n    new_solution[crossover_start:crossover_end+1] = other_sol[crossover_start:crossover_end+1]\n\n    # Ensure feasibility by fixing any duplicates\n    for i in range(n):\n        if np.count_nonzero(new_solution == new_solution[i]) > 1:\n            missing = list(set(np.arange(n)) - set(new_solution))\n            if missing:\n                new_solution[i] = random.choice(missing)\n\n    return new_solution\n\n",
        "score": [
            -0.7120526002664849,
            2.6261796951293945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.choice([i for i in range(len(archive)) if archive[i][1][0] + archive[i][1][1] > sum(obj[0] + obj[1] for _, obj in archive) / len(archive)])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and crossover-like operation\n    # Step 1: Select and invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a crossover-like operation with another random segment\n    other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n    crossover_start = random.randint(0, n-2)\n    crossover_end = random.randint(crossover_start+1, n-1)\n    new_solution[crossover_start:crossover_end+1] = other_sol[crossover_start:crossover_end+1]\n\n    # Ensure feasibility by fixing any duplicates\n    for i in range(n):\n        if np.count_nonzero(new_solution == new_solution[i]) > 1:\n            missing = list(set(np.arange(n)) - set(new_solution))\n            if missing:\n                new_solution[i] = random.choice(missing)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This heuristic function selects a solution from the archive based on a balance between objective values and diversity, then applies a novel local search combining node insertion and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a balance between objective values and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[(obj1 + obj2) / (i + 1) for i, (sol, (obj1, obj2)) in enumerate(archive)])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: node insertion with path reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random node and insert it at a different position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment to disrupt the path\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8216706432905683,
            2.3570335507392883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a balance between objective values and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[(obj1 + obj2) / (i + 1) for i, (sol, (obj1, obj2)) in enumerate(archive)])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: node insertion with path reversal\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random node and insert it at a different position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment to disrupt the path\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining normalized objective values and dominance rank, then applies a segment inversion and edge reversal hybrid local search to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective scores and dominance ranks\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4  # Weighted sum\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Segment inversion\n    start = random.randint(0, n-4)\n    end = random.randint(start+2, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge reversal\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, min(i+3, n-1))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9665862323463104,
            1.7517048120498657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective scores and dominance ranks\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4  # Weighted sum\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Segment inversion\n    start = random.randint(0, n-4)\n    end = random.randint(start+2, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge reversal\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, min(i+3, n-1))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This new algorithm selects the solution with the highest sum of normalized objective values, then applies a novel local search combining segment rotation, node swap with distance-aware selection, and probabilistic edge reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Distance-aware node swap\n    i, j = random.sample(range(n), 2)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n    total_dist = (distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j]) / 2\n    if total_dist > (distance_matrix_1[node_i, node_i] + distance_matrix_2[node_i, node_i]) / 2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Probabilistic edge reversal\n    for i in range(n-1):\n        if random.random() < 0.2:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7784856486765901,
            1.8914276361465454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Distance-aware node swap\n    i, j = random.sample(range(n), 2)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n    total_dist = (distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j]) / 2\n    if total_dist > (distance_matrix_1[node_i, node_i] + distance_matrix_2[node_i, node_i]) / 2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Probabilistic edge reversal\n    for i in range(n-1):\n        if random.random() < 0.2:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This new algorithm selects a solution from the archive based on the lowest sum of normalized objective values, then applies a hybrid local search combining segment rotation and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    min_sum = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum < min_sum:\n            min_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7950997474932423,
            1.3353575468063354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    min_sum = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum < min_sum:\n            min_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic score combining objective values and solution diversity, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dynamic score combining objectives and diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate a dynamic score combining objectives and diversity\n        diversity = len(set(sol[:len(sol)//2])) / len(sol)  # Fraction of unique nodes in first half\n        score = (obj1 + obj2) / (1 + diversity)  # Higher score for better trade-off\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)  # Select solution with lowest score (best trade-off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node from another random position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8680483342684635,
            1.3256045579910278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dynamic score combining objectives and diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate a dynamic score combining objectives and diversity\n        diversity = len(set(sol[:len(sol)//2])) / len(sol)  # Fraction of unique nodes in first half\n        score = (obj1 + obj2) / (1 + diversity)  # Higher score for better trade-off\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)  # Select solution with lowest score (best trade-off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node from another random position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of objective values (instead of sum or crowding distance), then applies a hybrid local search combining node inversion and segment crossover to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of objectives\n    max_product = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        current_product = obj1 * obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random node's position\n    node_idx = random.randint(0, n-1)\n    new_solution[node_idx] = base_solution[-node_idx-1]\n\n    # Step 2: Perform segment crossover\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    crossover_point = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:crossover_point], segment, new_solution[crossover_point:]])\n\n    # Ensure uniqueness\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique_nodes[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        if len(missing) > 0:\n            replace_pos = np.where(new_solution == dup)[0][1]\n            new_solution[replace_pos] = random.choice(missing)\n\n    return new_solution\n\n",
        "score": [
            -0.9428653641358173,
            0.9433215856552124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of objectives\n    max_product = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        current_product = obj1 * obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random node's position\n    node_idx = random.randint(0, n-1)\n    new_solution[node_idx] = base_solution[-node_idx-1]\n\n    # Step 2: Perform segment crossover\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    crossover_point = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:crossover_point], segment, new_solution[crossover_point:]])\n\n    # Ensure uniqueness\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique_nodes[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        if len(missing) > 0:\n            replace_pos = np.where(new_solution == dup)[0][1]\n            new_solution[replace_pos] = random.choice(missing)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment inversion and node swapping with alternating patterns to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment with alternating pattern\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted = segment[::-1]\n    for i in range(len(inverted)):\n        if i % 2 == 0:\n            inverted[i] = segment[i]\n    new_solution[start:end+1] = inverted\n\n    # Step 2: Swap nodes with alternating pattern\n    for i in range(0, n-1, 2):\n        if random.random() < 0.5:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9309679627310306,
            0.5203272104263306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment with alternating pattern\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    inverted = segment[::-1]\n    for i in range(len(inverted)):\n        if i % 2 == 0:\n            inverted[i] = segment[i]\n    new_solution[start:end+1] = inverted\n\n    # Step 2: Swap nodes with alternating pattern\n    for i in range(0, n-1, 2):\n        if random.random() < 0.5:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8428345007716072,
            1.5464894771575928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining node swapping and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of normalized objectives\n    selected_idx = 0\n    max_product = -1\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Perform node swapping based on distance improvement\n    i, j = random.sample(range(n), 2)\n    old_dist1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n    new_dist1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n    if new_dist1 < old_dist1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Rotate a segment to improve both objectives\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated\n\n    return new_solution\n\n",
        "score": [
            -0.8705368576228177,
            2.3682644963264465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of normalized objectives\n    selected_idx = 0\n    max_product = -1\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Perform node swapping based on distance improvement\n    i, j = random.sample(range(n), 2)\n    old_dist1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n    new_dist1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n    if new_dist1 < old_dist1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Rotate a segment to improve both objectives\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with high crowding distance, then applies a novel local search combining path inversion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Invert the entire path between two random nodes\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9251265860032208,
            2.201274871826172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Invert the entire path between two random nodes\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining 3-opt and a novel segment inversion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    # 3-opt step\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:d+1]\n    new_segments = [\n        np.concatenate([segment1, segment2, segment3]),\n        np.concatenate([segment1, segment3, segment2]),\n        np.concatenate([segment2, segment1, segment3]),\n        np.concatenate([segment2, segment3, segment1]),\n        np.concatenate([segment3, segment1, segment2]),\n        np.concatenate([segment3, segment2, segment1])\n    ]\n    new_solution[a:d+1] = random.choice(new_segments)\n\n    # Segment inversion step\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9318430688244346,
            2.4491597414016724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    # 3-opt step\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:d+1]\n    new_segments = [\n        np.concatenate([segment1, segment2, segment3]),\n        np.concatenate([segment1, segment3, segment2]),\n        np.concatenate([segment2, segment1, segment3]),\n        np.concatenate([segment2, segment3, segment1]),\n        np.concatenate([segment3, segment1, segment2]),\n        np.concatenate([segment3, segment2, segment1])\n    ]\n    new_solution[a:d+1] = random.choice(new_segments)\n\n    # Segment inversion step\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment inversion and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + adaptive edge insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive edge insertion\n    # Calculate diversity score for each node\n    diversity_scores = []\n    for i in range(n):\n        node = base_solution[i]\n        neighbors = [base_solution[(i-1)%n], base_solution[(i+1)%n]]\n        diversity = sum(distance_matrix_1[node, neighbor] + distance_matrix_2[node, neighbor] for neighbor in neighbors)\n        diversity_scores.append(diversity)\n\n    # Select a node with low diversity for insertion\n    min_diversity_idx = np.argmin(diversity_scores)\n    node_to_insert = new_solution[min_diversity_idx]\n\n    # Find the best insertion position\n    best_pos = 0\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate cost of inserting node_to_insert between i and j\n            cost = (distance_matrix_1[new_solution[i], node_to_insert] +\n                    distance_matrix_1[node_to_insert, new_solution[j]] -\n                    distance_matrix_1[new_solution[i], new_solution[j]]) + \\\n                   (distance_matrix_2[new_solution[i], node_to_insert] +\n                    distance_matrix_2[node_to_insert, new_solution[j]] -\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = (i, j)\n\n    # Perform the insertion\n    i, j = best_pos\n    new_solution = np.concatenate([new_solution[:i+1], [node_to_insert], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8925514650937446,
            8.622088134288788
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + adaptive edge insertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive edge insertion\n    # Calculate diversity score for each node\n    diversity_scores = []\n    for i in range(n):\n        node = base_solution[i]\n        neighbors = [base_solution[(i-1)%n], base_solution[(i+1)%n]]\n        diversity = sum(distance_matrix_1[node, neighbor] + distance_matrix_2[node, neighbor] for neighbor in neighbors)\n        diversity_scores.append(diversity)\n\n    # Select a node with low diversity for insertion\n    min_diversity_idx = np.argmin(diversity_scores)\n    node_to_insert = new_solution[min_diversity_idx]\n\n    # Find the best insertion position\n    best_pos = 0\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate cost of inserting node_to_insert between i and j\n            cost = (distance_matrix_1[new_solution[i], node_to_insert] +\n                    distance_matrix_1[node_to_insert, new_solution[j]] -\n                    distance_matrix_1[new_solution[i], new_solution[j]]) + \\\n                   (distance_matrix_2[new_solution[i], node_to_insert] +\n                    distance_matrix_2[node_to_insert, new_solution[j]] -\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = (i, j)\n\n    # Perform the insertion\n    i, j = best_pos\n    new_solution = np.concatenate([new_solution[:i+1], [node_to_insert], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment rotation and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    shift = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.roll(segment, shift)\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8079566903789189,
            1.7416294813156128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    shift = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.roll(segment, shift)\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This new algorithm selects a solution from the archive based on the minimal ratio of the two objectives, then applies a hybrid local search combining 3-opt and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with minimal ratio of objectives\n    min_ratio = float('inf')\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        if obj2 == 0:\n            continue\n        ratio = obj1 / obj2\n        if ratio < min_ratio:\n            min_ratio = ratio\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: 3-opt move\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_solution[a:d] = np.concatenate([segment1, segment3, segment2])\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8513080958793076,
            2.2243542075157166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with minimal ratio of objectives\n    min_ratio = float('inf')\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        if obj2 == 0:\n            continue\n        ratio = obj1 / obj2\n        if ratio < min_ratio:\n            min_ratio = ratio\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: 3-opt move\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_solution[a:d] = np.concatenate([segment1, segment3, segment2])\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest normalized product of objective values, then applies a hybrid local search combining segment rotation and node swapping with distance-aware selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n-segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Swap two nodes with high distance in both objectives\n    i, j = random.sample(range(n), 2)\n    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n    if dist1 + dist2 > (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8566880627861275,
            2.474774122238159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n-segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Swap two nodes with high distance in both objectives\n    i, j = random.sample(range(n), 2)\n    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n    if dist1 + dist2 > (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This heuristic selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select based on weighted normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1][::-1]  # Invert segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node insertion\n    if n > 3:\n        node = random.choice(new_solution)\n        new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    return new_solution\n\n",
        "score": [
            -0.8958728741433577,
            2.5509209036827087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select based on weighted normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1][::-1]  # Invert segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node insertion\n    if n > 3:\n        node = random.choice(new_solution)\n        new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel node clustering step to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Cluster nodes based on their positions in both spaces and reorder clusters\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        prev_coords = instance[prev_node]\n        curr_coords = instance[curr_node]\n\n        # Calculate distances in both spaces\n        dist1 = np.linalg.norm(prev_coords[:2] - curr_coords[:2])\n        dist2 = np.linalg.norm(prev_coords[2:] - curr_coords[2:])\n\n        # If distances are both small, add to current cluster\n        if dist1 < 10 and dist2 < 10:\n            current_cluster.append(curr_node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [curr_node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Reorder clusters randomly\n    random.shuffle(clusters)\n\n    # Reconstruct solution from reordered clusters\n    new_solution = np.concatenate([np.array(cluster) for cluster in clusters])\n\n    return new_solution\n\n",
        "score": [
            -0.8711016413310122,
            3.3243691325187683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Cluster nodes based on their positions in both spaces and reorder clusters\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        prev_coords = instance[prev_node]\n        curr_coords = instance[curr_node]\n\n        # Calculate distances in both spaces\n        dist1 = np.linalg.norm(prev_coords[:2] - curr_coords[:2])\n        dist2 = np.linalg.norm(prev_coords[2:] - curr_coords[2:])\n\n        # If distances are both small, add to current cluster\n        if dist1 < 10 and dist2 < 10:\n            current_cluster.append(curr_node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [curr_node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Reorder clusters randomly\n    random.shuffle(clusters)\n\n    # Reconstruct solution from reordered clusters\n    new_solution = np.concatenate([np.array(cluster) for cluster in clusters])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This new algorithm prioritizes solutions with high objective diversity by selecting those with the largest Euclidean distance in the objective space, then applies a hybrid local search combining 2-opt with a novel segment inversion operator to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with maximum Euclidean distance in objective space\n    selected_idx = 0\n    max_dist = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        dist = np.sqrt(obj1**2 + obj2**2)\n        if dist > max_dist:\n            max_dist = dist\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: 2-opt + segment inversion\n    # 2-opt step\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment inversion step\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8304021350314036,
            2.4456703662872314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with maximum Euclidean distance in objective space\n    selected_idx = 0\n    max_dist = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        dist = np.sqrt(obj1**2 + obj2**2)\n        if dist > max_dist:\n            max_dist = dist\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: 2-opt + segment inversion\n    # 2-opt step\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment inversion step\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel segment swap operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Swap two random segments of equal length\n    if n >= 6:\n        seg_length = random.randint(1, (n-2)//2)\n        seg1_start = random.randint(0, n-2*seg_length)\n        seg2_start = random.randint(seg1_start + seg_length, n-seg_length)\n\n        seg1 = new_solution[seg1_start:seg1_start+seg_length].copy()\n        seg2 = new_solution[seg2_start:seg2_start+seg_length].copy()\n\n        new_solution[seg1_start:seg1_start+seg_length] = seg2\n        new_solution[seg2_start:seg2_start+seg_length] = seg1\n\n    return new_solution\n\n",
        "score": [
            -0.9531766971957016,
            2.179139792919159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Swap two random segments of equal length\n    if n >= 6:\n        seg_length = random.randint(1, (n-2)//2)\n        seg1_start = random.randint(0, n-2*seg_length)\n        seg2_start = random.randint(seg1_start + seg_length, n-seg_length)\n\n        seg1 = new_solution[seg1_start:seg1_start+seg_length].copy()\n        seg2 = new_solution[seg2_start:seg2_start+seg_length].copy()\n\n        new_solution[seg1_start:seg1_start+seg_length] = seg2\n        new_solution[seg2_start:seg2_start+seg_length] = seg1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest dominance count (number of solutions it dominates) and applies a hybrid local search combining segment rotation and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance counts\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select solution with highest dominance count\n    selected_idx = dominance_counts.index(max(dominance_counts))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n-segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9308962074873535,
            2.2000091671943665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance counts\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select solution with highest dominance count\n    selected_idx = dominance_counts.index(max(dominance_counts))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n-segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This heuristic function selects a solution from the archive based on objective diversity, then applies a novel combination of node insertion and edge inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Randomly select a node and insert it in a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Invert a random segment of the tour\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7575135910777148,
            2.3148945569992065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Randomly select a node and insert it in a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Invert a random segment of the tour\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest improvement potential estimated by combining objective values and local neighborhood analysis, then applies a hybrid local search combining node reinsertion with adaptive segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Estimate improvement potential using objective values and local neighborhood\n        potential = obj1 * obj2  # Simple heuristic for potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n-1)\n    start = random.randint(0, n-segment_length)\n    end = start + segment_length - 1\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, segment_length-1)\n    rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated\n\n    # Step 2: Node reinsertion with distance awareness\n    remove_pos = random.randint(0, n-1)\n    node = new_solution[remove_pos]\n    new_solution = np.delete(new_solution, remove_pos)\n    # Find insertion position based on both distance matrices\n    min_cost = float('inf')\n    best_pos = 0\n    for pos in range(n-1):\n        if pos == remove_pos:\n            continue\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos]\n        cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9450976306260634,
            1.7667304277420044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Estimate improvement potential using objective values and local neighborhood\n        potential = obj1 * obj2  # Simple heuristic for potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n-1)\n    start = random.randint(0, n-segment_length)\n    end = start + segment_length - 1\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, segment_length-1)\n    rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated\n\n    # Step 2: Node reinsertion with distance awareness\n    remove_pos = random.randint(0, n-1)\n    node = new_solution[remove_pos]\n    new_solution = np.delete(new_solution, remove_pos)\n    # Find insertion position based on both distance matrices\n    min_cost = float('inf')\n    best_pos = 0\n    for pos in range(n-1):\n        if pos == remove_pos:\n            continue\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos]\n        cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel path inversion and node swap operator to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and dominance\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = obj1 * 0.7 + obj2 * 0.3  # Weighted sum of objectives\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: Path inversion and node swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two nodes with high distance in both spaces\n    max_dist = -1\n    swap_i, swap_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            total_dist = dist1 + dist2\n            if total_dist > max_dist:\n                max_dist = total_dist\n                swap_i, swap_j = i, j\n    new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n",
        "score": [
            -0.9895297640488484,
            5.556464374065399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and dominance\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = obj1 * 0.7 + obj2 * 0.3  # Weighted sum of objectives\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: Path inversion and node swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two nodes with high distance in both spaces\n    max_dist = -1\n    swap_i, swap_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            total_dist = dist1 + dist2\n            if total_dist > max_dist:\n                max_dist = total_dist\n                swap_i, swap_j = i, j\n    new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    selected_idx = 0\n    min_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining weighted objectives and dominance rank\n        score = 0.7 * obj1 + 0.3 * obj2  # Weighted sum\n        if score < min_score:\n            min_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7626655839862457,
            1.7526702880859375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance rank\n    selected_idx = 0\n    min_score = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining weighted objectives and dominance rank\n        score = 0.7 * obj1 + 0.3 * obj2  # Weighted sum\n        if score < min_score:\n            min_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives and applies a hybrid local search combining segment inversion and crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted sum of objectives\n    selected_idx = 0\n    min_weighted_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted_sum = 0.7 * obj1 + 0.3 * obj2  # Weighted sum of objectives\n        if weighted_sum < min_weighted_sum:\n            min_weighted_sum = weighted_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + crossover\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform crossover with another random solution\n    if len(archive) > 1:\n        other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n        crossover_point = random.randint(1, n-1)\n        new_solution[crossover_point:] = other_sol[crossover_point:]\n\n    return new_solution\n\n",
        "score": [
            -0.6691083510484157,
            1.2276945114135742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted sum of objectives\n    selected_idx = 0\n    min_weighted_sum = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted_sum = 0.7 * obj1 + 0.3 * obj2  # Weighted sum of objectives\n        if weighted_sum < min_weighted_sum:\n            min_weighted_sum = weighted_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + crossover\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform crossover with another random solution\n    if len(archive) > 1:\n        other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n        crossover_point = random.randint(1, n-1)\n        new_solution[crossover_point:] = other_sol[crossover_point:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This new algorithm selects a solution from the archive based on the smallest product of normalized objective values, then applies a hybrid local search combining edge swapping and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with smallest product\n    min_product = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product < min_product:\n            min_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random edges\n    i1, i2 = random.sample(range(n), 2)\n    new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    # Step 2: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1]\n    k = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[k:], segment[:k]])\n\n    return new_solution\n\n",
        "score": [
            -0.6569052879408901,
            2.2327865958213806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with smallest product\n    min_product = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product < min_product:\n            min_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random edges\n    i1, i2 = random.sample(range(n), 2)\n    new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    # Step 2: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1]\n    k = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[k:], segment[:k]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined improvement potential in both objective spaces, then applies a novel \"objective-aware segment inversion\" operator that reverses segments while considering both distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential as inverse of combined objectives\n        potential = 1.0 / (obj1 + obj2 + 1e-8)  # Avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel objective-aware segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Select segment to invert\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n\n    # Calculate segment cost before inversion\n    def segment_cost(sol, start, end):\n        cost1 = distance_matrix_1[sol[start], sol[(start+1)%n]]\n        cost2 = distance_matrix_2[sol[start], sol[(start+1)%n]]\n        for i in range(start+1, end):\n            cost1 += distance_matrix_1[sol[i], sol[i+1]]\n            cost2 += distance_matrix_2[sol[i], sol[i+1]]\n        cost1 += distance_matrix_1[sol[end], sol[(end+1)%n]]\n        cost2 += distance_matrix_2[sol[end], sol[(end+1)%n]]\n        return cost1, cost2\n\n    old_cost1, old_cost2 = segment_cost(new_solution, start, end)\n\n    # Invert the segment\n    inverted_segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Calculate segment cost after inversion\n    new_cost1, new_cost2 = segment_cost(new_solution, start, end)\n\n    # Only accept if at least one objective improves\n    if not (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n        # Revert if no improvement\n        new_solution[start:end+1] = inverted_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6164570478087649,
            1.4439452290534973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential as inverse of combined objectives\n        potential = 1.0 / (obj1 + obj2 + 1e-8)  # Avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel objective-aware segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Select segment to invert\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n\n    # Calculate segment cost before inversion\n    def segment_cost(sol, start, end):\n        cost1 = distance_matrix_1[sol[start], sol[(start+1)%n]]\n        cost2 = distance_matrix_2[sol[start], sol[(start+1)%n]]\n        for i in range(start+1, end):\n            cost1 += distance_matrix_1[sol[i], sol[i+1]]\n            cost2 += distance_matrix_2[sol[i], sol[i+1]]\n        cost1 += distance_matrix_1[sol[end], sol[(end+1)%n]]\n        cost2 += distance_matrix_2[sol[end], sol[(end+1)%n]]\n        return cost1, cost2\n\n    old_cost1, old_cost2 = segment_cost(new_solution, start, end)\n\n    # Invert the segment\n    inverted_segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Calculate segment cost after inversion\n    new_cost1, new_cost2 = segment_cost(new_solution, start, end)\n\n    # Only accept if at least one objective improves\n    if not (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n        # Revert if no improvement\n        new_solution[start:end+1] = inverted_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with high diversity in the objective space, then applies a novel local search strategy combining path inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on objective diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: path inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.3126847592691246,
            2.2854636907577515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on objective diversity\n    selected_idx = random.randint(0, len(archive)-1)\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: path inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment inversion and double-bridge move to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a double-bridge move\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b:c+1],\n        new_solution[a:b],\n        new_solution[c+1:d+1],\n        new_solution[d+1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.7908299272750907,
            2.5822957158088684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a double-bridge move\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b:c+1],\n        new_solution[a:b],\n        new_solution[c+1:d+1],\n        new_solution[d+1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of exponentially weighted objective values, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Exponentially weighted objective selection\n    max_weighted = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        weighted_sum = np.exp(norm_obj1) + np.exp(norm_obj2)\n        if weighted_sum > max_weighted:\n            max_weighted = weighted_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with adaptive size\n    segment_size = min(random.randint(2, 5), n-1)\n    start = random.randint(0, n-segment_size)\n    end = start + segment_size - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Insert a random edge between two non-adjacent nodes\n    if n > 3:\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if j - i > 1:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    return new_solution\n\n",
        "score": [
            -1.009470472305565,
            3.136814057826996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Exponentially weighted objective selection\n    max_weighted = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        weighted_sum = np.exp(norm_obj1) + np.exp(norm_obj2)\n        if weighted_sum > max_weighted:\n            max_weighted = weighted_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with adaptive size\n    segment_size = min(random.randint(2, 5), n-1)\n    start = random.randint(0, n-segment_size)\n    end = start + segment_size - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Insert a random edge between two non-adjacent nodes\n    if n > 3:\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if j - i > 1:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel local search combining edge reversal and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and edge reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n\n    # Invert the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Reverse a random edge\n    i = random.randint(0, n-2)\n    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9237966070694845,
            2.261626124382019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and edge reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n\n    # Invert the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Reverse a random edge\n    i = random.randint(0, n-2)\n    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining edge exchange and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: Exchange two edges\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, min(i+3, n-1))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Rotate a segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+2, min(start+4, n-1))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9008628737990854,
            2.5030691027641296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: Exchange two edges\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, min(i+3, n-1))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Rotate a segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+2, min(start+4, n-1))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment rotation and node swapping with a distance-aware heuristic to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    k = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Step 2: Distance-aware node swap\n    i, j = random.sample(range(n), 2)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate potential improvement in both objectives\n    delta_obj1 = (distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_1[node_j, new_solution[(j-1)%n]] + distance_matrix_1[node_i, new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[(i-1)%n], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[(j-1)%n], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n    delta_obj2 = (distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_2[node_j, new_solution[(j-1)%n]] + distance_matrix_2[node_i, new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[(i-1)%n], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[(j-1)%n], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n    # Only perform swap if it improves both objectives\n    if delta_obj1 < 0 and delta_obj2 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9096208717669718,
            2.4805012941360474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    k = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Step 2: Distance-aware node swap\n    i, j = random.sample(range(n), 2)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate potential improvement in both objectives\n    delta_obj1 = (distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_1[node_j, new_solution[(j-1)%n]] + distance_matrix_1[node_i, new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[(i-1)%n], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[(j-1)%n], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n    delta_obj2 = (distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_2[node_j, new_solution[(j-1)%n]] + distance_matrix_2[node_i, new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[(i-1)%n], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[(j-1)%n], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n    # Only perform swap if it improves both objectives\n    if delta_obj1 < 0 and delta_obj2 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining node swapping and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8762927669597761,
            1.944438397884369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining dominance rank and objective-space diversity, then applies a segment inversion and node swap local search to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: dominance rank + objective diversity\n    scores = []\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Dominance rank (simplified)\n        rank = sum(1 for (_, (o1, o2)) in archive if o1 < obj1 and o2 < obj2)\n        # Objective diversity (normalized)\n        diversity = (obj1 - obj2) ** 2\n        scores.append((rank, diversity))\n\n    # Select solution with best hybrid score\n    selected_idx = min(range(len(scores)), key=lambda i: (scores[i][0], -scores[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node swap\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Swap two non-adjacent nodes\n    i, j = random.sample(range(n), 2)\n    while abs(i-j) == 1 or i == j:\n        i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4487375413793081,
            1.9336237907409668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: dominance rank + objective diversity\n    scores = []\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Dominance rank (simplified)\n        rank = sum(1 for (_, (o1, o2)) in archive if o1 < obj1 and o2 < obj2)\n        # Objective diversity (normalized)\n        diversity = (obj1 - obj2) ** 2\n        scores.append((rank, diversity))\n\n    # Select solution with best hybrid score\n    selected_idx = min(range(len(scores)), key=lambda i: (scores[i][0], -scores[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node swap\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+4, n-1))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Swap two non-adjacent nodes\n    i, j = random.sample(range(n), 2)\n    while abs(i-j) == 1 or i == j:\n        i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining edge reinsertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Edge reinsertion\n    pos1 = random.randint(0, n-1)\n    pos2 = random.randint(0, n-1)\n    if pos1 != pos2:\n        node = new_solution[pos1]\n        new_solution = np.delete(new_solution, pos1)\n        new_solution = np.insert(new_solution, pos2, node)\n\n    # Step 2: Segment rotation\n    if n > 3:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+2, n-1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9007305276170043,
            2.1148386001586914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Edge reinsertion\n    pos1 = random.randint(0, n-1)\n    pos2 = random.randint(0, n-1)\n    if pos1 != pos2:\n        node = new_solution[pos1]\n        new_solution = np.delete(new_solution, pos1)\n        new_solution = np.insert(new_solution, pos2, node)\n\n    # Step 2: Segment rotation\n    if n > 3:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+2, n-1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining cyclic permutation and node swapping with a probability-based selection mechanism to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Cyclic permutation of a random segment\n    start = random.randint(0, n-3)\n    length = random.randint(2, min(5, n-start-1))\n    segment = new_solution[start:start+length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+length] = rotated_segment\n\n    # Step 2: Node swapping with probability\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7830537092538843,
            2.018782079219818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Cyclic permutation of a random segment\n    start = random.randint(0, n-3)\n    length = random.randint(2, min(5, n-start-1))\n    segment = new_solution[start:start+length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+length] = rotated_segment\n\n    # Step 2: Node swapping with probability\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution from the archive based on its Pareto dominance and applies a novel hybrid local search combining 3-opt and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise pick randomly\n    non_dominated = [sol for sol, (obj1, obj2) in archive if not any(\n        (obj1 > o1 and obj2 > o2) for _, (o1, o2) in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment reversal\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k > j else new_solution[:k]\n\n    # Apply 3-opt-like operation\n    new_solution = np.concatenate([\n        new_solution[:i], segment2, segment1, segment3\n    ])\n\n    # Random segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8123144962393753,
            1.9652236104011536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise pick randomly\n    non_dominated = [sol for sol, (obj1, obj2) in archive if not any(\n        (obj1 > o1 and obj2 > o2) for _, (o1, o2) in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment reversal\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k > j else new_solution[:k]\n\n    # Apply 3-opt-like operation\n    new_solution = np.concatenate([\n        new_solution[:i], segment2, segment1, segment3\n    ])\n\n    # Random segment reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined improvement potential in both objective spaces, then applies a novel \"double-bridge\" local search that reconnects two randomly selected non-overlapping segments of the tour, ensuring feasibility while potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Double-bridge local search\n    # Select two non-overlapping segments\n    a = random.randint(0, n-4)\n    b = random.randint(a+2, n-2)\n    c = random.randint(b+1, n-1)\n\n    # Reconnect segments in a bridge pattern\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    remaining = np.concatenate([new_solution[:a], new_solution[c:]])\n\n    # Create new order: remaining -> segment2 -> segment1\n    new_solution = np.concatenate([remaining, segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.9843207839217221,
            1.9454392790794373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Double-bridge local search\n    # Select two non-overlapping segments\n    a = random.randint(0, n-4)\n    b = random.randint(a+2, n-2)\n    c = random.randint(b+1, n-1)\n\n    # Reconnect segments in a bridge pattern\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    remaining = np.concatenate([new_solution[:a], new_solution[c:]])\n\n    # Create new order: remaining -> segment2 -> segment1\n    new_solution = np.concatenate([remaining, segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes\n    pos1, pos2 = random.sample(range(n), 2)\n    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.932963188115502,
            1.9907987713813782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes\n    pos1, pos2 = random.sample(range(n), 2)\n    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.987574864366321,
            2.1550116539001465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal, node swapping, and edge crossing to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Cross two edges by selecting two random non-adjacent nodes and swapping their positions\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        while abs(a - b) == 1 or abs(a - b) == n - 1:\n            a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.840604002140521,
            1.5750610828399658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Cross two edges by selecting two random non-adjacent nodes and swapping their positions\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        while abs(a - b) == 1 or abs(a - b) == n - 1:\n            a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    pos1, pos2 = random.sample(range(n), 2)\n    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.9066328949421241,
            2.000194549560547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    pos1, pos2 = random.sample(range(n), 2)\n    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest ratio of normalized objective values, then applies a hybrid local search combining segment rotation and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest ratio\n    max_ratio = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        if norm_obj2 > 0:\n            current_ratio = norm_obj1 / norm_obj2\n            if current_ratio > max_ratio:\n                max_ratio = current_ratio\n                selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6828711872960745,
            1.823443353176117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest ratio\n    max_ratio = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        if norm_obj2 > 0:\n            current_ratio = norm_obj1 / norm_obj2\n            if current_ratio > max_ratio:\n                max_ratio = current_ratio\n                selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This heuristic function selects a solution with high crowding distance and applies a novel local search that combines segment inversion and node insertion, prioritizing edges with high potential for improvement in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    segment = segment[::-1]  # Invert the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Insert the inverted segment at a new position\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.8307408465220723,
            0.27319926023483276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion and node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    segment = segment[::-1]  # Invert the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Insert the inverted segment at a new position\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with high crowding distance and applies a novel local search that combines segment inversion and node reinsertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node reinsertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    segment = segment[::-1]  # Invert the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node reinsertion\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9782170633636509,
            1.3197275400161743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node reinsertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    segment = segment[::-1]  # Invert the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Random node reinsertion\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and dominance, then applies a hybrid local search combining node insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives\n    max_score = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives (simplified)\n        norm_obj1 = obj1 / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj2 / (distance_matrix_2.max() * len(sol))\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: node insertion + segment reversal\n    # Step 1: Select a random node and insert it in a different position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9378625543260395,
            4.005918741226196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives\n    max_score = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives (simplified)\n        norm_obj1 = obj1 / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj2 / (distance_matrix_2.max() * len(sol))\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: node insertion + segment reversal\n    # Step 1: Select a random node and insert it in a different position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment rotation and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8801492866717198,
            1.3216682076454163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    node1 = random.randint(0, n-1)\n    node2 = random.randint(0, n-1)\n    if node1 != node2:\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n",
        "score": [
            -0.8729173187759266,
            1.2727519869804382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    node1 = random.randint(0, n-1)\n    node2 = random.randint(0, n-1)\n    if node1 != node2:\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines path inversion and node sequence shuffling to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[(obj1 + obj2) * (i + 1) for i, (_, (obj1, obj2)) in enumerate(archive)])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: path inversion + node sequence shuffling\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Shuffle a random subsequence of nodes\n    shuffle_start = random.randint(0, n-3)\n    shuffle_end = random.randint(shuffle_start+1, min(shuffle_start+4, n-1))\n    subsequence = new_solution[shuffle_start:shuffle_end+1]\n    np.random.shuffle(subsequence)\n    new_solution[shuffle_start:shuffle_end+1] = subsequence\n\n    return new_solution\n\n",
        "score": [
            -0.7170132268069972,
            1.13175630569458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[(obj1 + obj2) * (i + 1) for i, (_, (obj1, obj2)) in enumerate(archive)])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: path inversion + node sequence shuffling\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Shuffle a random subsequence of nodes\n    shuffle_start = random.randint(0, n-3)\n    shuffle_end = random.randint(shuffle_start+1, min(shuffle_start+4, n-1))\n    subsequence = new_solution[shuffle_start:shuffle_end+1]\n    np.random.shuffle(subsequence)\n    new_solution[shuffle_start:shuffle_end+1] = subsequence\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining node relinking and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Node relinking - select two random nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment inversion - invert a random segment of length 3\n    start = random.randint(0, n-3)\n    end = start + 2\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9681250627584013,
            1.259246587753296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Node relinking - select two random nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment inversion - invert a random segment of length 3\n    start = random.randint(0, n-3)\n    end = start + 2\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objectives and dominance, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objectives and dominance\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted score combining objectives and dominance\n        score = 0.7 * obj1 + 0.3 * obj2 - (obj1 * obj2) * 0.1  # Adjust weights as needed\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6362149487348954,
            1.2213996052742004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objectives and dominance\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted score combining objectives and dominance\n        score = 0.7 * obj1 + 0.3 * obj2 - (obj1 * obj2) * 0.1  # Adjust weights as needed\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Simplified crowding distance\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]  # Invert the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], inverted_segment, remaining[insert_pos:]])\n\n    # Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.9663987854006644,
            0.14780598878860474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Simplified crowding distance\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]  # Invert the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], inverted_segment, remaining[insert_pos:]])\n\n    # Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance\n    selected_idx = 0\n    min_weighted = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted = 0.7 * obj1 + 0.3 * obj2\n        if weighted < min_weighted:\n            min_weighted = weighted\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]  # Invert the segment\n\n    # Insert a randomly selected node elsewhere\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_insert], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7914248878619297,
            0.14366215467453003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance\n    selected_idx = 0\n    min_weighted = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted = 0.7 * obj1 + 0.3 * obj2\n        if weighted < min_weighted:\n            min_weighted = weighted\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]  # Invert the segment\n\n    # Insert a randomly selected node elsewhere\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_insert], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This heuristic function selects a solution from the archive based on a novel combination of objective values and solution quality metrics, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a novel metric combining objective values and solution quality\n    selected_idx = 0\n    best_metric = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a novel metric combining objective values and solution quality\n        metric = (obj1 + obj2) / (1 + sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))))\n        if metric > best_metric:\n            best_metric = metric\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Select a random node and insert it at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9554071091071868,
            2.327211081981659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a novel metric combining objective values and solution quality\n    selected_idx = 0\n    best_metric = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a novel metric combining objective values and solution quality\n        metric = (obj1 + obj2) / (1 + sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))))\n        if metric > best_metric:\n            best_metric = metric\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + node insertion\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Select a random node and insert it at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance rank and applies a novel local search combining partial path reversal and node insertion to generate a feasible neighbor solution, ensuring no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest dominance rank (simplified)\n    selected_idx = 0\n    min_rank = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        rank = obj1 + obj2  # Placeholder for actual dominance rank calculation\n        if rank < min_rank:\n            min_rank = rank\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment of the tour\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node from another position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5464255308792374,
            1.0356412529945374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest dominance rank (simplified)\n    selected_idx = 0\n    min_rank = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        rank = obj1 + obj2  # Placeholder for actual dominance rank calculation\n        if rank < min_rank:\n            min_rank = rank\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment of the tour\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a node from another position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This heuristic function selects a solution from the archive by prioritizing those with high crowding distance and applies a novel local search combining segment inversion and insertion, guided by both objective spaces' distance matrices to ensure balance in improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert the inverted segment at a new position guided by distance matrices\n    segment_length = len(segment)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n - segment_length + 1):\n        if i >= start and i <= end:\n            continue  # Skip original position\n\n        # Calculate cost for inserting segment at position i\n        cost1 = 0\n        cost2 = 0\n\n        if i > 0:\n            cost1 += distance_matrix_1[new_solution[i-1], segment[0]]\n            cost2 += distance_matrix_2[new_solution[i-1], segment[0]]\n\n        if i + segment_length < n:\n            cost1 += distance_matrix_1[segment[-1], new_solution[i + segment_length]]\n            cost2 += distance_matrix_2[segment[-1], new_solution[i + segment_length]]\n\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        segment = new_solution[start:end+1]\n        remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9028685104776308,
            2.1293532848358154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert the inverted segment at a new position guided by distance matrices\n    segment_length = len(segment)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n - segment_length + 1):\n        if i >= start and i <= end:\n            continue  # Skip original position\n\n        # Calculate cost for inserting segment at position i\n        cost1 = 0\n        cost2 = 0\n\n        if i > 0:\n            cost1 += distance_matrix_1[new_solution[i-1], segment[0]]\n            cost2 += distance_matrix_2[new_solution[i-1], segment[0]]\n\n        if i + segment_length < n:\n            cost1 += distance_matrix_1[segment[-1], new_solution[i + segment_length]]\n            cost2 += distance_matrix_2[segment[-1], new_solution[i + segment_length]]\n\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        segment = new_solution[start:end+1]\n        remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This new algorithm selects a solution from the archive based on a composite score combining both objective values and their normalized differences, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on composite score\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalized difference between objectives\n        norm_diff = abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n        # Composite score combining both objectives and their normalized difference\n        score = (obj1 + obj2) * (1 - norm_diff)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a random position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n    # Remove duplicate (since we're inserting an existing node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.9130633760434852,
            1.796328604221344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on composite score\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalized difference between objectives\n        norm_diff = abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n        # Composite score combining both objectives and their normalized difference\n        score = (obj1 + obj2) * (1 - norm_diff)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Insert a random node at a random position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n    # Remove duplicate (since we're inserting an existing node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This heuristic function selects a solution from the archive using a combination of objective diversity and solution quality metrics, then applies a novel \"cross-space segment transfer\" local search that moves segments between the two objective spaces to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and quality\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity\n        score = (obj1 + obj2) / (abs(obj1 - obj2) + 1)  # Balance between sum and diversity\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Cross-space segment transfer\n    # Select a random segment from the solution\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n\n    # Calculate segment costs in both spaces\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    seg_cost1 += distance_matrix_1[segment[-1], segment[0]]  # Close the segment\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    seg_cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Find insertion point that improves both objectives\n    best_insert = -1\n    best_improvement = -float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting before position i\n        if i == 0:\n            prev_node = remaining[-1]\n            next_node = remaining[i]\n        elif i == len(remaining):\n            prev_node = remaining[i-1]\n            next_node = remaining[0]\n        else:\n            prev_node = remaining[i-1]\n            next_node = remaining[i]\n\n        # Calculate cost change in both spaces\n        cost_change1 = (distance_matrix_1[prev_node, segment[0]] +\n                        distance_matrix_1[segment[-1], next_node] -\n                        distance_matrix_1[prev_node, next_node])\n        cost_change2 = (distance_matrix_2[prev_node, segment[0]] +\n                        distance_matrix_2[segment[-1], next_node] -\n                        distance_matrix_2[prev_node, next_node])\n\n        # Calculate improvement score (combining both objectives)\n        improvement = (seg_cost1 + cost_change1) + (seg_cost2 + cost_change2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([remaining[:best_insert], segment, remaining[best_insert:]])\n\n    return new_solution\n\n",
        "score": [
            -0.902472394129967,
            2.3751925826072693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and quality\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity\n        score = (obj1 + obj2) / (abs(obj1 - obj2) + 1)  # Balance between sum and diversity\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Cross-space segment transfer\n    # Select a random segment from the solution\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n\n    # Calculate segment costs in both spaces\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    seg_cost1 += distance_matrix_1[segment[-1], segment[0]]  # Close the segment\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    seg_cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Find insertion point that improves both objectives\n    best_insert = -1\n    best_improvement = -float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting before position i\n        if i == 0:\n            prev_node = remaining[-1]\n            next_node = remaining[i]\n        elif i == len(remaining):\n            prev_node = remaining[i-1]\n            next_node = remaining[0]\n        else:\n            prev_node = remaining[i-1]\n            next_node = remaining[i]\n\n        # Calculate cost change in both spaces\n        cost_change1 = (distance_matrix_1[prev_node, segment[0]] +\n                        distance_matrix_1[segment[-1], next_node] -\n                        distance_matrix_1[prev_node, next_node])\n        cost_change2 = (distance_matrix_2[prev_node, segment[0]] +\n                        distance_matrix_2[segment[-1], next_node] -\n                        distance_matrix_2[prev_node, next_node])\n\n        # Calculate improvement score (combining both objectives)\n        improvement = (seg_cost1 + cost_change1) + (seg_cost2 + cost_change2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([remaining[:best_insert], segment, remaining[best_insert:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining node swapping with a novel segment inversion strategy that considers both distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of normalized objectives\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: node swapping with distance-aware segment inversion\n    # Step 1: Select nodes based on combined distance improvement\n    i, j = random.sample(range(n), 2)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate potential improvement in both objectives\n    prev_nodes = [new_solution[i-1], new_solution[(i+1)%n], new_solution[j-1], new_solution[(j+1)%n]]\n    new_nodes = [new_solution[i-1], new_solution[j], new_solution[(i+1)%n], new_solution[j-1], new_solution[(j+1)%n]]\n\n    # Calculate improvement in both objectives\n    improvement1 = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, prev_nodes[1]] +\n                    distance_matrix_1[prev_nodes[2], node_j] + distance_matrix_1[node_j, prev_nodes[3]]) - \\\n                   (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, prev_nodes[1]] +\n                    distance_matrix_1[prev_nodes[2], node_i] + distance_matrix_1[node_i, prev_nodes[3]])\n\n    improvement2 = (distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, prev_nodes[1]] +\n                    distance_matrix_2[prev_nodes[2], node_j] + distance_matrix_2[node_j, prev_nodes[3]]) - \\\n                   (distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, prev_nodes[1]] +\n                    distance_matrix_2[prev_nodes[2], node_i] + distance_matrix_2[node_i, prev_nodes[3]])\n\n    # Only swap if it improves at least one objective\n    if improvement1 < 0 or improvement2 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment inversion considering both distance matrices\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n\n    # Calculate potential improvement for the segment inversion\n    prev_segment = [new_solution[start-1], new_solution[end], new_solution[(end+1)%n], new_solution[start]]\n    inverted_segment = segment[::-1]\n    new_segment = [new_solution[start-1], inverted_segment[0], inverted_segment[-1], new_solution[(end+1)%n]]\n\n    improvement1 = (distance_matrix_1[prev_segment[0], prev_segment[1]] + distance_matrix_1[prev_segment[2], prev_segment[3]]) - \\\n                   (distance_matrix_1[new_segment[0], new_segment[1]] + distance_matrix_1[new_segment[2], new_segment[3]])\n\n    improvement2 = (distance_matrix_2[prev_segment[0], prev_segment[1]] + distance_matrix_2[prev_segment[2], prev_segment[3]]) - \\\n                   (distance_matrix_2[new_segment[0], new_segment[1]] + distance_matrix_2[new_segment[2], new_segment[3]])\n\n    # Only invert if it improves at least one objective\n    if improvement1 < 0 or improvement2 < 0:\n        new_solution[start:end+1] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8540480306205396,
            1.8239280581474304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of normalized objectives\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: node swapping with distance-aware segment inversion\n    # Step 1: Select nodes based on combined distance improvement\n    i, j = random.sample(range(n), 2)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate potential improvement in both objectives\n    prev_nodes = [new_solution[i-1], new_solution[(i+1)%n], new_solution[j-1], new_solution[(j+1)%n]]\n    new_nodes = [new_solution[i-1], new_solution[j], new_solution[(i+1)%n], new_solution[j-1], new_solution[(j+1)%n]]\n\n    # Calculate improvement in both objectives\n    improvement1 = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, prev_nodes[1]] +\n                    distance_matrix_1[prev_nodes[2], node_j] + distance_matrix_1[node_j, prev_nodes[3]]) - \\\n                   (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, prev_nodes[1]] +\n                    distance_matrix_1[prev_nodes[2], node_i] + distance_matrix_1[node_i, prev_nodes[3]])\n\n    improvement2 = (distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, prev_nodes[1]] +\n                    distance_matrix_2[prev_nodes[2], node_j] + distance_matrix_2[node_j, prev_nodes[3]]) - \\\n                   (distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, prev_nodes[1]] +\n                    distance_matrix_2[prev_nodes[2], node_i] + distance_matrix_2[node_i, prev_nodes[3]])\n\n    # Only swap if it improves at least one objective\n    if improvement1 < 0 or improvement2 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment inversion considering both distance matrices\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n\n    # Calculate potential improvement for the segment inversion\n    prev_segment = [new_solution[start-1], new_solution[end], new_solution[(end+1)%n], new_solution[start]]\n    inverted_segment = segment[::-1]\n    new_segment = [new_solution[start-1], inverted_segment[0], inverted_segment[-1], new_solution[(end+1)%n]]\n\n    improvement1 = (distance_matrix_1[prev_segment[0], prev_segment[1]] + distance_matrix_1[prev_segment[2], prev_segment[3]]) - \\\n                   (distance_matrix_1[new_segment[0], new_segment[1]] + distance_matrix_1[new_segment[2], new_segment[3]])\n\n    improvement2 = (distance_matrix_2[prev_segment[0], prev_segment[1]] + distance_matrix_2[prev_segment[2], prev_segment[3]]) - \\\n                   (distance_matrix_2[new_segment[0], new_segment[1]] + distance_matrix_2[new_segment[2], new_segment[3]])\n\n    # Only invert if it improves at least one objective\n    if improvement1 < 0 or improvement2 < 0:\n        new_solution[start:end+1] = inverted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node reinsertion and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (sum of objectives)\n    selected_idx = np.argmax([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: node reinsertion + path reversal\n    # Step 1: Remove a random node and reinsert it at a different position\n    remove_pos = random.randint(0, n-1)\n    node = new_solution[remove_pos]\n    remaining = np.delete(new_solution, remove_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment of the tour\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7842066955727505,
            1.5407459139823914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (sum of objectives)\n    selected_idx = np.argmax([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: node reinsertion + path reversal\n    # Step 1: Remove a random node and reinsert it at a different position\n    remove_pos = random.randint(0, n-1)\n    node = new_solution[remove_pos]\n    remaining = np.delete(new_solution, remove_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Reverse a random segment of the tour\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined distance in both objective spaces, then applies a novel segment inversion and node insertion strategy to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined distance\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9061884651167409,
            2.1571004390716553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined distance\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a different position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of raw objective values, then applies a hybrid local search combining node swapping and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of raw objectives\n    max_sum = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        current_sum = obj1 + obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    pos1, pos2 = random.sample(range(n), 2)\n    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Step 2: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9473738001097755,
            2.0219815969467163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of raw objectives\n    max_sum = -1\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        current_sum = obj1 + obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    pos1, pos2 = random.sample(range(n), 2)\n    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Step 2: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This heuristic selects a solution from the archive using a combination of objective dominance and diversity, then applies a novel 3-segment relocation and crossover-based local search to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining dominance and diversity\n        score = obj1 * obj2  # Placeholder for more sophisticated score\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select three non-overlapping segments\n    points = sorted(random.sample(range(n), 3))\n    a, b, c = points[0], points[1], points[2]\n\n    # Step 2: Relocate the middle segment between the first and last segments\n    segment = new_solution[b:c+1]\n    remaining = np.concatenate([new_solution[:b], new_solution[c+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Perform crossover-like exchange between segments\n    if a > 0 and c < n-1:\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.946951230939813,
            1.7269701957702637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining dominance and diversity\n        score = obj1 * obj2  # Placeholder for more sophisticated score\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select three non-overlapping segments\n    points = sorted(random.sample(range(n), 3))\n    a, b, c = points[0], points[1], points[2]\n\n    # Step 2: Relocate the middle segment between the first and last segments\n    segment = new_solution[b:c+1]\n    remaining = np.concatenate([new_solution[:b], new_solution[c+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Perform crossover-like exchange between segments\n    if a > 0 and c < n-1:\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node reinsertion with a probability-based approach to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability 0.7\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+3, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node with probability 0.5\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9794692869953987,
            1.7384501099586487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability 0.7\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+3, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node with probability 0.5\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high diversity in both objectives, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity in objectives\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node elsewhere\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.42938094729913,
            1.686316430568695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity in objectives\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node elsewhere\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of dominance rank and objective space diversity, then applies a novel hybrid local search combining segment inversion and cross-exchange operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on dominance rank and objective space diversity\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score calculation combining dominance and diversity\n        score = obj1 * 0.7 + obj2 * 0.3 + (obj1 + obj2) * 0.2\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + cross-exchange\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-4)\n    end = random.randint(start+2, min(start+4, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Perform a cross-exchange between two random edges\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    k = random.randint(0, n-2)\n    l = random.randint(k+1, n-1)\n\n    # Ensure cross-exchange maintains feasibility\n    if i != k and j != l:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7856753835095995,
            1.6425517797470093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on dominance rank and objective space diversity\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score calculation combining dominance and diversity\n        score = obj1 * 0.7 + obj2 * 0.3 + (obj1 + obj2) * 0.2\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + cross-exchange\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-4)\n    end = random.randint(start+2, min(start+4, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Perform a cross-exchange between two random edges\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    k = random.randint(0, n-2)\n    l = random.randint(k+1, n-1)\n\n    # Ensure cross-exchange maintains feasibility\n    if i != k and j != l:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This new algorithm selects a solution from the archive based on the minimum normalized objective product, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with minimum product\n    min_product = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product < min_product:\n            min_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7266469638168866,
            1.4998186230659485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with minimum product\n    min_product = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product < min_product:\n            min_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This heuristic function selects a solution from the archive based on the worst-performing objective in each space, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst objective in either space\n    selected_idx = 0\n    max_worst = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        worst_obj = max(obj1, obj2)\n        if worst_obj > max_worst:\n            max_worst = worst_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal and node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Remove duplicate (since we inserted a node that already exists)\n    mask = np.ones(len(new_solution), dtype=bool)\n    mask[np.unique(new_solution, return_index=True)[1]] = False\n    new_solution = new_solution[~mask]\n\n    return new_solution\n\n",
        "score": [
            -0.8626590359245733,
            1.4916270971298218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst objective in either space\n    selected_idx = 0\n    max_worst = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        worst_obj = max(obj1, obj2)\n        if worst_obj > max_worst:\n            max_worst = worst_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment reversal and node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node at a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Remove duplicate (since we inserted a node that already exists)\n    mask = np.ones(len(new_solution), dtype=bool)\n    mask[np.unique(new_solution, return_index=True)[1]] = False\n    new_solution = new_solution[~mask]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This heuristic function selects a solution from the archive based on the balance between its objectives, then applies a novel local search combining cycle reversal and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = 0\n    min_diff = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diff = abs(obj1 - obj2)\n        if diff < min_diff:\n            min_diff = diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Perform a cycle reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7924275413509645,
            1.4381985068321228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_idx = 0\n    min_diff = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diff = abs(obj1 - obj2)\n        if diff < min_diff:\n            min_diff = diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Perform a cycle reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This heuristic function selects a solution from the archive with the best combined objective value, then applies a novel local search combining node reinsertion with a probabilistic edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    selected_idx = np.argmin([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a node and reinsert it at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Probabilistically reverse a segment of the tour\n    if random.random() < 0.5:  # 50% chance to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8201164734459738,
            2.0851762890815735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    selected_idx = np.argmin([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Randomly select a node and reinsert it at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    # Step 2: Probabilistically reverse a segment of the tour\n    if random.random() < 0.5:  # 50% chance to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment rotation and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.roll(segment, rotation)\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.999601235848599,
            2.5341126918792725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.roll(segment, rotation)\n\n    # Step 2: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This heuristic function selects a solution from the archive based on a novel combination of objective values and diversity metrics, then applies a unique local search operator that combines segment inversion with adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[(obj1 + obj2) * (1 + np.std(sol)) for sol, (obj1, obj2) in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion with adaptive edge insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1][::-1]\n\n    # Calculate potential insertion points based on both distance matrices\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insertion_scores = []\n\n    for i in range(len(remaining)):\n        if i == 0:\n            prev_node = remaining[-1]\n        else:\n            prev_node = remaining[i-1]\n\n        next_node = remaining[i]\n        segment_start = segment[0]\n        segment_end = segment[-1]\n\n        # Calculate insertion score based on both objectives\n        cost1 = distance_matrix_1[prev_node, segment_start] + distance_matrix_1[segment_end, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, segment_start] + distance_matrix_2[segment_end, next_node] - distance_matrix_2[prev_node, next_node]\n        insertion_scores.append(cost1 + cost2)\n\n    if insertion_scores:\n        best_insert_pos = insertion_scores.index(min(insertion_scores))\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8611717882150071,
            4.257045209407806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[(obj1 + obj2) * (1 + np.std(sol)) for sol, (obj1, obj2) in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion with adaptive edge insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1][::-1]\n\n    # Calculate potential insertion points based on both distance matrices\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insertion_scores = []\n\n    for i in range(len(remaining)):\n        if i == 0:\n            prev_node = remaining[-1]\n        else:\n            prev_node = remaining[i-1]\n\n        next_node = remaining[i]\n        segment_start = segment[0]\n        segment_end = segment[-1]\n\n        # Calculate insertion score based on both objectives\n        cost1 = distance_matrix_1[prev_node, segment_start] + distance_matrix_1[segment_end, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, segment_start] + distance_matrix_2[segment_end, next_node] - distance_matrix_2[prev_node, next_node]\n        insertion_scores.append(cost1 + cost2)\n\n    if insertion_scores:\n        best_insert_pos = insertion_scores.index(min(insertion_scores))\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This heuristic function selects a solution from the archive using a combination of objective dominance and diversity, then applies a novel local search that combines segment reversal and node insertion while ensuring feasibility by carefully validating all operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good diversity in objectives\n    selected_idx = 0\n    min_variance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        variance = abs(obj1 - obj2)\n        if variance < min_variance:\n            min_variance = variance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Segment reversal with validation\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_segment = segment[::-1]  # Reverse the segment\n    new_solution[start:end+1] = new_segment\n\n    # Node insertion with validation\n    if n > 3:\n        node = new_solution[random.randint(0, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9402230235103795,
            2.3122476935386658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good diversity in objectives\n    selected_idx = 0\n    min_variance = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        variance = abs(obj1 - obj2)\n        if variance < min_variance:\n            min_variance = variance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Segment reversal with validation\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_segment = segment[::-1]  # Reverse the segment\n    new_solution[start:end+1] = new_segment\n\n    # Node insertion with validation\n    if n > 3:\n        node = new_solution[random.randint(0, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining node reordering with probabilistic edge deletions and insertions to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective and diversity\n    max_score = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        diversity = len(set(sol)) / len(sol)  # Measure of uniqueness in the tour\n        current_score = (norm_obj1 + norm_obj2) * diversity\n        if current_score > max_score:\n            max_score = current_score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: probabilistic node reordering and edge operations\n    # Step 1: Reorder a random segment with probability based on distance improvement\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n\n    # Calculate current and reversed segment distances\n    current_dist1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    current_dist2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n    reversed_segment = segment[::-1]\n    reversed_dist1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n    reversed_dist2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n    # Reverse with probability based on improvement\n    if (reversed_dist1 + reversed_dist2) < (current_dist1 + current_dist2):\n        new_solution[start:end+1] = reversed_segment\n\n    # Step 2: Probabilistically delete and reinsert edges\n    for _ in range(2):  # Perform 2 edge operations\n        if random.random() < 0.7:  # 70% chance for deletion/insertion\n            # Delete a random edge\n            i = random.randint(0, n-2)\n            node1, node2 = new_solution[i], new_solution[i+1]\n            new_solution = np.delete(new_solution, i+1)\n\n            # Reinsert the node at a random position\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node2)\n\n    return new_solution\n\n",
        "score": [
            -0.8929338963995798,
            4.050345480442047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective and diversity\n    max_score = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        diversity = len(set(sol)) / len(sol)  # Measure of uniqueness in the tour\n        current_score = (norm_obj1 + norm_obj2) * diversity\n        if current_score > max_score:\n            max_score = current_score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: probabilistic node reordering and edge operations\n    # Step 1: Reorder a random segment with probability based on distance improvement\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n\n    # Calculate current and reversed segment distances\n    current_dist1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    current_dist2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n    reversed_segment = segment[::-1]\n    reversed_dist1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n    reversed_dist2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n    # Reverse with probability based on improvement\n    if (reversed_dist1 + reversed_dist2) < (current_dist1 + current_dist2):\n        new_solution[start:end+1] = reversed_segment\n\n    # Step 2: Probabilistically delete and reinsert edges\n    for _ in range(2):  # Perform 2 edge operations\n        if random.random() < 0.7:  # 70% chance for deletion/insertion\n            # Delete a random edge\n            i = random.randint(0, n-2)\n            node1, node2 = new_solution[i], new_solution[i+1]\n            new_solution = np.delete(new_solution, i+1)\n\n            # Reinsert the node at a random position\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment rotation and edge reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of normalized objectives\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Reverse a random edge\n    i = random.randint(0, n-2)\n    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9263284470084133,
            2.4445629119873047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of normalized objectives\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Reverse a random edge\n    i = random.randint(0, n-2)\n    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining node swapping with a novel segment inversion and insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on a combination of objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining objectives and diversity\n        diversity = sum(abs(sol[j] - sol[(j+1)%len(sol)]) for j in range(len(sol)))\n        score = (obj1 + obj2) * diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: node swapping with segment inversion and insertion\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Select a random node and insert it at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Perform a node swap based on distance improvement\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6761446444281358,
            6.613674700260162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on a combination of objective values and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate score combining objectives and diversity\n        diversity = sum(abs(sol[j] - sol[(j+1)%len(sol)]) for j in range(len(sol)))\n        score = (obj1 + obj2) * diversity\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: node swapping with segment inversion and insertion\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Select a random node and insert it at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Perform a node swap based on distance improvement\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node relocation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8864255234553877,
            2.0655476450920105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance and crowding distance, then applies a hybrid local search combining node insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance and crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Perform a random node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8817788812841018,
            1.314557135105133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance and crowding distance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Perform a random node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This heuristic selects a solution from the archive based on its objective values, then applies a hybrid local search combining 3-opt and adaptive segment inversion to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (diversification)\n    selected_idx = np.argmax([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + adaptive segment inversion\n    # Step 1: 3-opt move (select 3 random edges and reconnect)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:] if a != 0 else new_solution[:a]\n\n    # Reconnect segments in different order\n    if random.random() > 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2])\n    else:\n        new_solution = np.concatenate([segment2, segment3, segment1])\n\n    # Step 2: Adaptive segment inversion\n    inv_length = min(5, n // 2)\n    start = random.randint(0, n - inv_length)\n    end = start + inv_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8778215208353465,
            0.24751579761505127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (diversification)\n    selected_idx = np.argmax([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + adaptive segment inversion\n    # Step 1: 3-opt move (select 3 random edges and reconnect)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:] if a != 0 else new_solution[:a]\n\n    # Reconnect segments in different order\n    if random.random() > 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2])\n    else:\n        new_solution = np.concatenate([segment2, segment3, segment1])\n\n    # Step 2: Adaptive segment inversion\n    inv_length = min(5, n // 2)\n    start = random.randint(0, n - inv_length)\n    end = start + inv_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This heuristic selects a solution with high dominance rank and applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank (lower objectives preferred)\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7976540376245793,
            1.43806791305542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank (lower objectives preferred)\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel multi-segment relocation and inversion operator to generate a neighbor solution while ensuring feasibility by carefully maintaining the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Multi-segment relocation and inversion\n    # Select two non-overlapping segments\n    split1 = random.randint(1, n-3)\n    split2 = random.randint(split1+1, n-2)\n\n    # Extract segments\n    seg1 = new_solution[:split1]\n    seg2 = new_solution[split1:split2]\n    seg3 = new_solution[split2:]\n\n    # Invert the middle segment\n    seg2 = seg2[::-1]\n\n    # Recombine with random order\n    segments = [seg1, seg2, seg3]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            -0.7978213206111253,
            1.2290900349617004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Multi-segment relocation and inversion\n    # Select two non-overlapping segments\n    split1 = random.randint(1, n-3)\n    split2 = random.randint(split1+1, n-2)\n\n    # Extract segments\n    seg1 = new_solution[:split1]\n    seg2 = new_solution[split1:split2]\n    seg3 = new_solution[split2:]\n\n    # Invert the middle segment\n    seg2 = seg2[::-1]\n\n    # Recombine with random order\n    segments = [seg1, seg2, seg3]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and solution diversity, then applies a hybrid local search combining segment inversion and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted combination of objectives and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objective values and diversity\n        score = (obj1 + obj2) * 0.7 + (i % 5) * 0.3  # Simple diversity metric\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node reinsertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9219412727156657,
            1.275270938873291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted combination of objectives and diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate a score combining objective values and diversity\n        score = (obj1 + obj2) * 0.7 + (i % 5) * 0.3  # Simple diversity metric\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node reinsertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a random node\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0249071831558156,
            1.9401333332061768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0249071831558156,
            1.9401333332061768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search combining segment inversion and k-opt moves to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate diversity score (simplified)\n        diversity = obj1 * 0.3 + obj2 * 0.7  # Weighted sum\n        # Calculate dominance score\n        dominated = sum(1 for _, (o1, o2) in archive if o1 < obj1 and o2 < obj2)\n        score = diversity - dominated\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Novel local search: segment inversion + 3-opt\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7422637194814535,
            2.4841030836105347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate diversity score (simplified)\n        diversity = obj1 * 0.3 + obj2 * 0.7  # Weighted sum\n        # Calculate dominance score\n        dominated = sum(1 for _, (o1, o2) in archive if o1 < obj1 and o2 < obj2)\n        score = diversity - dominated\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Novel local search: segment inversion + 3-opt\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining node swapping and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1]\n    shift = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, shift)\n    new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9669696258437657,
            2.6884310245513916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    segment = new_solution[start:end+1]\n    shift = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, shift)\n    new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining node swapping and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Perform multiple node swaps\n    num_swaps = random.randint(1, min(3, n // 2))\n    for _ in range(num_swaps):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8973975179868334,
            1.7700315713882446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Perform multiple node swaps\n    num_swaps = random.randint(1, min(3, n // 2))\n    for _ in range(num_swaps):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a novel local search combining segment rotation, node relocation, and objective-aware edge swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    k = random.randint(1, n-1)\n    new_solution = np.roll(new_solution, k)\n\n    # Step 2: Relocate a random node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Objective-aware edge swap\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        current_edges = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]],\n                         distance_matrix_1[new_solution[j], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[k]])\n        swapped_edges = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[i], new_solution[k]],\n                          distance_matrix_1[new_solution[k], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[j]])\n        if sum(swapped_edges) < sum(current_edges):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.6845462117845131,
            3.2428608536720276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    k = random.randint(1, n-1)\n    new_solution = np.roll(new_solution, k)\n\n    # Step 2: Relocate a random node\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Objective-aware edge swap\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        current_edges = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]],\n                         distance_matrix_1[new_solution[j], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[k]])\n        swapped_edges = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[i], new_solution[k]],\n                          distance_matrix_1[new_solution[k], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[j]])\n        if sum(swapped_edges) < sum(current_edges):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search operator that combines segment inversion and position-based swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + position-based swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected positions\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9457771685249527,
            2.1364397406578064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + position-based swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected positions\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining node swapping and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random edge\n    k = random.randint(0, n-2)\n    new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8460798273300115,
            2.436580181121826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random edge\n    k = random.randint(0, n-2)\n    new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This heuristic function selects a solution from the archive using a hybrid scoring mechanism combining dominance rank and diversity metrics, then applies a novel local search combining segment inversion and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using hybrid scoring (dominance rank + diversity)\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Dominance rank (simplified)\n        dom_rank = sum(1 for other_sol, (other_obj1, other_obj2) in archive\n                      if (obj1 > other_obj1 and obj2 > other_obj2))\n        # Diversity metric (simplified)\n        diversity = obj1 * obj2  # Placeholder for actual diversity calculation\n        scores.append((dom_rank, diversity))\n\n    # Select solution with highest dominance rank and diversity\n    selected_idx = max(range(len(scores)), key=lambda i: (scores[i][0], scores[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8270959463104449,
            5.977932572364807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using hybrid scoring (dominance rank + diversity)\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Dominance rank (simplified)\n        dom_rank = sum(1 for other_sol, (other_obj1, other_obj2) in archive\n                      if (obj1 > other_obj1 and obj2 > other_obj2))\n        # Diversity metric (simplified)\n        diversity = obj1 * obj2  # Placeholder for actual diversity calculation\n        scores.append((dom_rank, diversity))\n\n    # Select solution with highest dominance rank and diversity\n    selected_idx = max(range(len(scores)), key=lambda i: (scores[i][0], scores[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining segment inversion and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of normalized objectives\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and compute weighted sum\n        norm_obj1 = obj1 / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj2 / (distance_matrix_2.max() * len(sol))\n        score = 0.6 * norm_obj1 + 0.4 * norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8981470917464023,
            5.528657615184784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of normalized objectives\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and compute weighted sum\n        norm_obj1 = obj1 / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj2 / (distance_matrix_2.max() * len(sol))\n        score = 0.6 * norm_obj1 + 0.4 * norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]\n    new_solution[start:end+1] = segment\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This heuristic function selects a promising solution from the archive based on high crowding distance and applies a novel local search strategy combining adaptive segment reversal and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Simplified crowding distance\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Guided edge insertion\n    candidates = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if j - i > 1:\n                candidates.append((i, j))\n\n    if candidates:\n        i, j = random.choice(candidates)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9198410347940276,
            1.8685003519058228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Simplified crowding distance\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment reversal\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Guided edge insertion\n    candidates = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if j - i > 1:\n                candidates.append((i, j))\n\n    if candidates:\n        i, j = random.choice(candidates)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This heuristic function selects a solution from the archive based on the combined improvement potential in both objective spaces, then applies a novel local search combining node insertion with a guided edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential improvement (simplified)\n        potential = (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]]) - (obj1 + obj2)\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: Node insertion with guided edge reversal\n    # Step 1: Remove a random node and insert it in a different position\n    remove_pos = random.randint(0, n-1)\n    node = new_solution[remove_pos]\n    remaining = np.concatenate([new_solution[:remove_pos], new_solution[remove_pos+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    # Step 2: Reverse a segment between two nodes with high distance savings\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        i, j = min(i, j), max(i, j)\n        segment = new_solution[i:j+1]\n        reverse_cost = (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_2[new_solution[i-1], segment[-1]] +\n                        distance_matrix_1[segment[0], new_solution[j+1]] + distance_matrix_2[segment[0], new_solution[j+1]]) if i > 0 and j < n-1 else 0\n        original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_2[new_solution[i-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[j+1]] + distance_matrix_2[segment[-1], new_solution[j+1]]) if i > 0 and j < n-1 else 0\n\n        if reverse_cost < original_cost:\n            new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6344107758008755,
            2.269901990890503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential improvement (simplified)\n        potential = (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]]) - (obj1 + obj2)\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: Node insertion with guided edge reversal\n    # Step 1: Remove a random node and insert it in a different position\n    remove_pos = random.randint(0, n-1)\n    node = new_solution[remove_pos]\n    remaining = np.concatenate([new_solution[:remove_pos], new_solution[remove_pos+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], [node], remaining[insert_pos:]])\n\n    # Step 2: Reverse a segment between two nodes with high distance savings\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        i, j = min(i, j), max(i, j)\n        segment = new_solution[i:j+1]\n        reverse_cost = (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_2[new_solution[i-1], segment[-1]] +\n                        distance_matrix_1[segment[0], new_solution[j+1]] + distance_matrix_2[segment[0], new_solution[j+1]]) if i > 0 and j < n-1 else 0\n        original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_2[new_solution[i-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[j+1]] + distance_matrix_2[segment[-1], new_solution[j+1]]) if i > 0 and j < n-1 else 0\n\n        if reverse_cost < original_cost:\n            new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment rotation, node swapping, and edge exchange with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive probability based on solution length\n    prob_rotate = min(0.8, 0.4 + 0.4 * (n / 100))\n    prob_swap = min(0.6, 0.3 + 0.3 * (n / 100))\n    prob_exchange = min(0.7, 0.4 + 0.3 * (n / 100))\n\n    # Step 1: Rotate a segment with adaptive probability\n    if random.random() < prob_rotate:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+10, n-1))\n        segment = new_solution[start:end+1]\n        shift = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two nodes with adaptive probability\n    if random.random() < prob_swap:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Exchange two edges with adaptive probability\n    if random.random() < prob_exchange:\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if j - i > 1:\n            k = random.randint(i+1, j-1)\n            new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9177962785137106,
            2.0689879655838013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive probability based on solution length\n    prob_rotate = min(0.8, 0.4 + 0.4 * (n / 100))\n    prob_swap = min(0.6, 0.3 + 0.3 * (n / 100))\n    prob_exchange = min(0.7, 0.4 + 0.3 * (n / 100))\n\n    # Step 1: Rotate a segment with adaptive probability\n    if random.random() < prob_rotate:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+10, n-1))\n        segment = new_solution[start:end+1]\n        shift = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap two nodes with adaptive probability\n    if random.random() < prob_swap:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Exchange two edges with adaptive probability\n    if random.random() < prob_exchange:\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if j - i > 1:\n            k = random.randint(i+1, j-1)\n            new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance count, then applies a hybrid local search combining 3-opt and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance count\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted score combining objectives and dominance (simplified)\n        dominance = sum(1 for (_, (o1, o2)) in archive if (o1 < obj1 and o2 < obj2))\n        score = - (0.7 * obj1 + 0.3 * obj2) + 0.5 * dominance\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 3:\n        # Hybrid local search: 3-opt + segment inversion\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n        # Perform 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7728242370951175,
            4.541785299777985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values and dominance count\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted score combining objectives and dominance (simplified)\n        dominance = sum(1 for (_, (o1, o2)) in archive if (o1 < obj1 and o2 < obj2))\n        score = - (0.7 * obj1 + 0.3 * obj2) + 0.5 * dominance\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 3:\n        # Hybrid local search: 3-opt + segment inversion\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n        # Perform 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining node swapping and segment rotation with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes with probability\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Rotate a segment with probability\n    if random.random() < 0.4:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        segment = new_solution[start:end+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[start:end+1] = np.roll(segment, rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.8955897579533241,
            1.9759583473205566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes with probability\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Rotate a segment with probability\n    if random.random() < 0.4:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        segment = new_solution[start:end+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[start:end+1] = np.roll(segment, rotation)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest sum of normalized objectives, then applies a hybrid local search combining segment rotation and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Flip edges with probability\n    for i in range(n):\n        if random.random() < 0.3:\n            j = (i + 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7820258399538683,
            2.1043933033943176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+5, n-1))\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Flip edges with probability\n    for i in range(n):\n        if random.random() < 0.3:\n            j = (i + 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement, measured by the combined distance reduction in both objective spaces, then applies a novel local search combining segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential improvement (simplified)\n        potential = (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]]) - (obj1 + obj2)\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6302619024087965,
            2.3058074712753296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential improvement (simplified)\n        potential = (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]]) - (obj1 + obj2)\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment reversal + node insertion\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest normalized sum of objectives, then applies a hybrid local search combining segment reversal with dynamic segment length and node swapping with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Dynamic segment reversal\n    segment_length = max(2, min(10, int(n * 0.3)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive node swapping\n    swap_prob = 0.6 if n > 10 else 0.8\n    if random.random() < swap_prob:\n        pos1, pos2 = random.sample(range(n), 2)\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.9795064933663079,
            1.982775330543518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Dynamic segment reversal\n    segment_length = max(2, min(10, int(n * 0.3)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive node swapping\n    swap_prob = 0.6 if n > 10 else 0.8\n    if random.random() < swap_prob:\n        pos1, pos2 = random.sample(range(n), 2)\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining 3-opt and a novel segment inversion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and dominance rank\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted objective score with dominance consideration\n        score = -0.7 * obj1 - 0.3 * obj2 + (len(archive) - i) * 0.01\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    # Step 1: 3-opt move\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_solution[a:d] = np.concatenate([segment1, segment3, segment2])\n\n    # Step 2: Segment inversion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9327488776576993,
            1.438040852546692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and dominance rank\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Weighted objective score with dominance consideration\n        score = -0.7 * obj1 - 0.3 * obj2 + (len(archive) - i) * 0.01\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    # Step 1: 3-opt move\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_solution[a:d] = np.concatenate([segment1, segment3, segment2])\n\n    # Step 2: Segment inversion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position with probability\n    if random.random() < 0.7:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Perform probabilistic edge swapping\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8693347905070802,
            1.3370439410209656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position with probability\n    if random.random() < 0.7:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Perform probabilistic edge swapping\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This new algorithm selects a solution from the archive based on the smallest sum of normalized objective values, then applies a hybrid local search combining edge swaps and node relocations with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with smallest sum\n    min_sum = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum < min_sum:\n            min_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Perform edge swap with probability based on solution quality\n    swap_prob = 0.6 if min_sum < 0.5 else 0.4\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Perform node relocation with adaptive probability\n    reloc_prob = 0.7 if min_sum < 0.3 else 0.5\n    if random.random() < reloc_prob:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5812490382029353,
            2.0613350868225098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with smallest sum\n    min_sum = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum < min_sum:\n            min_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Perform edge swap with probability based on solution quality\n    swap_prob = 0.6 if min_sum < 0.5 else 0.4\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Perform node relocation with adaptive probability\n    reloc_prob = 0.7 if min_sum < 0.3 else 0.5\n    if random.random() < reloc_prob:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment rotation and node swapping with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    selected_idx = 0\n    max_sum = -1\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment with adaptive probability\n    rotation_prob = 0.6 + 0.2 * (max_sum / (max_obj1 + max_obj2)) if (max_obj1 + max_obj2) > 0 else 0.6\n    if random.random() < rotation_prob:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        segment = new_solution[start:end+1]\n        shift = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap nodes based on distance improvement\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        original_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        if (new_dist1 + new_dist2) >= (original_dist1 + original_dist2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9425258626948422,
            2.1861371397972107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    selected_idx = 0\n    max_sum = -1\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment with adaptive probability\n    rotation_prob = 0.6 + 0.2 * (max_sum / (max_obj1 + max_obj2)) if (max_obj1 + max_obj2) > 0 else 0.6\n    if random.random() < rotation_prob:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        segment = new_solution[start:end+1]\n        shift = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Swap nodes based on distance improvement\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        original_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        if (new_dist1 + new_dist2) >= (original_dist1 + original_dist2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining node reversal with segment insertion and probabilistic node relocation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+4, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a segment at a new position with probability\n    if random.random() < 0.5:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+3, n-2))\n        segment = new_solution[start:end+1]\n        remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        insert_pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Relocate a random node with probability\n    if random.random() < 0.4:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8946765474952352,
            1.337043821811676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+4, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a segment at a new position with probability\n    if random.random() < 0.5:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+3, n-2))\n        segment = new_solution[start:end+1]\n        remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        insert_pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Relocate a random node with probability\n    if random.random() < 0.4:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective improvement potential, then applies a novel local search combining segment inversion and node reinsertion with adaptive step size to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (simplified)\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        potential = obj1 + obj2  # Placeholder for actual improvement potential calculation\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion with adaptive step size\n    step_size = max(2, min(5, n // 4))\n    start = random.randint(0, n - step_size - 1)\n    end = start + step_size\n\n    # Invert the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Node reinsertion with adaptive position\n    node_to_move = new_solution[end]\n    new_solution = np.concatenate([new_solution[:end], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.837128499520615,
            1.1342142820358276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (simplified)\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        potential = obj1 + obj2  # Placeholder for actual improvement potential calculation\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion with adaptive step size\n    step_size = max(2, min(5, n // 4))\n    start = random.randint(0, n - step_size - 1)\n    end = start + step_size\n\n    # Invert the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Node reinsertion with adaptive position\n    node_to_move = new_solution[end]\n    new_solution = np.concatenate([new_solution[:end], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{\"This heuristic selects a solution from the archive based on the highest combined objective value, then applies a novel hybrid local search combining adaptive segment inversion and probabilistic edge insertion to generate a neighbor solution while maintaining feasibility.\"}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Probabilistic edge insertion\n    for _ in range(2):\n        if random.random() < 0.7:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                if j > i:\n                    new_solution = np.delete(new_solution, j + 1)\n                else:\n                    new_solution = np.delete(new_solution, j)\n\n    return new_solution\n\n",
        "score": [
            -0.9004829915572969,
            1.6547617316246033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Probabilistic edge insertion\n    for _ in range(2):\n        if random.random() < 0.7:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                if j > i:\n                    new_solution = np.delete(new_solution, j + 1)\n                else:\n                    new_solution = np.delete(new_solution, j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+4, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.4:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9023476589411015,
            2.0691887736320496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+4, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.4:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This new algorithm selects a solution from the archive based on the lowest sum of normalized objective values, then applies a hybrid local search combining node swapping with k-opt (for k=3) and segment reversal with probability-based selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with lowest sum\n    min_sum = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum < min_sum:\n            min_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Apply 3-opt with probability\n    if random.random() < 0.6:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Step 2: Reverse a random segment with probability\n    if random.random() < 0.4:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6458790134050297,
            1.83584862947464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with lowest sum\n    min_sum = float('inf')\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum < min_sum:\n            min_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Apply 3-opt with probability\n    if random.random() < 0.6:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Step 2: Reverse a random segment with probability\n    if random.random() < 0.4:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node swapping with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive probabilities based on solution quality\n    quality = max_sum / 2  # Normalized quality\n    rev_prob = min(0.8, 0.5 + quality * 0.3)\n    swap_prob = min(0.7, 0.3 + quality * 0.4)\n\n    # Step 1: Reverse a random segment\n    if random.random() < rev_prob:\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Swap two random nodes\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.866257137034195,
            1.487354040145874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive probabilities based on solution quality\n    quality = max_sum / 2  # Normalized quality\n    rev_prob = min(0.8, 0.5 + quality * 0.3)\n    swap_prob = min(0.7, 0.3 + quality * 0.4)\n\n    # Step 1: Reverse a random segment\n    if random.random() < rev_prob:\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Swap two random nodes\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment rotation and node permutation with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment with adaptive probability\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n-segment_length)\n    end = start + segment_length - 1\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, segment_length-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Permute a random subset of nodes with adaptive probability\n    subset_size = random.randint(2, min(5, n-1))\n    subset_indices = random.sample(range(n), subset_size)\n    subset = new_solution[subset_indices]\n    np.random.shuffle(subset)\n    new_solution[subset_indices] = subset\n\n    return new_solution\n\n",
        "score": [
            -0.948938618186408,
            2.0667113065719604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment with adaptive probability\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n-segment_length)\n    end = start + segment_length - 1\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, segment_length-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Step 2: Permute a random subset of nodes with adaptive probability\n    subset_size = random.randint(2, min(5, n-1))\n    subset_indices = random.sample(range(n), subset_size)\n    subset = new_solution[subset_indices]\n    np.random.shuffle(subset)\n    new_solution[subset_indices] = subset\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This heuristic selects a solution from the archive based on the sum of normalized objective values, then applies a novel hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on normalized objective sum\n    max_score = -float('inf')\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and compute score\n        norm_obj1 = obj1 / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj2 / (distance_matrix_2.max() * len(sol))\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9495945627710094,
            4.811935245990753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on normalized objective sum\n    max_score = -float('inf')\n    selected_idx = 0\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Normalize objectives and compute score\n        norm_obj1 = obj1 / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj2 / (distance_matrix_2.max() * len(sol))\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: segment reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+3, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This heuristic function selects a solution from the archive based on a weighted combination of its objective values, then applies a hybrid local search combining a novel segment inversion and a probabilistic edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values\n    weights = [0.6, 0.4]  # Weight for first objective\n    selected_idx = 0\n    min_weighted = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted = weights[0] * obj1 + weights[1] * obj2\n        if weighted < min_weighted:\n            min_weighted = weighted\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + probabilistic edge insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]  # Invert segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Probabilistic edge insertion\n    if random.random() < 0.3:  # 30% chance\n        i, j = random.sample(range(n), 2)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6801852545807825,
            1.6667132377624512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values\n    weights = [0.6, 0.4]  # Weight for first objective\n    selected_idx = 0\n    min_weighted = float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        weighted = weights[0] * obj1 + weights[1] * obj2\n        if weighted < min_weighted:\n            min_weighted = weighted\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Hybrid local search: segment inversion + probabilistic edge insertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1][::-1]  # Invert segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Probabilistic edge insertion\n    if random.random() < 0.3:  # 30% chance\n        i, j = random.sample(range(n), 2)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objectives, then applies a novel local search combining adaptive segment rotation and probabilistic node swapping, ensuring feasibility by maintaining node uniqueness and tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment rotation\n    segment_length = max(2, min(5, n // 3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end+1] = rotated_segment\n\n    # Probabilistic node swapping\n    for i in range(n):\n        if random.random() < 0.3:\n            j = random.randint(0, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7594932000988504,
            1.9187037944793701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment rotation\n    segment_length = max(2, min(5, n // 3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end+1] = rotated_segment\n\n    # Probabilistic node swapping\n    for i in range(n):\n        if random.random() < 0.3:\n            j = random.randint(0, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized and weighted objective values, then applies a hybrid local search combining segment reversal, node insertion, and edge swapping with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of normalized objectives\n    max_score = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_score = 0.6 * norm_obj1 + 0.4 * norm_obj2\n        if current_score > max_score:\n            max_score = current_score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive probabilities based on solution length\n    p_reverse = min(0.8, 0.5 + n/100)\n    p_insert = min(0.6, 0.3 + n/150)\n    p_swap = min(0.7, 0.4 + n/120)\n\n    # Step 1: Reverse a random segment\n    if random.random() < p_reverse:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    if random.random() < p_insert:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Swap two edges\n    if random.random() < p_swap and n > 3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8623620242426552,
            2.446676254272461
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of normalized objectives\n    max_score = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_score = 0.6 * norm_obj1 + 0.4 * norm_obj2\n        if current_score > max_score:\n            max_score = current_score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive probabilities based on solution length\n    p_reverse = min(0.8, 0.5 + n/100)\n    p_insert = min(0.6, 0.3 + n/150)\n    p_swap = min(0.7, 0.4 + n/120)\n\n    # Step 1: Reverse a random segment\n    if random.random() < p_reverse:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position\n    if random.random() < p_insert:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Swap two edges\n    if random.random() < p_swap and n > 3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining segment reversal and node swap with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+3, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    if random.random() < 0.4:\n        pos1, pos2 = random.sample(range(n), 2)\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.842992233350366,
            2.4244340658187866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+3, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    if random.random() < 0.4:\n        pos1, pos2 = random.sample(range(n), 2)\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a novel local search strategy combining segment inversion and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node reinsertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Reinsert a randomly selected node to a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9058561568575577,
            2.2598975896835327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Novel local search: segment inversion + node reinsertion\n    # Step 1: Invert a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Reinsert a randomly selected node to a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    remaining = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining edge swapping and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Edge swap with adaptive probability\n    swap_prob = 0.6 + 0.2 * (max_sum - 1)\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment with adaptive probability\n    reverse_prob = 0.5 + 0.3 * (max_sum - 1)\n    if random.random() < reverse_prob:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9302194305168257,
            2.395513117313385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Edge swap with adaptive probability\n    swap_prob = 0.6 + 0.2 * (max_sum - 1)\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment with adaptive probability\n    reverse_prob = 0.5 + 0.3 * (max_sum - 1)\n    if random.random() < reverse_prob:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining k-opt moves with adaptive segment inversion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity\n        diversity = sum(abs(sol[j] - sol[j-1]) for j in range(1, len(sol)))\n        score = (obj1 + obj2) * 0.7 + diversity * 0.3\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive k-opt move (k between 3 and 5)\n    k = random.randint(3, min(5, n-1))\n    indices = sorted(random.sample(range(n), k))\n\n    # Create a segment of random size and invert it\n    segment_size = random.randint(2, min(5, n-k))\n    segment_start = indices[0]\n    segment_end = segment_start + segment_size\n    if segment_end > n:\n        segment_end = n\n\n    # Reverse the segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Rotate the selected indices\n    rotation = random.randint(1, k-1)\n    new_solution[indices] = np.roll(new_solution[indices], rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.7708840664744239,
            6.253389537334442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    selected_idx = 0\n    best_score = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Score combines objective values and diversity\n        diversity = sum(abs(sol[j] - sol[j-1]) for j in range(1, len(sol)))\n        score = (obj1 + obj2) * 0.7 + diversity * 0.3\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive k-opt move (k between 3 and 5)\n    k = random.randint(3, min(5, n-1))\n    indices = sorted(random.sample(range(n), k))\n\n    # Create a segment of random size and invert it\n    segment_size = random.randint(2, min(5, n-k))\n    segment_start = indices[0]\n    segment_end = segment_start + segment_size\n    if segment_end > n:\n        segment_end = n\n\n    # Reverse the segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Rotate the selected indices\n    rotation = random.randint(1, k-1)\n    new_solution[indices] = np.roll(new_solution[indices], rotation)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining node rotation and segment inversion with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment with adaptive probability\n    rotation_prob = 0.6 + 0.2 * (max_sum - 0.5)  # Higher probability for better solutions\n    if random.random() < rotation_prob:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+5, n-2))\n        rotation = random.randint(1, end-start)\n        new_solution[start:end+1] = np.roll(new_solution[start:end+1], rotation)\n\n    # Step 2: Invert a random segment with adaptive probability\n    inversion_prob = 0.4 + 0.3 * (max_sum - 0.5)\n    if random.random() < inversion_prob:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9652860631181803,
            2.6082012057304382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment with adaptive probability\n    rotation_prob = 0.6 + 0.2 * (max_sum - 0.5)  # Higher probability for better solutions\n    if random.random() < rotation_prob:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+5, n-2))\n        rotation = random.randint(1, end-start)\n        new_solution[start:end+1] = np.roll(new_solution[start:end+1], rotation)\n\n    # Step 2: Invert a random segment with adaptive probability\n    inversion_prob = 0.4 + 0.3 * (max_sum - 0.5)\n    if random.random() < inversion_prob:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objectives, then applies a novel hybrid local search combining adaptive segment rotation and probabilistic node swapping with distance-aware selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    selected_idx = 0\n    max_sum = -1\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment rotation\n    segment_length = min(5, n // 2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    segment = new_solution[start:end+1]\n\n    # Calculate average distance in both spaces for the segment\n    avg_dist1 = 0.0\n    avg_dist2 = 0.0\n    for i in range(len(segment)-1):\n        avg_dist1 += distance_matrix_1[segment[i], segment[i+1]]\n        avg_dist2 += distance_matrix_2[segment[i], segment[i+1]]\n    avg_dist1 += distance_matrix_1[segment[-1], segment[0]]\n    avg_dist2 += distance_matrix_2[segment[-1], segment[0]]\n    avg_dist1 /= len(segment)\n    avg_dist2 /= len(segment)\n\n    # Decide rotation direction based on distance comparison\n    if avg_dist1 > avg_dist2:\n        # Rotate left if first space is worse\n        segment = np.roll(segment, -1)\n    else:\n        # Rotate right if second space is worse\n        segment = np.roll(segment, 1)\n\n    new_solution[start:end+1] = segment\n\n    # Probabilistic node swapping with distance awareness\n    for i in range(n):\n        if random.random() < 0.3:\n            j = random.randint(0, n-1)\n            # Swap only if it improves at least one objective\n            old_dist1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n            new_dist1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]]\n            old_dist2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n            new_dist2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]]\n\n            if (new_dist1 < old_dist1) or (new_dist2 < old_dist2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.90138590803504,
            2.495514690876007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    selected_idx = 0\n    max_sum = -1\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Adaptive segment rotation\n    segment_length = min(5, n // 2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    segment = new_solution[start:end+1]\n\n    # Calculate average distance in both spaces for the segment\n    avg_dist1 = 0.0\n    avg_dist2 = 0.0\n    for i in range(len(segment)-1):\n        avg_dist1 += distance_matrix_1[segment[i], segment[i+1]]\n        avg_dist2 += distance_matrix_2[segment[i], segment[i+1]]\n    avg_dist1 += distance_matrix_1[segment[-1], segment[0]]\n    avg_dist2 += distance_matrix_2[segment[-1], segment[0]]\n    avg_dist1 /= len(segment)\n    avg_dist2 /= len(segment)\n\n    # Decide rotation direction based on distance comparison\n    if avg_dist1 > avg_dist2:\n        # Rotate left if first space is worse\n        segment = np.roll(segment, -1)\n    else:\n        # Rotate right if second space is worse\n        segment = np.roll(segment, 1)\n\n    new_solution[start:end+1] = segment\n\n    # Probabilistic node swapping with distance awareness\n    for i in range(n):\n        if random.random() < 0.3:\n            j = random.randint(0, n-1)\n            # Swap only if it improves at least one objective\n            old_dist1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n            new_dist1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]]\n            old_dist2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n            new_dist2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]]\n\n            if (new_dist1 < old_dist1) or (new_dist2 < old_dist2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives and applies a hybrid local search combining 3-opt and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of objectives\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = 0.7 * obj1 + 0.3 * obj2  # Weighted sum with different weights\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + node insertion\n    # 3-opt operation\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:d+1]\n    new_order = np.concatenate([segment1, segment3, segment2])\n    new_solution[a:d+1] = new_order\n\n    # Node insertion\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9204195371971825,
            2.0680076479911804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of objectives\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        score = 0.7 * obj1 + 0.3 * obj2  # Weighted sum with different weights\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + node insertion\n    # 3-opt operation\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:d+1]\n    new_order = np.concatenate([segment1, segment3, segment2])\n    new_solution[a:d+1] = new_order\n\n    # Node insertion\n    node = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining 3-opt with a novel segment inversion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.random.dirichlet(np.ones(2))\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.880618694515096,
            2.371249556541443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.random.dirichlet(np.ones(2))\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: 3-opt + segment inversion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining node swapping with path reversal and probabilistic segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a segment with probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 3: Insert a random segment with probability\n    if random.random() < 0.4:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+3, n-2))\n        segment = new_solution[start:end+1]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9178980594285503,
            2.355376958847046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a segment with probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 3: Insert a random segment with probability\n    if random.random() < 0.4:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+3, n-2))\n        segment = new_solution[start:end+1]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objectives, then applies a hybrid local search combining segment rotation and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment with adaptive probability\n    segment_length = min(4, n // 3)\n    if random.random() < 0.6:\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Swap two non-adjacent nodes with adaptive probability\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        while abs(i - j) <= 1:\n            i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9264623329072336,
            2.2548651099205017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Rotate a random segment with adaptive probability\n    segment_length = min(4, n // 3)\n    if random.random() < 0.6:\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Swap two non-adjacent nodes with adaptive probability\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        while abs(i - j) <= 1:\n            i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest sum of normalized objective values, then applies a novel local search combining path reversal, segment rotation, and selective edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    selected_idx = 0\n    max_normalized = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        normalized = (obj1 + obj2) / (max(obj1, obj2) if max(obj1, obj2) > 0 else 1)\n        if normalized > max_normalized:\n            max_normalized = normalized\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: path reversal, segment rotation, and selective insertion\n    # Step 1: Random path reversal\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Segment rotation\n    segment_size = random.randint(2, min(5, n//2))\n    segment_start = random.randint(0, n - segment_size)\n    segment = new_solution[segment_start:segment_start+segment_size]\n    rotation = random.randint(1, segment_size-1)\n    new_solution[segment_start:segment_start+segment_size] = np.roll(segment, rotation)\n\n    # Step 3: Selective edge insertion\n    if n > 4:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            # Insert node i after node j\n            new_solution = np.concatenate([\n                new_solution[:j+1],\n                [new_solution[i]],\n                new_solution[j+1:i],\n                new_solution[i+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.7786506175450953,
            0.8456885814666748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    selected_idx = 0\n    max_normalized = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        normalized = (obj1 + obj2) / (max(obj1, obj2) if max(obj1, obj2) > 0 else 1)\n        if normalized > max_normalized:\n            max_normalized = normalized\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Novel local search: path reversal, segment rotation, and selective insertion\n    # Step 1: Random path reversal\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Segment rotation\n    segment_size = random.randint(2, min(5, n//2))\n    segment_start = random.randint(0, n - segment_size)\n    segment = new_solution[segment_start:segment_start+segment_size]\n    rotation = random.randint(1, segment_size-1)\n    new_solution[segment_start:segment_start+segment_size] = np.roll(segment, rotation)\n\n    # Step 3: Selective edge insertion\n    if n > 4:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            # Insert node i after node j\n            new_solution = np.concatenate([\n                new_solution[:j+1],\n                [new_solution[i]],\n                new_solution[j+1:i],\n                new_solution[i+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining segment reversal and node insertion with probability-based selection to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest product\n    max_product = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Reverse a random segment with probability\n    if random.random() < 0.7:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random node at a new position with probability\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search combining node transposition and segment inversion with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Transpose two random nodes with adaptive probability\n    if random.random() < 0.8:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment with adaptive probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9623976790202686,
            1.980937123298645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    max_sum = -1\n    selected_idx = 0\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1_values), min(obj1_values)\n    max_obj2, min_obj2 = max(obj2_values), min(obj2_values)\n\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return base_solution\n\n    # Step 1: Transpose two random nodes with adaptive probability\n    if random.random() < 0.8:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment with adaptive probability\n    if random.random() < 0.6:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic function selects a promising solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on crowding distance and dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        crowding = obj1 + obj2  # Placeholder for actual crowding distance calculation\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Step 1: Select a random segment and relocate it\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This algorithm prioritizes solutions with high diversity in the objective space, then applies a hybrid local search combining path reversal and node insertion to generate a feasible neighbor solution while considering both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (spread in objective space)\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)  # Measure of diversity between objectives\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: path reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.3513347373183857,
            1.6149504780769348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (spread in objective space)\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (obj1, obj2)) in enumerate(archive):\n        diversity = abs(obj1 - obj2)  # Measure of diversity between objectives\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return base_solution\n\n    # Hybrid local search: path reversal + node insertion\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, min(start+5, n-2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    }
]