[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # If too small, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three random segments to modify\n        segments = np.sort(np.random.choice(n, 3, replace=False))\n        a, b, c = segments\n\n        # Extract segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Recombine segments with novel perturbation\n        new_order = np.concatenate([\n            segment1,\n            segment3[::-1],  # Reverse middle segment\n            segment2,\n            segment4\n        ])\n\n        # Ensure all nodes are visited exactly once\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order\n\n    return new_solution\n\n",
          "score": [
               -0.79853724529653,
               0.20083975791931152
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a promising solution from the archive by prioritizing those with the highest combined normalized objective values, indicating potential for improvement. It then applies a hybrid local search operator that combines a novel 3-opt move with a dynamic edge selection strategy, where edges are chosen based on their contribution to both objectives, ensuring feasibility by maintaining a Hamiltonian cycle. The algorithm dynamically adjusts the balance between objectives during the search, using a weighted sum of normalized objective values to guide the selection of edges for perturbation. The 3-opt move is applied in a way that minimizes the increase in the total tour length for both objectives, leveraging the distance matrices to compute edge costs efficiently. The process repeats for a fixed number of iterations or until no further improvement is found, with the final solution being the best encountered during the search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid 3-opt with dynamic edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Extract the edges\n    a, b, c = new_solution[i], new_solution[(i+1)%n], new_solution[j]\n    d, e, f = new_solution[(j+1)%n], new_solution[k], new_solution[(k+1)%n]\n\n    # Compute the cost of the current and new configurations\n    # Current cost: a-b, b-c, c-d, d-e, e-f\n    current_cost = (distance_matrix_1[a, b] + distance_matrix_1[b, c] + distance_matrix_1[c, d] + distance_matrix_1[d, e] + distance_matrix_1[e, f] +\n                    distance_matrix_2[a, b] + distance_matrix_2[b, c] + distance_matrix_2[c, d] + distance_matrix_2[d, e] + distance_matrix_2[e, f])\n\n    # New cost: a-c, c-b, b-e, e-d, d-f\n    new_cost = (distance_matrix_1[a, c] + distance_matrix_1[c, b] + distance_matrix_1[b, e] + distance_matrix_1[e, d] + distance_matrix_1[d, f] +\n                distance_matrix_2[a, c] + distance_matrix_2[c, b] + distance_matrix_2[b, e] + distance_matrix_2[e, d] + distance_matrix_2[d, f])\n\n    # Apply the move if it improves the combined cost\n    if new_cost < current_cost:\n        # Reconstruct the tour\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        new_solution[j+1:k+1] = np.flip(new_solution[j+1:k+1])\n        new_solution[k+1:] = np.roll(new_solution[k+1:], shift=1)\n\n    return new_solution\n\n",
          "score": [
               -0.8420272791118616,
               0.2737277150154114
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising base solution\n    def selection_criterion(sol_obj):\n        # Combine dominance and diversity metrics\n        sol, obj = sol_obj\n        # Simple criterion: prioritize lower objective values\n        return obj[0] + obj[1]\n\n    # Sort by selection criterion\n    archive_sorted = sorted(archive, key=selection_criterion)\n    base_solution, _ = archive_sorted[0]\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid operator: combination of restricted 3-opt and biased edge exchange\n    if n >= 4:\n        # Select three distinct positions with some randomness\n        i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n        # Apply restricted 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Apply biased edge exchange\n        # Prefer edges that improve both objectives when possible\n        for _ in range(2):  # Limit the number of exchanges\n            a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n            # Check if exchange improves both objectives\n            old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n            new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n            old_cost1 = sum(distance_matrix_1[u][v] for u, v in old_edges)\n            new_cost1 = sum(distance_matrix_1[u][v] for u, v in new_edges)\n            old_cost2 = sum(distance_matrix_2[u][v] for u, v in old_edges)\n            new_cost2 = sum(distance_matrix_2[u][v] for u, v in new_edges)\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not (len(new_solution) == len(np.unique(new_solution))):\n        raise ValueError(\"Generated solution is not a valid tour\")\n\n    return new_solution\n\n",
          "score": [
               -0.8446671578572267,
               0.2885757088661194
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first intelligently selects a solution from the archive by prioritizing those with lower combined objective values and higher variance in their objectives to identify Pareto-efficient solutions with potential for improvement. It then applies a hybrid local search operator that combines a modified 3-opt heuristic with a biased random walk to explore the solution space, ensuring feasibility by validating all candidate moves before execution. The operator selectively disrupts and repairs segments of the tour, using the distance matrices to guide moves that improve both objectives, while the biased random walk introduces controlled exploration to escape local optima. The function returns the new neighbor solution after validating its feasibility and ensuring it represents a valid TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value and high variance\n    archive_sorted = sorted(archive, key=lambda x: (sum(x[1]), -abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with biased random walk\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 distinct edges to modify\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Generate candidate moves (3-opt variants)\n    candidates = [\n        # Standard 3-opt\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[k:]]),\n        # Biased random walk\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n    ]\n\n    # Evaluate candidates based on both objectives\n    best_candidate = None\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        if len(set(candidate)) != n:  # Ensure validity\n            continue\n\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate.copy()\n\n    # If no improvement found, perform a small perturbation\n    if best_candidate is None:\n        i, j = np.random.choice(n, size=2, replace=False)\n        best_candidate = new_solution.copy()\n        best_candidate[i], best_candidate[j] = best_candidate[j], best_candidate[i]\n\n    return best_candidate\n\n",
          "score": [
               -0.838563790971558,
               0.2600090503692627
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for local improvement using a combination of crowding distance and objective-space dominance analysis. It then intelligently selects one such solution based on a weighted random selection that favors solutions with high crowding distance or non-dominated status. For the local search, it employs a hybrid approach that combines a novel 'segmented inversion' operator with a 'multi-objective edge insertion' strategy. The segmented inversion randomly selects a segment of the tour and reverses it, while the edge insertion strategy evaluates all possible insertions of non-adjacent edges to improve both objectives. The function ensures feasibility by always validating the generated neighbor solution before returning it, guaranteeing it remains a valid TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate crowding distance (simplified)\n        crowding_dist = obj[0] + obj[1]  # Sum of objectives as a proxy\n        candidates.append((sol, obj, crowding_dist))\n\n    # Step 2: Select a solution with high crowding distance or non-dominated status\n    candidates.sort(key=lambda x: -x[2])  # Sort by crowding distance (descending)\n    selected = candidates[0][0].copy()  # Start with the most promising\n\n    # Step 3: Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segmented inversion\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion (multi-objective)\n    best_improvement = 0\n    best_new_solution = new_solution.copy()\n\n    for i in range(n):\n        for j in range(i+2, n):\n            # Try inserting edge (i+1) after j\n            temp_sol = new_solution.copy()\n            temp_sol = np.concatenate([temp_sol[:i+1], temp_sol[i+2:j+1], temp_sol[i+1:i+2], temp_sol[j+1:]])\n\n            # Calculate improvement\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[i+2]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n            improvement1 = old_cost1 - new_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[i+2]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n            improvement2 = old_cost2 - new_cost2\n\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_new_solution = temp_sol.copy()\n\n    # Ensure feasibility\n    if len(np.unique(best_new_solution)) != n:\n        best_new_solution = new_solution.copy()  # Fallback to original if invalid\n\n    return best_new_solution\n\n",
          "score": [
               -0.9465775495376276,
               1.375964343547821
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (novel segment reversal)\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Edge insertion for further improvement\n    for _ in range(2):  # Perform a limited number of insertions\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == n, \"Invalid neighbor solution: duplicate nodes or missing nodes\"\n    assert np.all(np.sort(new_solution) == np.arange(n)), \"Invalid neighbor solution: missing nodes\"\n\n    return new_solution\n\n",
          "score": [
               -0.6149322515856278,
               0.26697051525115967
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' employs a multi-objective adaptive selection strategy to intelligently choose a solution from the archive by prioritizing those with high Pareto dominance or significant objective diversity, then applies a hybrid local search operator combining edge exchange and segment inversion, where edge exchange dynamically selects the best swap between edges from the two objective spaces based on a weighted cost function, while segment inversion flips a random sub-segment of the tour to escape local optima, ensuring feasibility by maintaining tour continuity and node uniqueness through careful index manipulation and validation, with the operator's intensity adjusted based on the solution's current objective divergence to balance exploration and exploitation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def dominance_score(obj):\n        # Simple dominance score based on normalized objective values\n        obj1, obj2 = obj\n        max_obj1 = max(o[0] for _, o in archive)\n        max_obj2 = max(o[1] for _, o in archive)\n        if max_obj1 == 0 or max_obj2 == 0:\n            return 0\n        return (obj1 / max_obj1) + (obj2 / max_obj2)\n\n    # Sort solutions by dominance score (higher is better)\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]), reverse=True)\n\n    # Select top 30% of solutions\n    top_percent = max(1, len(archive) // 3)\n    candidates = archive_sorted[:top_percent]\n\n    # Randomly select one from top candidates\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge exchange with weighted cost function\n    i, j = np.random.choice(n, 2, replace=False)\n    obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n    obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n    obj1_alt = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n    obj2_alt = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n    # Weighted cost difference\n    weight = 0.5  # Equal weight for both objectives\n    cost_diff = (obj1 + obj2) - (obj1_alt + obj2_alt)\n\n    if cost_diff > 0:  # If improvement\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion\n    if n > 3:\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7414655712762392,
               1.7289301753044128
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution from the archive by evaluating a custom fitness score that combines the solution's objective values with its structural properties, such as the diversity of edges and the balance between the two objectives. This score is computed as the weighted sum of the normalized objectives and the inverse of the solution's edge diversity, encouraging solutions with better objective values and higher structural variability. The function then applies a hybrid local search operator that combines a novel edge exchange mechanism with a probabilistic edge reinsertion step. The edge exchange mechanism selects two random edges in the solution and swaps their endpoints, ensuring the solution remains feasible. If this results in a significant improvement in either objective, the change is accepted. Otherwise, a probabilistic edge reinsertion is performed, where a randomly selected edge is removed and reinserted at a position that minimizes the increase in the total tour length. This hybrid approach balances exploration and exploitation, leveraging both the structural properties of the solution and the objective-specific improvements to generate high-quality neighbor solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a custom fitness score\n    def compute_fitness(solution, objective):\n        # Normalize objectives\n        max_obj1 = max(obj[0] for _, obj in archive)\n        max_obj2 = max(obj[1] for _, obj in archive)\n        norm_obj1 = objective[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = objective[1] / max_obj2 if max_obj2 != 0 else 0\n\n        # Compute edge diversity (number of unique edges)\n        edges = set()\n        for i in range(len(solution)):\n            u = solution[i]\n            v = solution[(i + 1) % len(solution)]\n            edges.add((min(u, v), max(u, v)))\n        edge_diversity = len(edges)\n\n        # Fitness score: balance between objectives and edge diversity\n        fitness = 0.5 * (norm_obj1 + norm_obj2) + 0.5 * (1 / edge_diversity if edge_diversity > 0 else 0)\n        return fitness\n\n    # Evaluate all solutions in the archive and select the best\n    best_solution = None\n    best_fitness = float('-inf')\n    for solution, objective in archive:\n        fitness = compute_fitness(solution, objective)\n        if fitness > best_fitness:\n            best_fitness = fitness\n            best_solution = solution.copy()\n\n    if best_solution is None:\n        best_solution = archive[0][0].copy()\n\n    new_solution = best_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Edge exchange mechanism\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Check if the exchange improves either objective\n    def compute_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            u = solution[i]\n            v = solution[(i + 1) % len(solution)]\n            cost += distance_matrix[u, v]\n        return cost\n\n    original_cost1 = compute_cost(best_solution, distance_matrix_1)\n    original_cost2 = compute_cost(best_solution, distance_matrix_2)\n    new_cost1 = compute_cost(new_solution, distance_matrix_1)\n    new_cost2 = compute_cost(new_solution, distance_matrix_2)\n\n    if new_cost1 > original_cost1 and new_cost2 > original_cost2:\n        # If no improvement, perform probabilistic edge reinsertion\n        k = np.random.randint(0, n)\n        removed_node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find the best position to reinsert the node\n        best_insert_pos = 0\n        best_insert_cost = float('inf')\n        for pos in range(n - 1):\n            temp_solution = np.insert(new_solution, pos, removed_node)\n            temp_cost = compute_cost(temp_solution, distance_matrix_1) + compute_cost(temp_solution, distance_matrix_2)\n            if temp_cost < best_insert_cost:\n                best_insert_cost = temp_cost\n                best_insert_pos = pos\n\n        new_solution = np.insert(new_solution, best_insert_pos, removed_node)\n\n    return new_solution\n\n",
          "score": [
               -0.8818676463008326,
               3.372175872325897
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from typing import List, Tuple\n    import numpy as np\n\n    # Select a promising solution from the archive (e.g., one with the lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine edge exchange with a novel segment-based perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (like 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have segments to swap\n        # Instead of reversing, we swap segments with a probability based on their cost improvement\n        segment1 = new_solution[i:j]\n        segment2 = np.roll(new_solution, j - i)[i:j]\n\n        cost1 = distance_matrix_1[new_solution[i-1], segment1[0]] + distance_matrix_1[segment1[-1], new_solution[j]]\n        cost2 = distance_matrix_1[new_solution[i-1], segment2[0]] + distance_matrix_1[segment2[-1], new_solution[j]]\n\n        if cost1 > cost2:  # If swapping improves the solution\n            new_solution[i:j] = segment2\n\n    # Step 2: Novel segment-based perturbation\n    # Randomly select a segment and move it to a different position, but only if it improves both objectives\n    k, l = sorted(random.sample(range(n), 2))\n    if l - k > 1:\n        segment = new_solution[k:l]\n        remaining = np.concatenate([new_solution[:k], new_solution[l:]])\n\n        # Try inserting the segment at different positions\n        for m in range(len(remaining)):\n            candidate = np.insert(remaining, m, segment)\n            # Check if this improves both objectives\n            old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n            new_cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n\n            old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n            new_cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.2830648285303481,
               2.874260663986206
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Determine which objective to prioritize\n    if current_obj[0] > current_obj[1]:\n        primary_matrix = distance_matrix_1\n        secondary_matrix = distance_matrix_2\n    else:\n        primary_matrix = distance_matrix_2\n        secondary_matrix = distance_matrix_1\n\n    # Hybrid local search: edge exchange with node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Try edge exchange\n        candidate = new_solution.copy()\n        candidate[i:j] = np.flip(candidate[i:j])\n\n        # Evaluate both objectives\n        def calculate_objective(sol, mat1, mat2):\n            cost1 = sum(mat1[sol[k], sol[k+1]] for k in range(n-1)) + mat1[sol[-1], sol[0]]\n            cost2 = sum(mat2[sol[k], sol[k+1]] for k in range(n-1)) + mat2[sol[-1], sol[0]]\n            return cost1, cost2\n\n        orig_cost = calculate_objective(new_solution, distance_matrix_1, distance_matrix_2)\n        new_cost = calculate_objective(candidate, distance_matrix_1, distance_matrix_2)\n\n        # Accept if better in primary objective or equally good in both\n        if (new_cost[0] < orig_cost[0] and new_cost[1] <= orig_cost[1]) or \\\n           (new_cost[0] <= orig_cost[0] and new_cost[1] < orig_cost[1]):\n            new_solution = candidate\n            continue\n\n        # If no improvement, try node insertion\n        k = np.random.randint(0, n)\n        candidate = np.delete(new_solution, k)\n        candidate = np.insert(candidate, np.random.randint(0, n-1), new_solution[k])\n        new_cost = calculate_objective(candidate, distance_matrix_1, distance_matrix_2)\n\n        if (new_cost[0] < orig_cost[0] and new_cost[1] <= orig_cost[1]) or \\\n           (new_cost[0] <= orig_cost[0] and new_cost[1] < orig_cost[1]):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               -0.518755042993283,
               7.084364473819733
          ]
     }
]