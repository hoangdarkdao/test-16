[
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ]
    },
    {
        "algorithm": "{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0655273414225888,
            0.8925878405570984
        ]
    }
]