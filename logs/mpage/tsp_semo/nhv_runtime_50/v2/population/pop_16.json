[
     {
          "algorithm": "{The new algorithm, named \"Objective-Driven Hybrid Segment Fusion with Dynamic Node Rebalancing,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first identifying and fusing the most complementary segments from different solutions in the archive, then dynamically rebalancing the tour by selectively replacing nodes based on their cross-dimensional contribution scores. This method combines segment fusion with a novel node replacement mechanism that evaluates each node's potential to improve both objectives simultaneously, using a probabilistic acceptance criterion that considers both immediate improvement and long-term solution balance, while maintaining tour feasibility through a two-phase validation process that checks both segment connectivity and node uniqueness.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the best segments from different solutions\n    best_segments = []\n    for solution, _ in archive[:3]:  # Consider top 3 solutions\n        n = len(solution)\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = solution[i:i+segment_length]\n            if len(segment) > 1:\n                best_segments.append(segment)\n\n    if not best_segments:\n        best_segments = [archive[0][0][:3]]\n\n    # Step 2: Create initial solution by combining complementary segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in best_segments:\n        new_solution.extend(seg)\n        for node in seg:\n            remaining_nodes.discard(node)\n\n    # Step 3: Dynamic node rebalancing\n    for _ in range(3):  # Perform 3 rebalancing iterations\n        for i in range(len(new_solution)):\n            node = new_solution[i]\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i+1] if i < len(new_solution)-1 else new_solution[0]\n\n            # Calculate current contribution to both objectives\n            current_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Find potential replacement nodes\n            candidates = list(remaining_nodes)\n            if not candidates:\n                break\n\n            for candidate in candidates:\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node] +\n                              distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node])\n\n                # Accept if improvement in both objectives\n                if new_contrib < current_contrib * 0.95:  # 5% improvement threshold\n                    new_solution[i] = candidate\n                    remaining_nodes.add(node)\n                    remaining_nodes.remove(candidate)\n                    break\n\n    # Step 4: Insert remaining nodes\n    remaining_nodes = list(remaining_nodes)\n    while remaining_nodes:\n        best_node = None\n        best_pos = -1\n        best_score = float('inf')\n\n        for node in remaining_nodes:\n            for i in range(len(new_solution)):\n                if i == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[i-1]\n                    next_node = new_solution[i]\n\n                score = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_pos = i\n\n        if best_node is not None:\n            new_solution.insert(best_pos, best_node)\n            remaining_nodes.remove(best_node)\n        else:\n            new_solution.extend(remaining_nodes)\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == len(instance), \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8144581164160893,
               0.09934872388839722
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Centric Tour Decomposition with Cross-Objective Segment Fusion,\" builds upon the common backbone of solution selection and tour decomposition from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective-centric\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then fused across objectives using an adaptive strategy that dynamically combines segments from both objectives while maintaining their relative order, followed by a \"cross-objective segment interleaving\" phase that probabilistically interleaves segments from both objectives to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into objective-centric segments\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = None\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if current_obj is None:\n            if cost1 > cost2:\n                current_obj = 1\n            else:\n                current_obj = 2\n            current_segment.append(current_node)\n        else:\n            if (current_obj == 1 and cost1 < cost2 * 0.8) or (current_obj == 2 and cost2 < cost1 * 0.8):\n                segments.append((current_obj, current_segment))\n                current_segment = [current_node]\n                current_obj = 3 - current_obj  # Switch objective\n            else:\n                current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [(1, new_solution[:n//2]), (2, new_solution[n//2:])]\n\n    # Step 3: Cross-objective segment fusion\n    fused_segments = []\n    i = 0\n    while i < len(segments):\n        obj1, seg1 = segments[i]\n        if i + 1 < len(segments):\n            obj2, seg2 = segments[i+1]\n            if obj1 != obj2 and random.random() < 0.5:\n                # Fuse segments from different objectives\n                fused_segment = seg1 + seg2\n                fused_segments.append((obj1, fused_segment))\n                i += 2\n            else:\n                fused_segments.append((obj1, seg1))\n                i += 1\n        else:\n            fused_segments.append((obj1, seg1))\n            i += 1\n\n    # Step 4: Cross-objective segment interleaving\n    if len(fused_segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in fused_segments if obj == 1]\n        obj2_segments = [seg for obj, seg in fused_segments if obj == 2]\n\n        # Interleave segments from both objectives\n        new_solution = []\n        i, j = 0, 0\n        while i < len(obj1_segments) or j < len(obj2_segments):\n            if i < len(obj1_segments) and (j >= len(obj2_segments) or random.random() < 0.5):\n                new_solution.extend(obj1_segments[i])\n                i += 1\n            else:\n                new_solution.extend(obj2_segments[j])\n                j += 1\n\n    # Step 5: Reconstruct solution and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            _, seg = fused_segments[i]\n            fused_segments[i] = (3 - fused_segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in fused_segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8855038623380989,
               0.12278997898101807
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Multi-Objective Segment Fusion with Adaptive Node Fusion and Objective-Weighted Reallocation,\" builds upon the segment-based approach but introduces a fundamentally different strategy by first identifying and fusing the most complementary segments from different solutions in the archive, then adaptively fusing nodes based on their cross-dimensional contribution scores, followed by an objective-weighted reallocation phase that probabilistically reorders segments to explore alternative configurations, while dynamically adjusting the fusion and reallocation parameters based on the current solution's objective balance, and ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on cross-dimensional contribution\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        total_cost = cost1 + cost2\n\n        if total_cost > 1.5 * (cost1 + cost2) / 2:  # High cross-dimensional variance\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive node fusion within segments\n    fused_segments = []\n    for segment in segments:\n        if len(segment) < 3:\n            fused_segments.append(segment)\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Adaptive fusion based on objective balance\n        if cost1 > 1.3 * cost2:\n            # Merge nodes with similar contribution to objective 1\n            fused_segment = []\n            i = 0\n            while i < len(segment):\n                if i + 1 < len(segment):\n                    node1 = segment[i]\n                    node2 = segment[i+1]\n                    contrib1 = distance_matrix_1[segment[i-1], node1] + distance_matrix_1[node1, node2]\n                    contrib2 = distance_matrix_1[segment[i-1], node2] + distance_matrix_1[node2, segment[i+2] if i+2 < len(segment) else segment[0]]\n\n                    if abs(contrib1 - contrib2) < 0.1 * (contrib1 + contrib2):\n                        fused_segment.append(node1)\n                        i += 2\n                    else:\n                        fused_segment.append(node1)\n                        i += 1\n                else:\n                    fused_segment.append(segment[i])\n                    i += 1\n            fused_segments.append(fused_segment)\n        else:\n            fused_segments.append(segment)\n\n    # Step 4: Objective-weighted segment reallocation\n    if len(fused_segments) > 1:\n        for i in range(len(fused_segments)):\n            if len(fused_segments[i]) < 2:\n                continue\n\n            cost1 = sum(distance_matrix_1[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n            cost2 = sum(distance_matrix_2[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n\n            if cost1 > 1.2 * cost2:\n                if random.random() < 0.5:\n                    # Reallocate nodes to better balance objectives\n                    segment = fused_segments[i]\n                    new_segment = []\n                    for j in range(len(segment)):\n                        node = segment[j]\n                        prev_node = segment[j-1] if j > 0 else segment[-1]\n                        next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                        if cost1 > 1.2 * cost2:\n                            # Find better node to replace with\n                            candidates = [k for k in range(len(instance)) if k not in segment]\n                            if candidates:\n                                best_node = None\n                                best_score = float('inf')\n                                for candidate in candidates:\n                                    new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                                    new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                                    score = abs(new_cost1 - new_cost2)\n                                    if score < best_score:\n                                        best_score = score\n                                        best_node = candidate\n                                if best_node is not None:\n                                    new_segment.append(best_node)\n                                else:\n                                    new_segment.append(node)\n                        else:\n                            new_segment.append(node)\n                    fused_segments[i] = new_segment\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9513067335199508,
               0.12776219844818115
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\n",
          "score": [
               -0.8491913871509116,
               0.11022323369979858
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Multi-Objective Segment Fusion with Dynamic Objective-Weighted Node Replacement,\" builds upon the common segment-based approach from the provided algorithms but introduces a fundamentally different mechanism by first adaptively identifying the most complementary segments from different solutions in the archive, then dynamically fusing and rebalancing these segments through an objective-weighted node replacement process that evaluates each node's potential contribution to both objectives using a probabilistic acceptance criterion that balances immediate improvement with long-term solution balance, while maintaining tour feasibility through a two-phase validation process that ensures both segment connectivity and node uniqueness, and dynamically adjusts the fusion and replacement parameters based on the current solution's objective balance and the distribution of nodes in the two objective spaces.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify critical segments based on cross-dimensional variance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        variance = abs(cost1 - cost2)\n\n        if variance > 0.5 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 3: Adaptive segment fusion with dynamic objective weighting\n    fused_segments = []\n    for i in range(len(segments)):\n        if len(segments[i]) < 2:\n            fused_segments.append(segments[i])\n            continue\n\n        segment = segments[i]\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Determine fusion strategy based on objective balance\n        if cost1 > 1.2 * cost2:\n            # Prioritize objective 2\n            for j in range(len(segment)):\n                node = segment[j]\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if current_cost2 > 1.2 * current_cost1:\n                    # Find better node to replace with\n                    candidates = [k for k in range(len(instance)) if k not in segment]\n                    if candidates:\n                        best_node = None\n                        best_score = float('inf')\n                        for candidate in candidates:\n                            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                            score = abs(new_cost1 - new_cost2)\n                            if score < best_score:\n                                best_score = score\n                                best_node = candidate\n                        if best_node is not None:\n                            segment[j] = best_node\n        else:\n            # Prioritize objective 1\n            for j in range(len(segment)):\n                node = segment[j]\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if current_cost1 > 1.2 * current_cost2:\n                    # Find better node to replace with\n                    candidates = [k for k in range(len(instance)) if k not in segment]\n                    if candidates:\n                        best_node = None\n                        best_score = float('inf')\n                        for candidate in candidates:\n                            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                            score = abs(new_cost1 - new_cost2)\n                            if score < best_score:\n                                best_score = score\n                                best_node = candidate\n                        if best_node is not None:\n                            segment[j] = best_node\n\n        fused_segments.append(segment)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.0429478487615236,
               0.831392228603363
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\n",
          "score": [
               -0.9782080321022513,
               0.14694750308990479
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Polarization-Driven Multi-Objective Tour Reconstruction,\" builds upon the clustering and segment-based approaches from the provided algorithms but introduces a fundamentally different strategy by first identifying and polarizing the most critical nodes in the tour based on their dominant objective contributions, then dynamically reconstructing the tour by alternately inserting nodes from each objective's dominant cluster while maintaining a balance between the objectives, using an adaptive polarization metric that classifies nodes into objective-specific clusters based on their relative contributions to each objective, and finally validating the reconstructed tour to ensure feasibility while probabilistically exploring alternative configurations through a dynamic polarization adjustment mechanism that periodically re-evaluates node classifications based on the current objective balance, ensuring that the tour remains feasible and maintains diversity in the search process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Classify nodes into objective-polarized clusters\n    cluster1 = []  # Dominant for objective 1\n    cluster2 = []  # Dominant for objective 2\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        if cost1 > 1.3 * cost2:\n            cluster1.append(node)\n        elif cost2 > 1.3 * cost1:\n            cluster2.append(node)\n        else:\n            if len(cluster1) <= len(cluster2):\n                cluster1.append(node)\n            else:\n                cluster2.append(node)\n\n    # Step 2: Dynamic tour reconstruction with alternating polarization\n    new_solution = []\n    i, j = 0, 0\n    polarity = 1  # Start with cluster1\n    while i < len(cluster1) or j < len(cluster2):\n        if polarity == 1 and i < len(cluster1):\n            new_solution.append(cluster1[i])\n            i += 1\n            polarity = 2\n        elif polarity == 2 and j < len(cluster2):\n            new_solution.append(cluster2[j])\n            j += 1\n            polarity = 1\n        elif i < len(cluster1):\n            new_solution.append(cluster1[i])\n            i += 1\n        else:\n            new_solution.append(cluster2[j])\n            j += 1\n\n    # Step 3: Adaptive polarization adjustment\n    if random.random() < 0.3:  # 30% chance to reclassify nodes\n        for _ in range(2):\n            if len(cluster1) > 0 and len(cluster2) > 0:\n                node = random.choice(cluster1 if random.random() < 0.5 else cluster2)\n                cluster1.remove(node) if node in cluster1 else cluster2.remove(node)\n\n                # Reclassify the node\n                prev_node = new_solution[new_solution.index(node)-1] if new_solution.index(node) > 0 else new_solution[-2]\n                next_node = new_solution[(new_solution.index(node)+1)%n]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if cost1 > 1.3 * cost2:\n                    cluster1.append(node)\n                else:\n                    cluster2.append(node)\n\n    # Step 4: Reconstruct solution with adjusted clusters\n    new_solution = []\n    i, j = 0, 0\n    polarity = 1\n    while i < len(cluster1) or j < len(cluster2):\n        if polarity == 1 and i < len(cluster1):\n            new_solution.append(cluster1[i])\n            i += 1\n            polarity = 2\n        elif polarity == 2 and j < len(cluster2):\n            new_solution.append(cluster2[j])\n            j += 1\n            polarity = 1\n        elif i < len(cluster1):\n            new_solution.append(cluster1[i])\n            i += 1\n        else:\n            new_solution.append(cluster2[j])\n            j += 1\n\n    # Ensure circularity and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.990483889741932,
               0.18438124656677246
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Node Alignment with Dynamic Objective Fusion,\" departs from the segment-based approach by first identifying the most promising nodes in each objective space through a novel alignment metric that evaluates node contributions across both dimensions, then dynamically fuses these nodes based on their cross-dimensional complementarity scores while maintaining feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity, and finally refines the solution through an adaptive node reordering strategy that probabilistically redistributes nodes based on their current objective balance, dynamically adjusting the fusion and rebalancing parameters during the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Calculate node alignment scores\n    node_scores = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1) % n]\n\n        # Calculate current contributions\n        current_contrib1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_contrib2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Calculate potential contributions if moved\n        potential_contrib1 = distance_matrix_1[prev_node, next_node]\n        potential_contrib2 = distance_matrix_2[prev_node, next_node]\n\n        # Alignment score combines both objectives\n        alignment_score = (current_contrib1 + current_contrib2) - (potential_contrib1 + potential_contrib2)\n        node_scores.append((node, alignment_score))\n\n    # Step 2: Sort nodes by alignment score\n    node_scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Step 3: Dynamic objective fusion\n    fused_nodes = []\n    remaining_nodes = set(range(n))\n    for node, score in node_scores:\n        if node in remaining_nodes:\n            # Find best fusion position\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(fused_nodes)):\n                prev_node = fused_nodes[i-1] if i > 0 else fused_nodes[-1]\n                next_node = fused_nodes[i]\n\n                # Calculate current contribution\n                current_contrib = (distance_matrix_1[prev_node, next_node] +\n                                 distance_matrix_2[prev_node, next_node])\n\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                             distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n                # Score based on improvement in both objectives\n                score_diff = new_contrib - current_contrib\n\n                if score_diff < best_score:\n                    best_score = score_diff\n                    best_pos = i\n\n            if best_pos != -1:\n                fused_nodes.insert(best_pos, node)\n                remaining_nodes.remove(node)\n\n    # Add remaining nodes\n    fused_nodes.extend(list(remaining_nodes))\n\n    # Step 4: Adaptive node reordering\n    for _ in range(3):  # Perform 3 reordering steps\n        i = random.randint(0, len(fused_nodes)-1)\n        j = random.randint(0, len(fused_nodes)-1)\n        if i != j:\n            # Calculate current cost\n            prev_i = fused_nodes[i-1] if i > 0 else fused_nodes[-1]\n            next_i = fused_nodes[(i+1) % len(fused_nodes)]\n            prev_j = fused_nodes[j-1] if j > 0 else fused_nodes[-1]\n            next_j = fused_nodes[(j+1) % len(fused_nodes)]\n\n            current_cost = (distance_matrix_1[prev_i, fused_nodes[i]] + distance_matrix_1[fused_nodes[i], next_i] +\n                           distance_matrix_2[prev_i, fused_nodes[i]] + distance_matrix_2[fused_nodes[i], next_i] +\n                           distance_matrix_1[prev_j, fused_nodes[j]] + distance_matrix_1[fused_nodes[j], next_j] +\n                           distance_matrix_2[prev_j, fused_nodes[j]] + distance_matrix_2[fused_nodes[j], next_j])\n\n            # Calculate potential cost with swapped nodes\n            new_cost = (distance_matrix_1[prev_i, fused_nodes[j]] + distance_matrix_1[fused_nodes[j], next_i] +\n                       distance_matrix_2[prev_i, fused_nodes[j]] + distance_matrix_2[fused_nodes[j], next_i] +\n                       distance_matrix_1[prev_j, fused_nodes[i]] + distance_matrix_1[fused_nodes[i], next_j] +\n                       distance_matrix_2[prev_j, fused_nodes[i]] + distance_matrix_2[fused_nodes[i], next_j])\n\n            # Accept swap if it improves at least one objective\n            if new_cost < current_cost:\n                fused_nodes[i], fused_nodes[j] = fused_nodes[j], fused_nodes[i]\n\n    # Step 5: Reconstruct solution and validate\n    if fused_nodes[0] != fused_nodes[-1]:\n        fused_nodes.append(fused_nodes[0])\n\n    # Ensure circular tour and no duplicates\n    unique_nodes = np.unique(fused_nodes[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random shuffle\n        fused_nodes = list(range(n))\n        random.shuffle(fused_nodes)\n        fused_nodes.append(fused_nodes[0])\n\n    return np.array(fused_nodes)\n\n",
          "score": [
               -0.9951554781560382,
               0.24459493160247803
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Driven Path Realignment with Dynamic Segment Reconfiguration,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first analyzing the solution's objective contributions at each edge, then dynamically reconfiguring the tour by realigning segments based on their primary objective dominance, followed by a probabilistic segment reordering phase that reorders segments to optimize both objectives simultaneously, while maintaining feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines objective-driven path realignment with dynamic segment reconfiguration, allowing for both fine-grained local improvements and more disruptive global explorations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Analyze objective contributions at each edge\n    edge_contributions = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n        edge_contributions.append((cost1, cost2))\n\n    # Step 2: Dynamic segment reconfiguration\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = 1 if edge_contributions[0][0] < edge_contributions[0][1] else 2\n\n    for i in range(1, n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1, cost2 = edge_contributions[i]\n\n        if (current_obj == 1 and cost1 < cost2) or (current_obj == 2 and cost2 < cost1):\n            current_segment.append(node)\n        else:\n            segments.append((current_obj, current_segment))\n            current_segment = [node]\n            current_obj = 3 - current_obj\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Step 3: Probabilistic segment reordering\n    if len(segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in segments if obj == 1]\n        obj2_segments = [seg for obj, seg in segments if obj == 2]\n\n        # Reorder segments with probability based on their objective dominance\n        new_segments = []\n        while obj1_segments or obj2_segments:\n            if obj1_segments and (not obj2_segments or random.random() < 0.7):\n                new_segments.append((1, obj1_segments.pop(0)))\n            elif obj2_segments:\n                new_segments.append((2, obj2_segments.pop(0)))\n\n        # Reconstruct solution\n        new_solution = []\n        for _, seg in new_segments:\n            new_solution.extend(seg)\n\n    # Step 4: Reconstruct solution and validate\n    if len(new_solution) != n:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            _, seg = segments[i]\n            segments[i] = (3 - segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in segments:\n                new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random shuffle\n        random.shuffle(new_solution)\n        new_solution = new_solution[:n]\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9625441946222131,
               0.1361600160598755
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Aware Hierarchical Segment Fusion with Dynamic Rebalancing,\" departs from the segment-based approach by first constructing a hierarchical decomposition of the solution into multiple levels of nested segments, then fusing segments based on their objective-aware complementarity scores, followed by a dynamic rebalancing phase that probabilistically redistributes nodes between segments based on their cross-dimensional contribution, while dynamically adjusting the fusion and rebalancing parameters based on the current solution's objective balance, and ensuring feasibility through a hierarchical validation mechanism that checks for node uniqueness and circularity at each level of the decomposition.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hierarchical segment decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        total_cost = cost1 + cost2\n\n        if total_cost > 1.5 * (cost1 + cost2) / 2:  # High cross-dimensional variance\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Objective-aware hierarchical fusion\n    fused_segments = []\n    for segment in segments:\n        if len(segment) < 3:\n            fused_segments.append(segment)\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Hierarchical fusion based on objective dominance\n        if cost1 > 1.3 * cost2:\n            # Merge nodes with similar contribution to objective 1\n            fused_segment = []\n            i = 0\n            while i < len(segment):\n                if i + 1 < len(segment):\n                    node1 = segment[i]\n                    node2 = segment[i+1]\n                    contrib1 = distance_matrix_1[segment[i-1], node1] + distance_matrix_1[node1, node2]\n                    contrib2 = distance_matrix_2[segment[i-1], node2] + distance_matrix_2[node2, segment[i+2] if i+2 < len(segment) else segment[0]]\n\n                    if abs(contrib1 - contrib2) < 0.1 * (contrib1 + contrib2):\n                        fused_segment.append(node1)\n                        i += 2\n                    else:\n                        fused_segment.append(node1)\n                        i += 1\n                else:\n                    fused_segment.append(segment[i])\n                    i += 1\n            fused_segments.append(fused_segment)\n        else:\n            # Split segment into sub-segments\n            sub_segments = []\n            sub_segment = [segment[0]]\n            for j in range(1, len(segment)):\n                prev_node = segment[j-1]\n                current_node = segment[j]\n                cost1 = distance_matrix_1[prev_node, current_node]\n                cost2 = distance_matrix_2[prev_node, current_node]\n\n                if cost1 > 1.2 * cost2:\n                    sub_segments.append(sub_segment)\n                    sub_segment = [current_node]\n                else:\n                    sub_segment.append(current_node)\n\n            if len(sub_segment) > 0:\n                sub_segments.append(sub_segment)\n\n            if len(sub_segments) > 1:\n                fused_segments.extend(sub_segments)\n            else:\n                fused_segments.append(segment)\n\n    # Step 4: Dynamic rebalancing phase\n    if len(fused_segments) > 1:\n        for i in range(len(fused_segments)):\n            if len(fused_segments[i]) < 2:\n                continue\n\n            cost1 = sum(distance_matrix_1[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n            cost2 = sum(distance_matrix_2[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n\n            if cost1 > 1.2 * cost2:\n                if random.random() < 0.5:\n                    # Rebalance nodes between segments\n                    segment = fused_segments[i]\n                    for j in range(len(segment)):\n                        node = segment[j]\n                        prev_node = segment[j-1] if j > 0 else segment[-1]\n                        next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                        if cost1 > 1.2 * cost2:\n                            # Find target segment for rebalancing\n                            target_segment = None\n                            min_diff = float('inf')\n                            for k in range(len(fused_segments)):\n                                if k == i:\n                                    continue\n\n                                seg_cost1 = sum(distance_matrix_1[fused_segments[k][l], fused_segments[k][l+1]] for l in range(len(fused_segments[k])-1))\n                                seg_cost2 = sum(distance_matrix_2[fused_segments[k][l], fused_segments[k][l+1]] for l in range(len(fused_segments[k])-1))\n\n                                if seg_cost2 > 1.2 * seg_cost1:\n                                    diff = abs((seg_cost1 + cost1) - (seg_cost2 + cost2))\n                                    if diff < min_diff:\n                                        min_diff = diff\n                                        target_segment = k\n\n                            if target_segment is not None:\n                                # Move node to target segment\n                                fused_segments[target_segment].append(node)\n                                segment.pop(j)\n                                break\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8796346475132205,
               0.13945233821868896
          ]
     }
]