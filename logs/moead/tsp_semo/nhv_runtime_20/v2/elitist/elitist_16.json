[
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8658723702355473,
            0.5310291647911072
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel multi-objective local search strategy that combines adaptive segment reversal with objective-aware edge selection, dynamically balancing improvements in both objective spaces while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1/(obj[0] + obj[1] + 1) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment selection based on both objectives\n    segment_length = max(2, min(5, int(n * 0.2)))  # Dynamic segment length\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment costs\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Objective-aware edge selection\n    best_improvement = 0\n    best_pos = -1\n    best_reversed = False\n\n    for pos in range(n - segment_length + 1):\n        if abs(pos - a) < segment_length:\n            continue  # Skip overlapping segments\n\n        # Try both original and reversed segment\n        for reverse in [False, True]:\n            temp_segment = segment[::-1] if reverse else segment.copy()\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[pos-1], new_solution[pos]) if pos > 0 else None,\n                (new_solution[pos+segment_length-1], new_solution[(pos+segment_length)%n]) if pos+segment_length < n else None\n            ]\n            new_edges = [\n                (new_solution[pos-1], temp_segment[0]) if pos > 0 else None,\n                (temp_segment[-1], new_solution[(pos+segment_length)%n]) if pos+segment_length < n else None\n            ]\n\n            improvement1 = sum(\n                (distance_matrix_1[new[0], new[1]] - distance_matrix_1[old[0], old[1]])\n                for old, new in zip(old_edges, new_edges) if old is not None\n            )\n            improvement2 = sum(\n                (distance_matrix_2[new[0], new[1]] - distance_matrix_2[old[0], old[1]])\n                for old, new in zip(old_edges, new_edges) if old is not None\n            )\n\n            # Weighted improvement considering both objectives\n            total_improvement = (improvement1 + improvement2) / (current_obj[0] + current_obj[1] + 1e-6)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n                best_reversed = reverse\n\n    if best_pos != -1:\n        # Apply the best segment insertion/reversal\n        segment = segment[::-1] if best_reversed else segment\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos+segment_length:]\n        ])\n    else:\n        # Fallback: perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[j:k+1],\n            new_solution[i:j],\n            new_solution[k+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9654613740490084,
            0.1676921248435974
        ]
    },
    {
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic path reversal operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a path reversal operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Check if the reversed segment is better in both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        # Apply the reversed segment\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If not better, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9980483187816847,
            0.20924699306488037
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective selection criterion with a dynamic node insertion operator, prioritizing nodes with high potential for cost reduction in both objective spaces while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards better solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to remove and reinsert\n    node_to_remove = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_remove]\n\n    # Create a temporary solution without the removed node\n    temp_solution = np.delete(new_solution, node_to_remove)\n\n    # Find the best insertion point for the removed node\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(temp_solution, pos, removed_node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_obj1 and new_cost2 < current_obj2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n        # If not better in both, check if it's better in at least one objective\n        elif new_cost1 < current_obj1 or new_cost2 < current_obj2:\n            if (new_cost1 + new_cost2) < (best_cost1 + best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n        # Revert the insertion\n        temp_solution = np.delete(temp_solution, pos)\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(temp_solution, best_insert_pos, removed_node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.863852762782875,
            0.08395695686340332
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Dynamic segment exchange\n    n = len(new_solution)\n    segment_size = random.randint(2, min(5, n // 2))  # Random segment size between 2 and 5 or n/2\n\n    # Select two non-overlapping segments\n    a = random.randint(0, n - segment_size)\n    b = random.randint(0, n - segment_size)\n    while abs(a - b) < segment_size:  # Ensure segments don't overlap\n        b = random.randint(0, n - segment_size)\n\n    # Extract segments\n    segment1 = new_solution[a:a+segment_size]\n    segment2 = new_solution[b:b+segment_size]\n\n    # Calculate segment costs\n    def segment_cost(seg, dist_matrix):\n        cost = 0\n        for i in range(len(seg)):\n            cost += dist_matrix[seg[i], seg[(i+1)%len(seg)]]\n        return cost\n\n    cost1_seg1 = segment_cost(segment1, distance_matrix_1)\n    cost2_seg1 = segment_cost(segment1, distance_matrix_2)\n    cost1_seg2 = segment_cost(segment2, distance_matrix_1)\n    cost2_seg2 = segment_cost(segment2, distance_matrix_2)\n\n    # Calculate potential improvement\n    improvement1 = (cost1_seg1 + cost1_seg2) - (distance_matrix_1[segment1[-1], segment2[0]] + distance_matrix_1[segment2[-1], segment1[0]])\n    improvement2 = (cost2_seg1 + cost2_seg2) - (distance_matrix_2[segment1[-1], segment2[0]] + distance_matrix_2[segment2[-1], segment1[0]])\n\n    # Apply exchange if beneficial in both objectives\n    if improvement1 > 0 and improvement2 > 0:\n        # Swap segments\n        new_solution[a:a+segment_size] = segment2\n        new_solution[b:b+segment_size] = segment1\n    else:\n        # Perform random 2-opt if no improvement found\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6917347359343206,
            0.052630722522735596
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    }
]