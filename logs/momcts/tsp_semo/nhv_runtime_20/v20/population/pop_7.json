[
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the lowest combined objective value) and applies a novel 4-opt-inspired local search by randomly selecting four edges and reconnecting them in a non-standard way to explore higher-quality neighborhoods, ensuring feasibility by reversing segments and maintaining a circular tour. The key design idea is to prioritize the most promising solution while introducing diversity through a creative edge-reconnection strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[l:j+1][::-1],\n        new_solution[k:l+1][::-1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9964296678185147,
            0.10547882318496704
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective) and applies a novel 4-opt-inspired local search by randomly selecting four edges, reversing segments between them, and reconnecting them to explore a larger neighborhood while ensuring feasibility. It prioritizes solutions with lower total cost and dynamically modifies the tour by segment reversal and concatenation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        new_solution[b:c+1][::-1],\n        new_solution[d:],\n        new_solution[a+1:b+1][::-1],\n        new_solution[c+1:d+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9715020941909596,
            0.14212608337402344
        ]
    },
    {
        "algorithm": "The heuristic selects the solution with the highest combined objective value from the archive, then applies a novel 3-opt-inspired local search by randomly selecting three edges and reconnecting them in a way that maintains feasibility while exploring higher-quality neighborhoods. The algorithm prioritizes solutions with worse combined objectives (sum of both costs) to focus on less explored regions, and ensures the generated neighbor remains a valid TSP tour by reversing segments of the path and reconnecting them.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 3-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[j:k+1][::-1],\n        new_solution[k+1:],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.8796892138585624,
            0.27913469076156616
        ]
    },
    {
        "algorithm": "The algorithm prioritizes nondominated solutions from the archive, dynamically selects segments based on objective diversity, and employs a hybrid local search combining adaptive segment reversals and edge swaps to generate improved neighbor solutions while ensuring feasibility. It focuses on regions of the Pareto front with high improvement potential by evaluating edge swaps in both objective spaces and dynamically adjusting segment sizes. The selection of segments and edges is guided by a diversity metric, and the algorithm maintains a circular tour by ensuring the neighbor solution remains a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select a solution based on objective diversity\n    objectives = np.array([obj for _, obj in nondominated])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective diversity\n    segment_size = max(2, int(np.ceil(n * 0.1 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Hybrid local search: adaptive segment reversal and edge swaps\n    if np.random.rand() < 0.5:\n        # Reverse segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        # Swap edges\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Edge selection based on objective improvement\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 <= old_cost2) or (new_cost1 <= old_cost1 and new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9470726877155471,
            1.2816454768180847
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search: first reversing a random segment of the tour (like 2-opt) and then rotating the segment to explore a more diverse neighborhood while ensuring feasibility. The selection strategy focuses on high-quality solutions, while the novel local search combines segment reversal and rotation to escape local optima effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment reversal (similar to 2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment rotation: rotate the segment by a random amount\n    k = np.random.randint(1, j-i+1)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7527095184899617,
            0.7415230870246887
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of objectives) and applies a hybrid local search combining edge insertion (moving a node to a new position) and node swapping (exchanging two nodes) to generate a neighbor solution while ensuring feasibility by checking for duplicate nodes. The design prioritizes solutions with lower combined objective values and uses random segment selection to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: edge insertion + node swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge insertion: move a random node to a new position\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node_to_move], new_solution[j+1:]])\n\n    # Node swap: swap two random nodes\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.905185401510344,
            1.402988612651825
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (based on normalized objective scores) and applies a hybrid local search combining 3-opt moves with an edge-selection mechanism. It prioritizes solutions with higher combined objective values and uses random edge modifications to explore neighboring solutions while ensuring feasibility. The edge-selection step evaluates swaps between random edges and the 3-opt segment, accepting improvements in both objectives to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    if np.random.rand() < 0.5:\n        # Case 1: Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Case 2: Reverse segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Edge selection mechanism: choose the best edge to include\n    for _ in range(5):  # Limit iterations to avoid long computation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a == b:\n            continue\n\n        # Evaluate the impact of swapping edges a-b and i-j\n        old_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[i]] + distance_matrix_1[new_solution[b], new_solution[j]]\n\n        old_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[i]] + distance_matrix_2[new_solution[b], new_solution[j]]\n\n        if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n            # Perform the swap\n            new_solution[a], new_solution[i] = new_solution[i], new_solution[a]\n            new_solution[b], new_solution[j] = new_solution[j], new_solution[b]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9267165987309169,
            2.00429505109787
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from an archive using a weighted combination of objectives (70% first objective, 30% second), then applies a hybrid 4-opt local search with probabilistic edge swaps to generate a neighbor solution. It ensures feasibility by validating the tour structure and falls back to the original solution if invalid. The probabilistic edge selection accepts swaps based on improvement potential, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective combination (0.7 for first objective, 0.3 for second)\n    objectives = np.array([obj for _, obj in archive])\n    weighted_scores = 0.7 * objectives[:, 0] + 0.3 * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with probabilistic edge selection\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Apply 4-opt move (randomly choose one of 3 possible segment reversals)\n    move_type = np.random.randint(0, 3)\n    if move_type == 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif move_type == 1:\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Probabilistic edge selection: accept swaps with probability based on improvement\n    for _ in range(3):  # Reduced iterations for efficiency\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a == b:\n            continue\n\n        old_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[i]] + distance_matrix_1[new_solution[b], new_solution[j]]\n\n        old_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[i]] + distance_matrix_2[new_solution[b], new_solution[j]]\n\n        improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n        if improvement > 0 and np.random.rand() < min(1.0, improvement / (old_cost1 + old_cost2)):\n            new_solution[a], new_solution[i] = new_solution[i], new_solution[a]\n            new_solution[b], new_solution[j] = new_solution[j], new_solution[b]\n            break\n\n    # Verify tour is valid (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.898584190995788,
            1.6844857335090637
        ]
    },
    {
        "algorithm": "The algorithm selects a nondominated solution from the archive, applies adaptive segment selection to dynamically adjust segment sizes based on objective diversity, and uses a hybrid edge-selection mechanism to explore high-quality neighborhoods while ensuring feasibility. The selection prioritizes solutions on the Pareto front, while the local search dynamically balances segment size and edge swaps to improve both objectives. The hybrid approach combines segment reversal and edge-based swaps, with a focus on reducing total cost across both spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution (Pareto front)\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j] <= objectives[i]).all():\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.argmin(objectives.sum(axis=1))\n    else:\n        selected_idx = random.choice(nondominated)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Adaptive segment selection based on objective diversity\n    obj_diversity = objectives.std(axis=0).sum()\n    segment_size = max(2, int(obj_diversity / (objectives.max() - objectives.min()).sum() * len(base_solution) / 2))\n\n    # Hybrid local search with dynamic segment size\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to modify\n    i = np.random.randint(0, n - segment_size)\n    j = i + segment_size\n\n    # Reverse segment to explore new neighborhoods\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge selection mechanism with dynamic evaluation\n    for _ in range(min(3, n // 2)):  # Limit iterations for efficiency\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a == b:\n            continue\n\n        # Evaluate the impact of swapping edges\n        old_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[i]] + distance_matrix_1[new_solution[b], new_solution[j]]\n\n        old_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[i]] + distance_matrix_2[new_solution[b], new_solution[j]]\n\n        if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n            # Perform the swap\n            new_solution[a], new_solution[i] = new_solution[i], new_solution[a]\n            new_solution[b], new_solution[j] = new_solution[j], new_solution[b]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8733659506046769,
            9.661152005195618
        ]
    },
    {
        "algorithm": "The algorithm selects high-performing solutions from the archive based on a weighted combination of objectives (60% first objective, 40% second) and applies a hybrid 4-opt local search with probabilistic edge reversals to generate improved neighbor solutions while ensuring feasibility. It evaluates all possible 4-opt configurations and applies the best one that reduces the combined cost, followed by occasional random edge reversals for diversification. The method prioritizes solutions with better weighted objective scores and systematically explores local improvements through constrained perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective score (0.6 for first objective, 0.4 for second)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 4-opt with probabilistic edge reversal\n    for _ in range(3):  # Perform multiple perturbations\n        # Randomly select four distinct edges\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                        distance_matrix_1[new_solution[c], new_solution[(c+1)%n]] +\n                        distance_matrix_1[new_solution[d], new_solution[(d+1)%n]])\n\n        current_cost2 = (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[c], new_solution[(c+1)%n]] +\n                        distance_matrix_2[new_solution[d], new_solution[(d+1)%n]])\n\n        # Consider all possible 4-opt configurations\n        configs = [\n            (a, b, c, d),  # Original\n            (a, c, b, d),  # Swap b and c\n            (a, b, d, c),  # Swap c and d\n            (a, d, b, c),  # Swap b and d\n            (a, d, c, b),  # Swap c and d, then b and d\n            (a, c, d, b)   # Swap b and c, then c and d\n        ]\n\n        best_config = None\n        min_cost = float('inf')\n\n        for config in configs:\n            # Create temporary solution for this configuration\n            temp_sol = new_solution.copy()\n            temp_sol[config[0]], temp_sol[config[1]] = temp_sol[config[1]], temp_sol[config[0]]\n            temp_sol[config[2]], temp_sol[config[3]] = temp_sol[config[3]], temp_sol[config[2]]\n\n            # Calculate new costs\n            new_cost1 = (distance_matrix_1[temp_sol[config[0]], temp_sol[(config[0]+1)%n]] +\n                         distance_matrix_1[temp_sol[config[1]], temp_sol[(config[1]+1)%n]] +\n                         distance_matrix_1[temp_sol[config[2]], temp_sol[(config[2]+1)%n]] +\n                         distance_matrix_1[temp_sol[config[3]], temp_sol[(config[3]+1)%n]])\n\n            new_cost2 = (distance_matrix_2[temp_sol[config[0]], temp_sol[(config[0]+1)%n]] +\n                         distance_matrix_2[temp_sol[config[1]], temp_sol[(config[1]+1)%n]] +\n                         distance_matrix_2[temp_sol[config[2]], temp_sol[(config[2]+1)%n]] +\n                         distance_matrix_2[temp_sol[config[3]], temp_sol[(config[3]+1)%n]])\n\n            total_cost = new_cost1 + new_cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_config = config\n\n        if best_config and min_cost < (current_cost1 + current_cost2):\n            # Apply the best configuration\n            new_solution[best_config[0]], new_solution[best_config[1]] = new_solution[best_config[1]], new_solution[best_config[0]]\n            new_solution[best_config[2]], new_solution[best_config[3]] = new_solution[best_config[3]], new_solution[best_config[2]]\n\n        # Probabilistic edge reversal for diversification\n        if np.random.rand() < 0.3:\n            e1, e2 = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[e1:e2+1] = new_solution[e1:e2+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8673919669903645,
            2.2782323956489563
        ]
    }
]