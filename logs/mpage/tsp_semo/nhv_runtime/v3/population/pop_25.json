[
     {
          "algorithm": "{This new algorithm introduces a hierarchical local search approach that combines a multi-objective-aware node clustering strategy with a novel edge contraction-expansion mechanism. It first identifies clusters of nodes based on their proximity in both objective spaces, then selectively contracts edges between distant clusters while expanding edges within clusters, followed by a probabilistic node reordering that prioritizes edges with balanced distance improvements across objectives. The method incorporates a dynamic cluster size adjustment based on the current solution's objective balance, ensuring exploration of diverse neighborhoods while maintaining feasibility through careful validation and fallback mechanisms.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1]) / (objectives.sum(axis=1) + 1e-6)\n    weights = 1.0 / (obj_balance + 1e-6)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Cluster nodes based on both distance matrices\n    cluster_size = max(3, min(8, n // 3))\n    clusters = []\n    remaining = set(range(n))\n    while remaining:\n        center = np.random.choice(list(remaining))\n        cluster = [center]\n        remaining.remove(center)\n        for _ in range(cluster_size - 1):\n            if not remaining:\n                break\n            closest = min(remaining, key=lambda x: distance_matrix_1[center, x] + distance_matrix_2[center, x])\n            cluster.append(closest)\n            remaining.remove(closest)\n        clusters.append(cluster)\n\n    # Step 3: Edge contraction-expansion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n        # Contract edges between cluster nodes\n        for i in range(len(cluster)):\n            for j in range(i+1, len(cluster)):\n                a, b = cluster[i], cluster[j]\n                if a > b:\n                    a, b = b, a\n                # Check if swapping a and b improves both objectives\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        # Expand edges within cluster\n        for i in range(len(cluster)-1):\n            a, b = cluster[i], cluster[i+1]\n            if a > b:\n                a, b = b, a\n            # Check if moving b after a improves both objectives\n            if b != (a+1)%n:\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    # Move b after a\n                    node = new_solution[b]\n                    new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n                    insert_pos = np.where(new_solution == new_solution[a])[0][0] + 1\n                    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Probabilistic node reordering based on objective balance\n    obj1, obj2 = archive[selected_idx][1]\n    if abs(obj1 - obj2) > 0.2 * (obj1 + obj2):\n        # More aggressive reordering when objectives are unbalanced\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            # Check if swapping segments improves both objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            if delta1 + delta2 < 0:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 5: Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -1.0807467550296899,
               0.6731994152069092
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol_i, obj_i))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Step 2: Select a solution based on objective values and diversity\n    objectives = np.array([obj for _, obj in pareto_front])\n    normalized_obj = objectives / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = []\n    for sol, _ in pareto_front:\n        unique_edges = set()\n        for i in range(len(sol)):\n            unique_edges.add((min(sol[i], sol[(i+1)%len(sol)]), max(sol[i], sol[(i+1)%len(sol)])))\n        diversity_scores.append(len(unique_edges))\n    diversity_scores = np.array(diversity_scores) / (np.max(diversity_scores) + 1e-10)\n\n    selection_scores = 0.7 * (1 - normalized_obj[:, 0]) + 0.3 * diversity_scores\n    selected_idx = np.argmax(selection_scores)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Step 3: Multi-segment crossover operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two random segments from the base solution\n    seg1_start = np.random.randint(0, n)\n    seg1_length = np.random.randint(2, min(4, n//2))\n    seg1_end = (seg1_start + seg1_length) % n\n\n    seg2_start = np.random.randint(0, n)\n    while abs(seg2_start - seg1_start) < 2 or abs(seg2_start - seg1_end) < 2:\n        seg2_start = np.random.randint(0, n)\n    seg2_length = np.random.randint(2, min(4, n//2))\n    seg2_end = (seg2_start + seg2_length) % n\n\n    # Extract segments\n    if seg1_start < seg1_end:\n        seg1 = new_solution[seg1_start:seg1_end]\n    else:\n        seg1 = np.concatenate([new_solution[seg1_start:], new_solution[:seg1_end]])\n\n    if seg2_start < seg2_end:\n        seg2 = new_solution[seg2_start:seg2_end]\n    else:\n        seg2 = np.concatenate([new_solution[seg2_start:], new_solution[:seg2_end]])\n\n    # Select a third segment from another solution in the archive\n    other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n    seg3_start = np.random.randint(0, n)\n    seg3_length = np.random.randint(2, min(4, n//2))\n    seg3_end = (seg3_start + seg3_length) % n\n\n    if seg3_start < seg3_end:\n        seg3 = other_sol[seg3_start:seg3_end]\n    else:\n        seg3 = np.concatenate([other_sol[seg3_start:], other_sol[:seg3_end]])\n\n    # Combine segments to form new solution\n    remaining_nodes = set(range(n)) - set(seg1) - set(seg2) - set(seg3)\n    new_solution = np.concatenate([seg1, seg2, seg3, np.array(list(remaining_nodes))])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0059111292081795,
               0.346810519695282
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a novel \"objective-balanced path inversion\" strategy that first selects a solution from the archive based on a combined objective score, then dynamically partitions the tour into balanced segments where each segment's length is determined by the harmonic mean of the segment's individual objective costs, followed by a probabilistic inversion of these segments with a probability inversely proportional to their objective balance, while maintaining feasibility through careful segment boundary tracking and a fallback mechanism that ensures connectivity by reinserting any disconnected segments back into the tour, all while incorporating a dynamic objective weighting that adapts to the archive's current non-dominated front to guide the search toward more balanced solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic segment partitioning based on objective balance\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        cost1 = distance_matrix_1[current_segment[-1], node]\n        cost2 = distance_matrix_2[current_segment[-1], node]\n\n        # Calculate segment length based on harmonic mean\n        if cost1 + cost2 > 0:\n            segment_length = 2 * cost1 * cost2 / (cost1 + cost2 + 1e-6)\n        else:\n            segment_length = 1\n\n        if len(current_segment) < segment_length:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Probabilistic segment inversion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n\n        # Calculate segment's objective balance\n        seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        balance = abs(seg_cost1 - seg_cost2) / (seg_cost1 + seg_cost2 + 1e-6)\n\n        # Inversion probability inversely proportional to balance\n        if np.random.random() < 1.0 / (balance + 1e-6):\n            seg.reverse()\n\n    # Reconstruct solution from segments\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(new_solution) != n + 1 or len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.0044415389105121,
               0.0769835114479065
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a \"multi-objective tour decomposition and recombination\" strategy that first selects a solution from the archive based on a novel \"objective diversity metric\" which prioritizes solutions with unbalanced improvements in either objective, then decomposes the tour into overlapping segments using a \"dual-objective segment clustering\" approach that groups nodes based on their connection costs in both objectives, followed by a \"probabilistic segment merging and splitting\" process that intelligently combines and divides segments while incorporating a \"cross-objective segment transposition\" mechanism that moves segments between different positions in the tour based on their potential to improve the underperforming objective, with the recombination decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment transposition if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_diversity)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition based on both objectives\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate segment properties\n        if len(current_segment) > 1:\n            # Average costs in current segment\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n\n            # Variance in connection costs\n            var_cost1 = np.var([distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n            var_cost2 = np.var([distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n        else:\n            avg_cost1 = avg_cost2 = var_cost1 = var_cost2 = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or (var_cost1 > 0.3 or var_cost2 > 0.3) or len(current_segment) >= 5:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Segment transformation with objective awareness\n    transformed_segments = []\n    for segment in segments:\n        if len(segment) > 2:\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Decide transformation based on objective balance\n            if seg_cost1 > seg_cost2:\n                # Improve objective 1 by reversing segment\n                transformed_segments.append(segment[::-1])\n            else:\n                # Improve objective 2 by rotating segment\n                rotation = np.random.randint(1, len(segment))\n                transformed_segments.append(segment[rotation:] + segment[:rotation])\n        else:\n            transformed_segments.append(segment)\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in transformed_segments:\n        new_solution.extend(segment)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple inversion of a random segment\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9342277012596714,
               0.0691184401512146
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a \"multi-objective tour decomposition and recombination\" strategy that first selects a solution from the archive based on a novel \"objective diversity metric\" which prioritizes solutions with unbalanced improvements in either objective, then decomposes the tour into overlapping segments using a \"dual-objective segment clustering\" approach that groups nodes based on their connection costs in both objectives, followed by a \"probabilistic segment merging and splitting\" process that intelligently combines and divides segments while incorporating a \"cross-objective segment transposition\" mechanism that moves segments between different positions in the tour based on their potential to improve the underperforming objective, with the recombination decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment transposition if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition based on both objectives\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate segment properties\n        if len(current_segment) > 1:\n            # Average costs in current segment\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n\n            # Variance in connection costs\n            var_cost1 = np.var([distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n            var_cost2 = np.var([distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n        else:\n            avg_cost1 = avg_cost2 = var_cost1 = var_cost2 = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or (var_cost1 > 0.3 or var_cost2 > 0.3) or len(current_segment) >= 5:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Segment transformation with objective awareness\n    transformed_segments = []\n    for segment in segments:\n        if len(segment) > 2:\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Decide transformation based on objective balance\n            if seg_cost1 > seg_cost2:\n                # Improve objective 1 by reversing segment\n                transformed_segments.append(segment[::-1])\n            else:\n                # Improve objective 2 by rotating segment\n                rotation = np.random.randint(1, len(segment))\n                transformed_segments.append(segment[rotation:] + segment[:rotation])\n        else:\n            transformed_segments.append(segment)\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in transformed_segments:\n        new_solution.extend(segment)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple inversion of a random segment\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9483890474490249,
               0.07203096151351929
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a \"multi-objective tour decomposition and recombination\" strategy that first selects a solution from the archive based on a novel \"objective diversity metric\" which prioritizes solutions with unbalanced improvements in either objective, then decomposes the tour into overlapping segments using a \"dual-objective segment clustering\" approach that groups nodes based on their connection costs in both objectives, followed by a \"probabilistic segment merging and splitting\" process that intelligently combines and divides segments while incorporating a \"cross-objective segment transposition\" mechanism that moves segments between different positions in the tour based on their potential to improve the underperforming objective, with the recombination decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment transposition if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition based on both objectives\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate segment properties\n        if len(current_segment) > 1:\n            # Average costs in current segment\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n\n            # Variance in connection costs\n            var_cost1 = np.var([distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n            var_cost2 = np.var([distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n        else:\n            avg_cost1 = avg_cost2 = var_cost1 = var_cost2 = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or (var_cost1 > 0.3 or var_cost2 > 0.3) or len(current_segment) >= 5:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Segment transformation with objective awareness\n    transformed_segments = []\n    for segment in segments:\n        if len(segment) > 2:\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Decide transformation based on objective balance\n            if seg_cost1 > seg_cost2:\n                # Improve objective 1 by reversing segment\n                transformed_segments.append(segment[::-1])\n            else:\n                # Improve objective 2 by rotating segment\n                rotation = np.random.randint(1, len(segment))\n                transformed_segments.append(segment[rotation:] + segment[:rotation])\n        else:\n            transformed_segments.append(segment)\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in transformed_segments:\n        new_solution.extend(segment)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple inversion of a random segment\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8824402291463871,
               0.0700879693031311
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a \"multi-objective tour restructuring and hybrid segment fusion\" strategy that first selects a solution from the archive based on a novel \"objective correlation metric\" which prioritizes solutions where the improvement directions in both objectives are highly correlated, then decomposes the tour into variable-length segments using a \"dual-objective segment fusion\" approach that intelligently merges adjacent nodes when their connection costs in both objectives show strong positive correlation, followed by a \"probabilistic segment reordering and inversion\" process that reorders segments based on their potential to improve the underperforming objective while considering the correlation between objectives, with the reordering decisions guided by a weighted combination of segment-specific costs, their objective-specific connection potential, and the correlation between the objectives, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment reordering if the solution becomes invalid, incorporating a \"correlation-aware segment inversion\" mechanism that inverts segments when the correlation between objectives in the segment is negative, to potentially improve both objectives simultaneously.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective correlation\n    objectives = np.array([obj for _, obj in archive])\n    correlation = np.corrcoef(objectives[:, 0], objectives[:, 1])[0, 1]\n    if correlation > 0.5:\n        selected_idx = np.argmax(np.abs(objectives[:, 0] - objectives[:, 1]))\n    else:\n        selected_idx = np.argmin(np.abs(objectives[:, 0] - objectives[:, 1]))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dual-objective segment fusion\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate correlation in current segment\n        if len(current_segment) > 1:\n            seg_costs1 = [distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)]\n            seg_costs2 = [distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)]\n            seg_correlation = np.corrcoef(seg_costs1, seg_costs2)[0, 1]\n        else:\n            seg_correlation = 0\n\n        # Decide whether to merge with current segment\n        if seg_correlation > 0.7 or len(current_segment) >= 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n    segments.append(current_segment)\n\n    # Probabilistic segment reordering and inversion\n    if len(segments) > 1:\n        # Calculate current objectives\n        obj1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1))\n        obj2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1))\n        obj_balance = obj1 - obj2\n\n        # Calculate segment properties\n        segment_props = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_corr = np.corrcoef(\n                [distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1)],\n                [distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1)]\n            )[0, 1]\n            segment_props.append((seg_cost1, seg_cost2, seg_corr))\n\n        # Reorder segments\n        if obj_balance > 0:  # Objective 1 is worse\n            # Sort segments by potential to improve objective 1 (considering correlation)\n            segments_sorted = sorted(\n                range(len(segments)),\n                key=lambda i: segment_props[i][0] - (0.5 * segment_props[i][2] * segment_props[i][1])\n            )\n            new_order = segments_sorted\n        else:  # Objective 2 is worse\n            # Sort segments by potential to improve objective 2 (considering correlation)\n            segments_sorted = sorted(\n                range(len(segments)),\n                key=lambda i: segment_props[i][1] - (0.5 * segment_props[i][2] * segment_props[i][0])\n            )\n            new_order = segments_sorted\n\n        # Invert segments with negative correlation\n        for i in range(len(segments)):\n            if segment_props[i][2] < -0.3:\n                segments[i] = segments[i][::-1]\n\n        # Apply new order\n        new_segments = [segments[i] for i in new_order]\n        new_solution = []\n        for seg in new_segments:\n            new_solution.extend(seg)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple segment reordering\n        np.random.shuffle(segments)\n        new_solution = []\n        for seg in segments:\n            new_solution.extend(seg)\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.053888153118009,
               1.1229557991027832
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search operations by combining a novel segment permutation strategy with a dynamic edge reassembly mechanism. It first selects a solution from the archive using a diversity-aware selection mechanism that prioritizes solutions with high variance in objective improvements, then applies a hybrid local search that involves permuting a randomly selected segment using a custom permutation pattern and inserting it into a different position in the tour, while also performing a dynamic edge reassembly operation that reconstructs edges between non-adjacent segments based on a probabilistic model that considers both distance matrices to explore promising regions of the solution space. The algorithm ensures feasibility by verifying no duplicates or missing nodes and includes a fallback mechanism to a simple segment permutation if the solution becomes invalid, with the permutation pattern dynamically adjusted based on the current solution's properties.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weights = obj_variance / np.sum(obj_variance)\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment permutation and dynamic edge reassembly\n    # Step 1: Select a random segment to permute\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1]\n\n    # Create a custom permutation pattern based on distance matrices\n    segment_distances = distance_matrix_1[segment, :][:, segment] + distance_matrix_2[segment, :][:, segment]\n    permutation = np.argsort(np.sum(segment_distances, axis=1))\n    permuted_segment = segment[permutation]\n\n    # Step 2: Insert the permuted segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], permuted_segment, base_solution[k:]])\n\n    # Step 3: Dynamic edge reassembly between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n\n        # Probabilistic reassembly based on distance matrices\n        a_distances = distance_matrix_1[segment_a, :] + distance_matrix_2[segment_a, :]\n        b_distances = distance_matrix_1[segment_b, :] + distance_matrix_2[segment_b, :]\n\n        a_prob = np.exp(-np.sum(a_distances, axis=1) / np.sum(a_distances))\n        b_prob = np.exp(-np.sum(b_distances, axis=1) / np.sum(b_distances))\n\n        a_permutation = np.argsort(a_prob)\n        b_permutation = np.argsort(b_prob)\n\n        new_solution[a:b] = segment_a[a_permutation]\n        new_solution[b:] = segment_b[b_permutation]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment permutation with dynamic pattern\n        segment = base_solution[i:j+1]\n        segment_distances = distance_matrix_1[segment, :][:, segment] + distance_matrix_2[segment, :][:, segment]\n        permutation = np.argsort(np.sum(segment_distances, axis=1))\n        new_solution[i:j+1] = segment[permutation]\n\n    return new_solution\n\n",
          "score": [
               -1.0044109690536933,
               0.21091383695602417
          ]
     },
     {
          "algorithm": "{The new algorithm combines \"multi-objective tour decomposition and recombination\" with \"hybrid local search\" by first selecting a solution from the archive based on a novel \"objective balance metric\" that prioritizes solutions with balanced improvements across both objectives, then decomposes the tour into non-overlapping segments using a \"dual-objective segment partitioning\" approach that identifies natural breaks in the tour where the connection costs in both objectives are significantly different, followed by an \"adaptive segment relocation and inversion\" process that intelligently moves segments to different positions in the tour and optionally inverts them based on their potential to improve the underperforming objective, with the relocation decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment inversion if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Objective balance selection\n    objectives = np.array([obj for _, obj in archive])\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmin(obj_balance)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dual-objective segment partitioning\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate average costs in current segment\n        if len(current_segment) > 1:\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n        else:\n            avg_cost1 = avg_cost2 = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.3 * avg_cost1 and cost2 > 1.3 * avg_cost2) or len(current_segment) >= 5:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Adaptive segment relocation and inversion\n    if len(segments) > 1:\n        # Calculate current objectives\n        obj1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1))\n        obj2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1))\n\n        # Identify underperforming objective\n        if obj1 > obj2:\n            # Improve objective 1 by relocating segments\n            for i in range(len(segments)):\n                if len(segments[i]) > 1 and np.random.random() < 0.4:\n                    # Find best insertion position\n                    best_pos = -1\n                    best_cost = float('inf')\n                    for j in range(len(segments)):\n                        if j != i:\n                            # Try inserting segment i before segment j\n                            temp_segments = segments.copy()\n                            segment = temp_segments.pop(i)\n                            temp_segments.insert(j, segment)\n\n                            # Calculate new objective 1 cost\n                            temp_solution = []\n                            for seg in temp_segments:\n                                temp_solution.extend(seg)\n                            temp_solution.append(temp_solution[0])\n                            new_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n))\n\n                            if new_obj1 < best_cost:\n                                best_cost = new_obj1\n                                best_pos = j\n\n                    if best_pos != -1:\n                        segment = segments.pop(i)\n                        segments.insert(best_pos, segment)\n        else:\n            # Improve objective 2 by inverting segments\n            for i in range(len(segments)):\n                if len(segments[i]) > 2 and np.random.random() < 0.5:\n                    # Invert segment\n                    segments[i] = segments[i][::-1]\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple segment inversion\n        i = np.random.choice(range(len(segments)))\n        if len(segments[i]) > 2:\n            segments[i] = segments[i][::-1]\n        new_solution = []\n        for segment in segments:\n            new_solution.extend(segment)\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9529343961926355,
               0.09015500545501709
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a \"multi-objective adaptive segment inversion and relocation\" strategy that dynamically identifies and inverts segments based on their potential to improve both objectives simultaneously, while simultaneously relocating these segments to positions that optimize the weighted combination of both objectives, using a probabilistic approach that balances exploration of new segments with exploitation of high-potential segments, all while maintaining solution feasibility through comprehensive validation and ensuring connectivity through a segment-specific inversion mechanism that preserves the tour's structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10\n    obj_weights = 1 / obj_range\n    obj_weights /= np.sum(obj_weights)\n\n    weighted_scores = np.dot(objectives, obj_weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    if n > 3:\n        # Identify segments with high potential for improvement\n        segments = []\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = base_solution[i:i+segment_length]\n            segments.append(segment)\n\n        # Calculate segment costs\n        segment_costs = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            segment_costs.append((seg_cost1, seg_cost2))\n\n        # Adaptive segment inversion and relocation\n        for i in range(len(segments)):\n            if np.random.random() < 0.4:\n                # Invert segment if it has high potential\n                if obj_weights[0] * segment_costs[i][0] + obj_weights[1] * segment_costs[i][1] > np.mean(weighted_scores):\n                    segments[i] = segments[i][::-1]\n\n                # Relocate segment to a new position\n                j = np.random.randint(0, len(segments))\n                if i != j:\n                    segments.insert(j, segments.pop(i))\n\n        # Reconstruct solution\n        new_solution = np.concatenate(segments)\n        new_solution = np.append(new_solution, new_solution[0])\n\n    # Validate solution\n    assert len(new_solution) == n + 1 and len(np.unique(new_solution[:-1])) == n\n\n    return new_solution\n\n",
          "score": [
               -1.0043024455829204,
               0.11589115858078003
          ]
     }
]