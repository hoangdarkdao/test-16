[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8179669842566333,
            0.3183813691139221
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a promising solution from the archive by prioritizing balanced objectives (40% weight for the first cost, 60% for the second) and randomly applies either a node swap or a path reversal to generate a neighbor, ensuring feasibility by verifying no nodes are duplicated or missing. The method balances exploration and exploitation by favoring more balanced solutions and using a hybrid local search strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower weighted objectives (prioritize balanced solutions)\n    archive_sorted = sorted(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)  # Select from top 5 or all if fewer\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    # Hybrid local search: combine node swaps and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between swap or path reversal\n    if random.random() < 0.6:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Path reversal between two random indices\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.9229999080145157,
            1.1371864676475525
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-dominance-based selection, prioritizing non-dominated solutions, then applies a hybrid local search operator that combines segment rotation and edge insertion to generate a neighbor solution while ensuring feasibility by validating the tour and reverting to the original if invalid. The segment size and rotation are randomized to balance diversification and intensification, with the solution's objective values implicitly guiding the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj[0] and obj_j[1] <= obj[1] and (obj_j[0] < obj[0] or obj_j[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation and edge insertion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Rotate the segment\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the rotated segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    best_pos = random.randint(0, len(remaining))\n\n    # Insert the rotated segment at the best position\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9319700699839684,
            1.4907165169715881
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using inverse lexicographical ordering, then applies a hybrid local search combining adaptive segment relocations, probabilistic edge crossings, and dynamic node swaps with varying segment sizes and insertion probabilities to explore the solution space more thoroughly. The selection prioritizes solutions with better objectives, while the local search operators dynamically adjust their intensity based on segment costs and random probabilities to ensure diverse exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with inverse lexicographical ordering of objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = sorted_indices[np.random.randint(0, min(3, len(sorted_indices)))]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with dynamic size\n    segment_size = random.randint(3, min(6, n//3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    remaining = np.delete(new_solution, range(start, start+segment_size))\n\n    # Calculate segment's contribution to objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_size))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_size))\n\n    # Dynamic insertion with probability based on segment cost\n    insertion_prob = min(0.9, 0.4 + (seg_cost1 + seg_cost2) / (sum(distance_matrix_1.flatten()) + sum(distance_matrix_2.flatten()) + 1e-10))\n    if random.random() < insertion_prob:\n        best_pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, best_pos, segment)\n    else:\n        new_solution = np.concatenate([remaining, segment])\n\n    # Probabilistic edge crossing\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            k = random.randint(i+1, j-1)\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:j], new_solution[i:k], new_solution[j:]])\n\n    # Dynamic node swaps with varying segment sizes\n    if random.random() < 0.4:\n        swap_size = random.randint(1, min(3, n//4))\n        i = random.randint(0, n - swap_size)\n        j = random.randint(0, n - swap_size)\n        if abs(i - j) >= swap_size:\n            temp = new_solution[i:i+swap_size].copy()\n            new_solution[i:i+swap_size] = new_solution[j:j+swap_size]\n            new_solution[j:j+swap_size] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9692505333613919,
            1.5506538152694702
        ]
    },
    {
        "algorithm": "The algorithm selects nondominated solutions with inverse Pareto rank probability, then applies a hybrid local search combining cost-aware segment rotations (prioritizing high-cost-ratio segments) and adaptive edge flips (prioritizing cost-improving flips), ensuring feasibility through permutation checks. The method balances exploration (via segment rotation) and exploitation (via edge flips) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto ranking and selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                ranks[i] += 1\n\n    # Select with inverse rank probability\n    selected_idx = np.random.choice(np.where(ranks == np.min(ranks))[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cost-aware segment rotation\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment cost ratios\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    cost_ratio = seg_cost1 / (seg_cost2 + 1e-10)\n\n    # Rotate based on cost ratio\n    rotation = random.randint(1, segment_length-1)\n    if cost_ratio > 1.3:\n        rotation = -rotation\n    rotated_segment = np.roll(segment, rotation)\n\n    # Find best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, rotated_segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + 0.6 * cost2  # Weighted sum\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Adaptive edge flips\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            seg_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            seg_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flip_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            flip_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n            if (flip_cost1 + flip_cost2) < (seg_cost1 + seg_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution\n    return new_solution\n\n",
        "score": [
            -1.017532167337836,
            4.72875714302063
        ]
    },
    {
        "algorithm": "The algorithm combines dominance-depth-based selection with a hybrid local search that adaptively reorders variable-length segments based on their normalized cost contributions in both objectives, using probabilistic segment inversion and cost-aware edge swaps to balance exploration and exploitation. It prioritizes segments with high normalized costs (>0.3) for inversion (70% chance) or rotation, while other segments are rotated. Edge swaps are performed when they improve both objectives or with a 30% probability for single-objective improvement. The solution is validated to ensure feasibility, falling back to the original if invalid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dominance-depth-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    dominance_depth = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominance_depth[i] += 1\n\n    # Calculate selection probabilities\n    selection_probs = 1 / (dominance_depth + 1)\n    selection_probs /= np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering\n    segment_length = random.randint(3, min(7, n // 3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate normalized segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    norm_cost1 = segment_cost1 / total_cost1 if total_cost1 > 0 else 0\n    norm_cost2 = segment_cost2 / total_cost2 if total_cost2 > 0 else 0\n\n    # Adaptive segment reordering\n    if norm_cost1 > 0.3 or norm_cost2 > 0.3:\n        if random.random() < 0.7:\n            segment = segment[::-1]  # Invert segment with higher probability\n        else:\n            segment = np.roll(segment, random.randint(1, segment_length - 1))\n    else:\n        segment = np.roll(segment, random.randint(1, segment_length - 1))\n\n    # Insert the modified segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, segment)\n\n    # Cost-aware edge swaps\n    for i in range(1, len(new_solution) - 1):\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n           (random.random() < 0.3 and (swapped_cost1 < current_cost1 or swapped_cost2 < current_cost2)):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0129392474515224,
            2.3028358221054077
        ]
    },
    {
        "algorithm": "The algorithm combines probabilistic Pareto selection (favoring solutions with high objective disparities) with an adaptive path-swapping operator (dynamically adjusting segment sizes based on cost differences) and a multi-objective edge-flipping step (selectively reversing edges to improve both objectives). It prioritizes solutions where objectives differ significantly, uses weighted segment swaps to balance improvements across both spaces, and employs edge reversals with strict improvement conditions, with a fallback mechanism to maintain feasibility. The critical design choices involve prioritizing solutions with objective disparities, using weighted segment swaps, and applying edge flips only when both objectives improve or at least one improves sufficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective disparity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_disparities = np.abs((objectives[:,0] - objectives[:,1]) / (objectives[:,0] + objectives[:,1] + 1e-10))\n    selected_idx = np.argmax(normalized_disparities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive objective-weighted path swapping\n    max_segment = min(6, n//2)\n    segment_length = random.randint(2, max_segment)\n    start1 = random.randint(0, n - segment_length)\n    start2 = random.randint(0, n - segment_length)\n\n    segment1 = new_solution[start1:start1+segment_length]\n    segment2 = new_solution[start2:start2+segment_length]\n\n    # Calculate segment costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i-1], segment1[i]] for i in range(1, segment_length))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i-1], segment1[i]] for i in range(1, segment_length))\n\n    cost1_seg2 = sum(distance_matrix_1[segment2[i-1], segment2[i]] for i in range(1, segment_length))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i-1], segment2[i]] for i in range(1, segment_length))\n\n    # Calculate weight factors\n    weight1 = cost1_seg1 / (cost1_seg2 + 1e-10)\n    weight2 = cost2_seg1 / (cost2_seg2 + 1e-10)\n\n    # Swap segments with probability based on weight factors\n    if random.random() < (weight1 + weight2) / 2:\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n    # Multi-objective edge flipping\n    for _ in range(random.randint(1, 4)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(5, n//3))) % n\n\n        # Calculate potential costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if ((new_cost1 < old_cost1 and new_cost2 < old_cost2) or\n            (new_cost1 < old_cost1 and (old_cost2 - new_cost2) < 0.2 * old_cost2) or\n            (new_cost2 < old_cost2 and (old_cost1 - new_cost1) < 0.2 * old_cost1)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if permutation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5514553809206316,
            0.44702911376953125
        ]
    },
    {
        "algorithm": "The algorithm selects non-dominated solutions from the archive with a fallback to random selection, then applies a hybrid local search combining segment inversion/rotation (prioritizing high-cost segments) and cost-aware edge swaps (favoring bi-objective improvements). It ensures feasibility by validating the solution and reverting to the original if invalid. The method balances exploration (random segment operations) and exploitation (targeted cost reduction) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dominance-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering\n    segment_length = random.randint(4, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate normalized segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    norm_cost1 = segment_cost1 / total_cost1 if total_cost1 > 0 else 0\n    norm_cost2 = segment_cost2 / total_cost2 if total_cost2 > 0 else 0\n\n    # Adaptive segment reordering\n    if norm_cost1 > 0.4 or norm_cost2 > 0.4:\n        if random.random() < 0.6:\n            segment = segment[::-1]  # Invert segment with 60% probability\n        else:\n            segment = np.roll(segment, random.randint(1, segment_length - 1))\n    else:\n        if random.random() < 0.4:\n            segment = np.roll(segment, random.randint(1, segment_length - 1))  # Shift with 40% probability\n\n    # Insert the modified segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, segment)\n\n    # Cost-aware edge swaps\n    for i in range(1, len(new_solution) - 1):\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n           (random.random() < 0.2 and (swapped_cost1 < current_cost1 or swapped_cost2 < current_cost2)):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0096287225963685,
            2.675853967666626
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined objective costs (weighted 60% for the first objective and 40% for the second), then applies a hybrid local search that randomly chooses between segment reversal (reversing a random segment of the tour) or edge swapping (swapping two non-adjacent edges) to generate a neighbor solution, ensuring feasibility by checking for duplicate nodes. The selection process biases toward high-potential solutions, while the local search diversifies exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective (exponential weighting)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    selected_idx = min(15, len(archive_sorted) - 1)\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal or edge swapping\n    if random.random() < 0.6:\n        # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge swapping\n        if n >= 4:\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify solution validity\n    assert len(new_solution) == len(selected_solution), \"Solution length mismatch\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes detected\"\n\n    return new_solution\n\n",
        "score": [
            -0.9076585486137072,
            1.1378300786018372
        ]
    },
    {
        "algorithm": "This algorithm employs an adaptive hybrid approach that combines probabilistic segment transformations (inversion, rotation, swapping) with cost-sensitive edge swaps and node relocations, prioritizing segments with higher normalized costs while maintaining feasibility through validation checks. It dynamically decomposes solutions into variable-length segments and applies objective-aware operations, balancing exploration and exploitation through randomized decisions and cost thresholds. The method ensures feasibility by validating solutions and falling back to the original if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with objective-aware probability\n    objectives = np.array([obj for (sol, obj) in archive])\n    selection_probs = np.exp(-np.array([obj[0]**0.7 + obj[1]**0.7 for obj in objectives]))\n    selection_probs /= np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path decomposition with variable segment lengths\n    segment_size = max(2, min(4, n // 4))\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n    if len(segments[-1]) < 2:\n        segments[-2] = np.concatenate([segments[-2], segments[-1]])\n        segments = segments[:-1]\n\n    # Segment transformation with objective-aware probabilities\n    for i in range(len(segments)):\n        seg_len = len(segments[i])\n        if seg_len < 2:\n            continue\n\n        # Calculate segment costs\n        seg_cost1 = sum(distance_matrix_1[segments[i][j-1], segments[i][j]] for j in range(1, seg_len))\n        seg_cost2 = sum(distance_matrix_2[segments[i][j-1], segments[i][j]] for j in range(1, seg_len))\n        norm_cost1 = seg_cost1 / (distance_matrix_1.max() * seg_len)\n        norm_cost2 = seg_cost2 / (distance_matrix_2.max() * seg_len)\n\n        # Operation selection\n        if norm_cost1 > 0.3 or norm_cost2 > 0.3:\n            op = random.random()\n            if op < 0.4:\n                segments[i] = segments[i][::-1]  # Invert segment\n            elif op < 0.7:\n                segments[i] = np.roll(segments[i], random.randint(1, seg_len - 1))  # Rotate segment\n            else:\n                # Partial swap\n                split = random.randint(1, seg_len - 1)\n                segments[i] = np.concatenate([segments[i][:split], segments[i][split:][::-1]])\n        else:\n            # Probabilistic relocation\n            if len(segments) > 1 and random.random() < 0.6:\n                old_pos = i\n                new_pos = (i + random.randint(1, len(segments) - 1)) % len(segments)\n                if old_pos != new_pos:\n                    segments[old_pos], segments[new_pos] = segments[new_pos], segments[old_pos]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Cost-sensitive edge swaps\n    for i in range(1, n - 2):\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n        flipped_cost = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if flipped_cost < current_cost * 0.95 or (random.random() < 0.2 and flipped_cost < current_cost):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Node relocation with cost-based probability\n    if n > 5:\n        for _ in range(min(3, n // 4)):\n            node_to_move = random.choice(new_solution)\n            pos = np.where(new_solution == node_to_move)[0][0]\n            new_pos = random.randint(0, n - 1)\n            if pos != new_pos:\n                # Calculate cost difference\n                old_cost = distance_matrix_1[new_solution[pos-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[(pos+1)%n]] + \\\n                           distance_matrix_2[new_solution[pos-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[(pos+1)%n]]\n                new_cost = distance_matrix_1[new_solution[new_pos-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[new_pos]] + \\\n                           distance_matrix_2[new_solution[new_pos-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[new_pos]]\n                delta_cost = new_cost - old_cost\n\n                if delta_cost < 0 or (random.random() < 0.3 and delta_cost < old_cost * 0.1):\n                    new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9496718722019416,
            1.9879992604255676
        ]
    }
]