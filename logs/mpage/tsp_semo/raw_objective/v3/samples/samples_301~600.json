[
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining hierarchical clustering with multi-objective aware node relocation and insertion, which first partitions the solution into hierarchical clusters based on both spatial proximity and edge strength in both objective spaces, then performs a multi-dimensional relocation process that simultaneously considers both objectives to identify and move nodes to positions that promise improvement in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while dynamically adjusting the search depth based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.cluster.hierarchy import linkage, fcluster\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    Z = linkage(combined_dist + edge_strength, method='ward')\n    clusters = fcluster(Z, t=max(2, n//5), criterion='maxclust')\n\n    cluster_indices = {}\n    for idx, cluster in enumerate(clusters):\n        if cluster not in cluster_indices:\n            cluster_indices[cluster] = []\n        cluster_indices[cluster].append(idx)\n\n    sorted_clusters = sorted(cluster_indices.keys(), key=lambda x: -len(cluster_indices[x]))\n\n    for _ in range(min(3, len(sorted_clusters))):\n        if len(sorted_clusters) < 2:\n            break\n\n        cluster1 = sorted_clusters[0]\n        cluster2 = sorted_clusters[1]\n\n        node1_idx = np.random.choice(cluster_indices[cluster1])\n        node2_idx = np.random.choice(cluster_indices[cluster2])\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[node1_idx], new_solution[node2_idx] = new_solution[node2_idx], new_solution[node1_idx]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                  distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                  distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining dynamic objective-space aware path decomposition with adaptive multi-dimensional node swapping and insertion, which first decomposes the solution into dynamic path segments based on the relative improvement potential in both objective spaces and the current solution's structure, then performs an adaptive node swapping process that simultaneously considers both objectives to identify and swap nodes that promise balanced improvement in both objectives while dynamically adjusting the swapping scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from sklearn.metrics import pairwise_distances\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = pairwise_distances(coords1)\n    dist2 = pairwise_distances(coords2)\n\n    improvement_potential = np.zeros(n)\n    for i in range(n):\n        node = base_solution[i]\n        improvement_potential[i] = (np.sum(distance_matrix_1[node, :]) + np.sum(distance_matrix_2[node, :])) / (n-1)\n\n    sorted_indices = np.argsort(improvement_potential)[::-1]\n    segments = []\n    current_segment = [sorted_indices[0]]\n    for i in range(1, n):\n        if improvement_potential[sorted_indices[i]] > 0.7 * improvement_potential[current_segment[0]]:\n            current_segment.append(sorted_indices[i])\n        else:\n            if len(current_segment) > 1:\n                segments.append(current_segment)\n            current_segment = [sorted_indices[i]]\n    if len(current_segment) > 1:\n        segments.append(current_segment)\n\n    if not segments:\n        segments = [list(range(n))]\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 1:\n            break\n\n        segment = segments[np.random.randint(0, len(segments))]\n        if len(segment) < 2:\n            continue\n\n        i, j = np.random.choice(segment, 2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            if temp_cost1 + temp_cost2 < best_cost:\n                if abs(temp_cost1 - temp_cost2) < 0.5 * (current_cost1 + current_cost2):\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 301,
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive objective-space aware path segmentation with dynamic multi-dimensional node rearrangement and selective insertion, which first segments the solution into adaptive path segments based on the relative improvement potential in both objective spaces and the current solution's structure, then performs a dynamic node rearrangement process that simultaneously considers both objectives to identify and rearrange nodes in segments that promise balanced improvement in both objectives while dynamically adjusting the rearrangement scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a selective insertion phase that prioritizes nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    segment_size = max(2, n // 4)\n    segments = [list(range(i, min(i + segment_size, n))) for i in range(0, n, segment_size)]\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 1:\n            break\n\n        segment = segments[np.random.randint(0, len(segments))]\n        if len(segment) < 2:\n            continue\n\n        i, j = np.random.choice(segment, 2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            if temp_cost1 + temp_cost2 < best_cost:\n                if abs(temp_cost1 - temp_cost2) < 0.3 * (current_cost1 + current_cost2):\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.213558291669283,
               5.989913369669796
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    segment_size = max(2, n // 4)\n    segments = [list(range(i, min(i + segment_size, n))) for i in range(0, n, segment_size)]\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 1:\n            break\n\n        segment = segments[np.random.randint(0, len(segments))]\n        if len(segment) < 2:\n            continue\n\n        i, j = np.random.choice(segment, 2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            if temp_cost1 + temp_cost2 < best_cost:\n                if abs(temp_cost1 - temp_cost2) < 0.3 * (current_cost1 + current_cost2):\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach that combines adaptive multi-objective path decomposition with dynamic segment reassembly, which first decomposes the solution into variable-length segments based on the combined spatial and objective-aware edge characteristics, then selectively reassembles these segments by considering their potential to improve both objectives, followed by a probabilistic segment rotation phase that dynamically adjusts the rotation direction based on the current solution's segment structure and the relative improvement potential in both objectives, and concludes with a constrained segment inversion phase that prioritizes segments with complementary improvement potential across both objectives, while maintaining feasibility through a permutation-aware validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate edge characteristics\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        combined_cost = edge_cost1 + edge_cost2\n\n        # Calculate spatial coherence\n        coord1_prev = instance[new_solution[i-1], :2]\n        coord1_curr = instance[new_solution[i], :2]\n        coord2_prev = instance[new_solution[i-1], 2:]\n        coord2_curr = instance[new_solution[i], 2:]\n        spatial_dist1 = np.linalg.norm(coord1_curr - coord1_prev)\n        spatial_dist2 = np.linalg.norm(coord2_curr - coord2_prev)\n\n        # Segment decision\n        if (combined_cost > 1.5 * np.mean([distance_matrix_1.mean(), distance_matrix_2.mean()]) or\n            spatial_dist1 > 2 * np.mean(spatial_dist1) or\n            spatial_dist2 > 2 * np.mean(spatial_dist2)):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Dynamic segment reassembly\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        # Select two random segments\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n        old_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n\n        new_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        new_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Reassemble segments\n            new_segments = segments.copy()\n            new_segments[seg1_idx] = seg2 + seg1\n            new_segments[seg2_idx] = []\n\n            # Update solution\n            new_solution = np.concatenate([s for s in new_segments if s])\n            segments = [s for s in new_segments if s]\n\n    # Probabilistic segment rotation\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 2:\n            continue\n\n        # Calculate rotation potential\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try both rotation directions\n        rotated1 = segment[1:] + [segment[0]]\n        rotated2 = [segment[-1]] + segment[:-1]\n\n        new_cost1_1 = sum(distance_matrix_1[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n        new_cost2_1 = sum(distance_matrix_2[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n\n        new_cost1_2 = sum(distance_matrix_1[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n        new_cost2_2 = sum(distance_matrix_2[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n\n        if (new_cost1_1 + new_cost2_1 < old_cost1 + old_cost2 and\n            np.random.random() < 0.7):\n            segments[seg_idx] = rotated1\n        elif (new_cost1_2 + new_cost2_2 < old_cost1 + old_cost2 and\n              np.random.random() < 0.7):\n            segments[seg_idx] = rotated2\n\n    # Constrained segment inversion\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 3:\n            continue\n\n        # Select inversion points\n        inv_start = np.random.randint(0, len(segment)-2)\n        inv_end = np.random.randint(inv_start+1, len(segment))\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_1[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n        old_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_2[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n\n        new_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_1[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n        new_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_2[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Perform inversion\n            segments[seg_idx] = segment[:inv_start] + segment[inv_start:inv_end+1][::-1] + segment[inv_end+1:]\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining adaptive objective-space segmentation with multi-dimensional path inversion and selective edge refinement, which first partitions the solution into dynamic segments based on the combined spatial proximity and edge strength in both objective spaces, then selectively inverts segments of the tour while considering their potential to improve both objectives, followed by a guided edge refinement phase that prioritizes edges with complementary improvement potential in both objectives while dynamically adjusting the refinement scope based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    segments.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        if seg1_end <= seg2_idx or seg2_end <= seg1_idx:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[seg1_idx-1], new_solution[seg1_idx]] +\n                   distance_matrix_1[new_solution[seg1_end-1], new_solution[seg1_end%n]] +\n                   distance_matrix_1[new_solution[seg2_idx-1], new_solution[seg2_idx]] +\n                   distance_matrix_1[new_solution[seg2_end-1], new_solution[seg2_end%n]] +\n                   distance_matrix_2[new_solution[seg1_idx-1], new_solution[seg1_idx]] +\n                   distance_matrix_2[new_solution[seg1_end-1], new_solution[seg1_end%n]] +\n                   distance_matrix_2[new_solution[seg2_idx-1], new_solution[seg2_idx]] +\n                   distance_matrix_2[new_solution[seg2_end-1], new_solution[seg2_end%n]])\n\n        candidate = new_solution.copy()\n        candidate[seg1_idx:seg1_end] = candidate[seg1_idx:seg1_end][::-1]\n        candidate[seg2_idx:seg2_end] = candidate[seg2_idx:seg2_end][::-1]\n\n        new_cost = (distance_matrix_1[candidate[seg1_idx-1], candidate[seg1_idx]] +\n                   distance_matrix_1[candidate[seg1_end-1], candidate[seg1_end%n]] +\n                   distance_matrix_1[candidate[seg2_idx-1], candidate[seg2_idx]] +\n                   distance_matrix_1[candidate[seg2_end-1], candidate[seg2_end%n]] +\n                   distance_matrix_2[candidate[seg1_idx-1], candidate[seg1_idx]] +\n                   distance_matrix_2[candidate[seg1_end-1], candidate[seg1_end%n]] +\n                   distance_matrix_2[candidate[seg2_idx-1], candidate[seg2_idx]] +\n                   distance_matrix_2[candidate[seg2_end-1], candidate[seg2_end%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                   distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                   distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                   distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        if abs(i - j) == 1:\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n        else:\n            if i < j:\n                candidate[i:j] = candidate[i:j][::-1]\n            else:\n                candidate[j:i] = candidate[j:i][::-1]\n\n        new_cost = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                   distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_1[candidate[j-1], candidate[j]] +\n                   distance_matrix_1[candidate[j], candidate[(j+1)%n]] +\n                   distance_matrix_2[candidate[i-1], candidate[i]] +\n                   distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_2[candidate[j-1], candidate[j]] +\n                   distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 302,
          "algorithm": "{The new algorithm introduces a novel approach that combines hierarchical clustering with multi-objective edge swapping and dynamic segment merging, which first hierarchically clusters nodes based on their combined spatial proximity in both objective spaces, then performs a guided edge swapping phase that prioritizes edges connecting clusters of different sizes while considering their potential to improve both objectives, followed by a dynamic segment merging phase that selectively merges adjacent segments based on their combined improvement potential in both objectives while dynamically adjusting the merging criteria based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with probability inversely proportional to its rank\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives.sum(axis=1)))\n    probabilities = 1 / (ranks + 1)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hierarchical clustering based on combined spatial proximity\n    from scipy.cluster.hierarchy import linkage, fcluster\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.column_stack((coords1, coords2))\n    Z = linkage(combined_coords, method='ward')\n    max_d = 1.5 * np.median(Z[:, 2])\n    clusters = fcluster(Z, max_d, criterion='distance')\n\n    # Guided edge swapping phase\n    for _ in range(min(5, n//2)):\n        # Select two edges from different clusters\n        cluster_sizes = np.bincount(clusters)\n        large_clusters = np.where(cluster_sizes > 2)[0]\n\n        if len(large_clusters) < 2:\n            break\n\n        c1, c2 = np.random.choice(large_clusters, 2, replace=False)\n        nodes_c1 = np.where(clusters == c1)[0]\n        nodes_c2 = np.where(clusters == c2)[0]\n\n        if len(nodes_c1) < 2 or len(nodes_c2) < 2:\n            continue\n\n        i = np.random.choice(nodes_c1)\n        j = np.random.choice(nodes_c2)\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        new_cost = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                   distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_1[candidate[j-1], candidate[j]] +\n                   distance_matrix_1[candidate[j], candidate[(j+1)%n]] +\n                   distance_matrix_2[candidate[i-1], candidate[i]] +\n                   distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_2[candidate[j-1], candidate[j]] +\n                   distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    # Dynamic segment merging phase\n    segments = []\n    current_segment = [0]\n    for i in range(1, n):\n        if clusters[i] != clusters[i-1]:\n            segments.append(current_segment)\n            current_segment = [i]\n        else:\n            current_segment.append(i)\n    if current_segment:\n        segments.append(current_segment)\n\n    for _ in range(min(3, len(segments)-1)):\n        # Select two adjacent segments\n        seg_idx = np.random.randint(0, len(segments)-1)\n        seg1, seg2 = segments[seg_idx], segments[seg_idx+1]\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[new_solution[seg1[-1]], new_solution[seg1[0]]] +\n                   distance_matrix_1[new_solution[seg2[-1]], new_solution[seg2[0]]] +\n                   distance_matrix_2[new_solution[seg1[-1]], new_solution[seg1[0]]] +\n                   distance_matrix_2[new_solution[seg2[-1]], new_solution[seg2[0]]])\n\n        new_cost = (distance_matrix_1[new_solution[seg1[-1]], new_solution[seg2[0]]] +\n                   distance_matrix_1[new_solution[seg2[-1]], new_solution[seg1[0]]] +\n                   distance_matrix_2[new_solution[seg1[-1]], new_solution[seg2[0]]] +\n                   distance_matrix_2[new_solution[seg2[-1]], new_solution[seg1[0]]])\n\n        if new_cost < old_cost:\n            # Merge segments\n            merged = seg1 + seg2\n            segments[seg_idx] = merged\n            segments.pop(seg_idx+1)\n\n            # Update solution\n            new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.956543867599115,
               7.450404891178083
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with probability inversely proportional to its rank\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives.sum(axis=1)))\n    probabilities = 1 / (ranks + 1)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hierarchical clustering based on combined spatial proximity\n    from scipy.cluster.hierarchy import linkage, fcluster\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.column_stack((coords1, coords2))\n    Z = linkage(combined_coords, method='ward')\n    max_d = 1.5 * np.median(Z[:, 2])\n    clusters = fcluster(Z, max_d, criterion='distance')\n\n    # Guided edge swapping phase\n    for _ in range(min(5, n//2)):\n        # Select two edges from different clusters\n        cluster_sizes = np.bincount(clusters)\n        large_clusters = np.where(cluster_sizes > 2)[0]\n\n        if len(large_clusters) < 2:\n            break\n\n        c1, c2 = np.random.choice(large_clusters, 2, replace=False)\n        nodes_c1 = np.where(clusters == c1)[0]\n        nodes_c2 = np.where(clusters == c2)[0]\n\n        if len(nodes_c1) < 2 or len(nodes_c2) < 2:\n            continue\n\n        i = np.random.choice(nodes_c1)\n        j = np.random.choice(nodes_c2)\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        new_cost = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                   distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_1[candidate[j-1], candidate[j]] +\n                   distance_matrix_1[candidate[j], candidate[(j+1)%n]] +\n                   distance_matrix_2[candidate[i-1], candidate[i]] +\n                   distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_2[candidate[j-1], candidate[j]] +\n                   distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    # Dynamic segment merging phase\n    segments = []\n    current_segment = [0]\n    for i in range(1, n):\n        if clusters[i] != clusters[i-1]:\n            segments.append(current_segment)\n            current_segment = [i]\n        else:\n            current_segment.append(i)\n    if current_segment:\n        segments.append(current_segment)\n\n    for _ in range(min(3, len(segments)-1)):\n        # Select two adjacent segments\n        seg_idx = np.random.randint(0, len(segments)-1)\n        seg1, seg2 = segments[seg_idx], segments[seg_idx+1]\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[new_solution[seg1[-1]], new_solution[seg1[0]]] +\n                   distance_matrix_1[new_solution[seg2[-1]], new_solution[seg2[0]]] +\n                   distance_matrix_2[new_solution[seg1[-1]], new_solution[seg1[0]]] +\n                   distance_matrix_2[new_solution[seg2[-1]], new_solution[seg2[0]]])\n\n        new_cost = (distance_matrix_1[new_solution[seg1[-1]], new_solution[seg2[0]]] +\n                   distance_matrix_1[new_solution[seg2[-1]], new_solution[seg1[0]]] +\n                   distance_matrix_2[new_solution[seg1[-1]], new_solution[seg2[0]]] +\n                   distance_matrix_2[new_solution[seg2[-1]], new_solution[seg1[0]]])\n\n        if new_cost < old_cost:\n            # Merge segments\n            merged = seg1 + seg2\n            segments[seg_idx] = merged\n            segments.pop(seg_idx+1)\n\n            # Update solution\n            new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining hierarchical clustering with multi-objective aware node relocation and insertion, which first partitions the solution into hierarchical clusters based on both spatial proximity and edge strength in both objective spaces, then performs a multi-dimensional relocation process that simultaneously considers both objectives to identify and move nodes to positions that promise improvement in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while dynamically adjusting the search depth based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.cluster.hierarchy import linkage, fcluster\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    Z = linkage(combined_dist + edge_strength, method='ward')\n    clusters = fcluster(Z, t=max(2, n//5), criterion='maxclust')\n\n    cluster_indices = {}\n    for idx, cluster in enumerate(clusters):\n        if cluster not in cluster_indices:\n            cluster_indices[cluster] = []\n        cluster_indices[cluster].append(idx)\n\n    sorted_clusters = sorted(cluster_indices.keys(), key=lambda x: -len(cluster_indices[x]))\n\n    for _ in range(min(3, len(sorted_clusters))):\n        if len(sorted_clusters) < 2:\n            break\n\n        cluster1 = sorted_clusters[0]\n        cluster2 = sorted_clusters[1]\n\n        node1_idx = np.random.choice(cluster_indices[cluster1])\n        node2_idx = np.random.choice(cluster_indices[cluster2])\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[node1_idx], new_solution[node2_idx] = new_solution[node2_idx], new_solution[node1_idx]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                  distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                  distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining adaptive multi-objective tour segmentation with dynamic node reallocation and insertion, which first segments the solution into dynamic path segments based on the combined spatial proximity and edge strength in both objective spaces, then performs a multi-dimensional node reallocation process that simultaneously considers both objective spaces to identify and move nodes to positions that promise improvement in both objectives while dynamically adjusting the relocation scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    # Calculate combined spatial proximity and edge strength\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    # Dynamic tour segmentation\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment strength\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    # Sort segments by strength (descending)\n    segments.sort(key=lambda x: -x[2])\n\n    # Multi-dimensional node relocation with dynamic scope\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        # Select two segments with high strength\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        # Calculate dynamic relocation scope\n        scope = min(3, max(1, (seg1_end - seg1_idx) // 2))\n\n        # Select nodes from each segment within the scope\n        node1_idx = np.random.randint(seg1_idx, min(seg1_end, seg1_idx + scope))\n        node2_idx = np.random.randint(seg2_idx, min(seg2_end, seg2_idx + scope))\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                        distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                        distance_matrix_1[new_solution[node2_idx-1], node2] +\n                        distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        current_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                        distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                        distance_matrix_2[new_solution[node2_idx-1], node2] +\n                        distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        # Try relocating nodes between segments\n        candidate = new_solution.copy()\n\n        # Option 1: Move node1 to segment2 and node2 to segment1\n        temp_solution = candidate.copy()\n        temp_solution[node1_idx], temp_solution[node2_idx] = temp_solution[node2_idx], temp_solution[node1_idx]\n\n        new_cost1 = (distance_matrix_1[temp_solution[node1_idx-1], temp_solution[node1_idx]] +\n                    distance_matrix_1[temp_solution[node1_idx], temp_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[temp_solution[node2_idx-1], temp_solution[node2_idx]] +\n                    distance_matrix_1[temp_solution[node2_idx], temp_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[node1_idx-1], temp_solution[node1_idx]] +\n                    distance_matrix_2[temp_solution[node1_idx], temp_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[temp_solution[node2_idx-1], temp_solution[node2_idx]] +\n                    distance_matrix_2[temp_solution[node2_idx], temp_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            candidate = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n        # Option 2: Move node1 to segment2\n        temp_solution = candidate.copy()\n        temp_node = temp_solution[node1_idx]\n        temp_solution = np.delete(temp_solution, node1_idx)\n        insert_pos = np.random.randint(seg2_idx, min(seg2_end, seg2_idx + scope))\n        temp_solution = np.insert(temp_solution, insert_pos, temp_node)\n\n        new_cost1 = (distance_matrix_1[temp_solution[insert_pos-1], temp_solution[insert_pos]] +\n                    distance_matrix_1[temp_solution[insert_pos], temp_solution[(insert_pos+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[insert_pos-1], temp_solution[insert_pos]] +\n                    distance_matrix_2[temp_solution[insert_pos], temp_solution[(insert_pos+1)%n]])\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            candidate = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n        # Option 3: Move node2 to segment1\n        temp_solution = candidate.copy()\n        temp_node = temp_solution[node2_idx]\n        temp_solution = np.delete(temp_solution, node2_idx)\n        insert_pos = np.random.randint(seg1_idx, min(seg1_end, seg1_idx + scope))\n        temp_solution = np.insert(temp_solution, insert_pos, temp_node)\n\n        new_cost1 = (distance_matrix_1[temp_solution[insert_pos-1], temp_solution[insert_pos]] +\n                    distance_matrix_1[temp_solution[insert_pos], temp_solution[(insert_pos+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[insert_pos-1], temp_solution[insert_pos]] +\n                    distance_matrix_2[temp_solution[insert_pos], temp_solution[(insert_pos+1)%n]])\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            candidate = temp_solution\n\n        new_solution = candidate\n\n    # Guided insertion with global structure consideration\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        # Remove the node\n        candidate = np.delete(new_solution, i)\n\n        # Find the best position to reinsert the node\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            # Consider global structure impact\n            if len(temp) > 5:\n                # Check if the insertion maintains balanced improvement\n                if (abs(temp_cost1 - temp_cost2) < 0.3 * (current_cost1 + current_cost2)):\n                    if temp_cost1 + temp_cost2 < best_cost:\n                        best_cost = temp_cost1 + temp_cost2\n                        best_pos = j\n            else:\n                if temp_cost1 + temp_cost2 < best_cost:\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 303,
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive multi-objective path decomposition with dynamic node swapping and parallel insertion, which first decomposes the solution into dynamic path segments based on the combined spatial proximity and edge strength in both objective spaces, then performs a multi-dimensional node swapping process that simultaneously considers both objective spaces to identify and swap nodes across different segments that promise improvement in both objectives while dynamically adjusting the swapping scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a parallel insertion phase that simultaneously evaluates multiple candidate insertions in different segments to prioritize nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate combined spatial proximity and edge strength\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = np.linalg.norm(coords1[:, np.newaxis] - coords1, axis=2)\n    dist2 = np.linalg.norm(coords2[:, np.newaxis] - coords2, axis=2)\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    # Dynamic path decomposition\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment strength\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    # Sort segments by strength (descending)\n    segments.sort(key=lambda x: -x[2])\n\n    # Multi-dimensional node swapping with dynamic scope\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        # Select two segments with high strength\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        # Calculate dynamic swapping scope\n        scope = min(3, max(1, (seg1_end - seg1_idx) // 2))\n\n        # Select nodes from each segment within the scope\n        node1_idx = np.random.randint(seg1_idx, min(seg1_end, seg1_idx + scope))\n        node2_idx = np.random.randint(seg2_idx, min(seg2_end, seg2_idx + scope))\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                        distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                        distance_matrix_1[new_solution[node2_idx-1], node2] +\n                        distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        current_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                        distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                        distance_matrix_2[new_solution[node2_idx-1], node2] +\n                        distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        # Try swapping nodes between segments\n        temp_solution = new_solution.copy()\n        temp_solution[node1_idx], temp_solution[node2_idx] = temp_solution[node2_idx], temp_solution[node1_idx]\n\n        new_cost1 = (distance_matrix_1[temp_solution[node1_idx-1], temp_solution[node1_idx]] +\n                    distance_matrix_1[temp_solution[node1_idx], temp_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[temp_solution[node2_idx-1], temp_solution[node2_idx]] +\n                    distance_matrix_1[temp_solution[node2_idx], temp_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[node1_idx-1], temp_solution[node1_idx]] +\n                    distance_matrix_2[temp_solution[node1_idx], temp_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[temp_solution[node2_idx-1], temp_solution[node2_idx]] +\n                    distance_matrix_2[temp_solution[node2_idx], temp_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            new_solution = temp_solution\n\n    # Parallel insertion with global structure consideration\n    for _ in range(min(3, n//4)):\n        # Select multiple segments to consider in parallel\n        selected_segments = np.random.choice(len(segments), size=min(3, len(segments)), replace=False)\n\n        for seg_idx in selected_segments:\n            seg_start, seg_end, _ = segments[seg_idx]\n\n            # Select a node from the segment\n            node_idx = np.random.randint(seg_start, seg_end)\n            node = new_solution[node_idx]\n\n            # Calculate current costs\n            current_cost1 = (distance_matrix_1[new_solution[node_idx-1], node] +\n                            distance_matrix_1[node, new_solution[(node_idx+1)%n]])\n            current_cost2 = (distance_matrix_2[new_solution[node_idx-1], node] +\n                            distance_matrix_2[node, new_solution[(node_idx+1)%n]])\n\n            # Remove the node\n            candidate = np.delete(new_solution, node_idx)\n\n            # Find the best position to reinsert the node in a different segment\n            best_pos = None\n            best_cost = float('inf')\n\n            # Consider inserting in other segments\n            for other_seg_idx in range(len(segments)):\n                if other_seg_idx == seg_idx:\n                    continue\n\n                other_start, other_end, _ = segments[other_seg_idx]\n                for j in range(other_start, other_end):\n                    temp = np.insert(candidate, j, node)\n                    temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                                 distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n                    temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                                 distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n                    # Consider global structure impact\n                    if len(temp) > 5:\n                        # Check if the insertion maintains balanced improvement\n                        if (abs(temp_cost1 - temp_cost2) < 0.3 * (current_cost1 + current_cost2)):\n                            if temp_cost1 + temp_cost2 < best_cost:\n                                best_cost = temp_cost1 + temp_cost2\n                                best_pos = j\n                    else:\n                        if temp_cost1 + temp_cost2 < best_cost:\n                            best_cost = temp_cost1 + temp_cost2\n                            best_pos = j\n\n            if best_pos is not None:\n                new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.47377398666822,
               6.496403372232401
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate combined spatial proximity and edge strength\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = np.linalg.norm(coords1[:, np.newaxis] - coords1, axis=2)\n    dist2 = np.linalg.norm(coords2[:, np.newaxis] - coords2, axis=2)\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    # Dynamic path decomposition\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment strength\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    # Sort segments by strength (descending)\n    segments.sort(key=lambda x: -x[2])\n\n    # Multi-dimensional node swapping with dynamic scope\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        # Select two segments with high strength\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        # Calculate dynamic swapping scope\n        scope = min(3, max(1, (seg1_end - seg1_idx) // 2))\n\n        # Select nodes from each segment within the scope\n        node1_idx = np.random.randint(seg1_idx, min(seg1_end, seg1_idx + scope))\n        node2_idx = np.random.randint(seg2_idx, min(seg2_end, seg2_idx + scope))\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                        distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                        distance_matrix_1[new_solution[node2_idx-1], node2] +\n                        distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        current_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                        distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                        distance_matrix_2[new_solution[node2_idx-1], node2] +\n                        distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        # Try swapping nodes between segments\n        temp_solution = new_solution.copy()\n        temp_solution[node1_idx], temp_solution[node2_idx] = temp_solution[node2_idx], temp_solution[node1_idx]\n\n        new_cost1 = (distance_matrix_1[temp_solution[node1_idx-1], temp_solution[node1_idx]] +\n                    distance_matrix_1[temp_solution[node1_idx], temp_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[temp_solution[node2_idx-1], temp_solution[node2_idx]] +\n                    distance_matrix_1[temp_solution[node2_idx], temp_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[node1_idx-1], temp_solution[node1_idx]] +\n                    distance_matrix_2[temp_solution[node1_idx], temp_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[temp_solution[node2_idx-1], temp_solution[node2_idx]] +\n                    distance_matrix_2[temp_solution[node2_idx], temp_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            new_solution = temp_solution\n\n    # Parallel insertion with global structure consideration\n    for _ in range(min(3, n//4)):\n        # Select multiple segments to consider in parallel\n        selected_segments = np.random.choice(len(segments), size=min(3, len(segments)), replace=False)\n\n        for seg_idx in selected_segments:\n            seg_start, seg_end, _ = segments[seg_idx]\n\n            # Select a node from the segment\n            node_idx = np.random.randint(seg_start, seg_end)\n            node = new_solution[node_idx]\n\n            # Calculate current costs\n            current_cost1 = (distance_matrix_1[new_solution[node_idx-1], node] +\n                            distance_matrix_1[node, new_solution[(node_idx+1)%n]])\n            current_cost2 = (distance_matrix_2[new_solution[node_idx-1], node] +\n                            distance_matrix_2[node, new_solution[(node_idx+1)%n]])\n\n            # Remove the node\n            candidate = np.delete(new_solution, node_idx)\n\n            # Find the best position to reinsert the node in a different segment\n            best_pos = None\n            best_cost = float('inf')\n\n            # Consider inserting in other segments\n            for other_seg_idx in range(len(segments)):\n                if other_seg_idx == seg_idx:\n                    continue\n\n                other_start, other_end, _ = segments[other_seg_idx]\n                for j in range(other_start, other_end):\n                    temp = np.insert(candidate, j, node)\n                    temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                                 distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n                    temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                                 distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n                    # Consider global structure impact\n                    if len(temp) > 5:\n                        # Check if the insertion maintains balanced improvement\n                        if (abs(temp_cost1 - temp_cost2) < 0.3 * (current_cost1 + current_cost2)):\n                            if temp_cost1 + temp_cost2 < best_cost:\n                                best_cost = temp_cost1 + temp_cost2\n                                best_pos = j\n                    else:\n                        if temp_cost1 + temp_cost2 < best_cost:\n                            best_cost = temp_cost1 + temp_cost2\n                            best_pos = j\n\n            if best_pos is not None:\n                new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach that combines adaptive multi-objective path decomposition with dynamic segment reassembly, which first decomposes the solution into variable-length segments based on the combined spatial and objective-aware edge characteristics, then selectively reassembles these segments by considering their potential to improve both objectives, followed by a probabilistic segment rotation phase that dynamically adjusts the rotation direction based on the current solution's segment structure and the relative improvement potential in both objectives, and concludes with a constrained segment inversion phase that prioritizes segments with complementary improvement potential across both objectives, while maintaining feasibility through a permutation-aware validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate edge characteristics\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        combined_cost = edge_cost1 + edge_cost2\n\n        # Calculate spatial coherence\n        coord1_prev = instance[new_solution[i-1], :2]\n        coord1_curr = instance[new_solution[i], :2]\n        coord2_prev = instance[new_solution[i-1], 2:]\n        coord2_curr = instance[new_solution[i], 2:]\n        spatial_dist1 = np.linalg.norm(coord1_curr - coord1_prev)\n        spatial_dist2 = np.linalg.norm(coord2_curr - coord2_prev)\n\n        # Segment decision\n        if (combined_cost > 1.5 * np.mean([distance_matrix_1.mean(), distance_matrix_2.mean()]) or\n            spatial_dist1 > 2 * np.mean(spatial_dist1) or\n            spatial_dist2 > 2 * np.mean(spatial_dist2)):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Dynamic segment reassembly\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        # Select two random segments\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n        old_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n\n        new_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        new_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Reassemble segments\n            new_segments = segments.copy()\n            new_segments[seg1_idx] = seg2 + seg1\n            new_segments[seg2_idx] = []\n\n            # Update solution\n            new_solution = np.concatenate([s for s in new_segments if s])\n            segments = [s for s in new_segments if s]\n\n    # Probabilistic segment rotation\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 2:\n            continue\n\n        # Calculate rotation potential\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try both rotation directions\n        rotated1 = segment[1:] + [segment[0]]\n        rotated2 = [segment[-1]] + segment[:-1]\n\n        new_cost1_1 = sum(distance_matrix_1[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n        new_cost2_1 = sum(distance_matrix_2[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n\n        new_cost1_2 = sum(distance_matrix_1[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n        new_cost2_2 = sum(distance_matrix_2[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n\n        if (new_cost1_1 + new_cost2_1 < old_cost1 + old_cost2 and\n            np.random.random() < 0.7):\n            segments[seg_idx] = rotated1\n        elif (new_cost1_2 + new_cost2_2 < old_cost1 + old_cost2 and\n              np.random.random() < 0.7):\n            segments[seg_idx] = rotated2\n\n    # Constrained segment inversion\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 3:\n            continue\n\n        # Select inversion points\n        inv_start = np.random.randint(0, len(segment)-2)\n        inv_end = np.random.randint(inv_start+1, len(segment))\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_1[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n        old_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_2[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n\n        new_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_1[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n        new_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_2[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Perform inversion\n            segments[seg_idx] = segment[:inv_start] + segment[inv_start:inv_end+1][::-1] + segment[inv_end+1:]\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining hierarchical clustering with multi-objective aware node relocation and insertion, which first partitions the solution into hierarchical clusters based on both spatial proximity and edge strength in both objective spaces, then performs a multi-dimensional relocation process that simultaneously considers both objectives to identify and move nodes to positions that promise improvement in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while dynamically adjusting the search depth based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.cluster.hierarchy import linkage, fcluster\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    Z = linkage(combined_dist + edge_strength, method='ward')\n    clusters = fcluster(Z, t=max(2, n//5), criterion='maxclust')\n\n    cluster_indices = {}\n    for idx, cluster in enumerate(clusters):\n        if cluster not in cluster_indices:\n            cluster_indices[cluster] = []\n        cluster_indices[cluster].append(idx)\n\n    sorted_clusters = sorted(cluster_indices.keys(), key=lambda x: -len(cluster_indices[x]))\n\n    for _ in range(min(3, len(sorted_clusters))):\n        if len(sorted_clusters) < 2:\n            break\n\n        cluster1 = sorted_clusters[0]\n        cluster2 = sorted_clusters[1]\n\n        node1_idx = np.random.choice(cluster_indices[cluster1])\n        node2_idx = np.random.choice(cluster_indices[cluster2])\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[node1_idx], new_solution[node2_idx] = new_solution[node2_idx], new_solution[node1_idx]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                  distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                  distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 304,
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive multi-objective tour segmentation with probabilistic path reconfiguration, which first partitions the solution into variable-length segments based on the combined spatial and objective-aware edge characteristics, then performs a probabilistic path reconfiguration process that selectively swaps segments between different positions in the tour while considering their potential to improve both objectives, followed by a dynamic segment merging phase that combines adjacent segments when their combined edge costs are below a certain threshold, and concludes with a constrained segment splitting phase that divides long segments into smaller ones when their internal edge diversity exceeds a certain threshold, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with probability proportional to its rank in combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    ranks = np.argsort(np.argsort(combined_scores))\n    probabilities = np.linspace(0.1, 1.0, len(archive))\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive tour segmentation\n    segments = []\n    current_segment = [new_solution[0]]\n    threshold1 = 1.3 * np.mean(distance_matrix_1)\n    threshold2 = 1.3 * np.mean(distance_matrix_2)\n\n    for i in range(1, n):\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        if edge_cost1 > threshold1 or edge_cost2 > threshold2:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Probabilistic path reconfiguration\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        if len(seg1) < 2 or len(seg2) < 2:\n            continue\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[seg1[-1], seg1[0]] +\n                    distance_matrix_1[seg2[-1], seg2[0]])\n        old_cost2 = (distance_matrix_2[seg1[-1], seg1[0]] +\n                    distance_matrix_2[seg2[-1], seg2[0]])\n\n        new_cost1 = (distance_matrix_1[seg1[-1], seg2[0]] +\n                    distance_matrix_1[seg2[-1], seg1[0]])\n        new_cost2 = (distance_matrix_2[seg1[-1], seg2[0]] +\n                    distance_matrix_2[seg2[-1], seg1[0]])\n\n        if (new_cost1 + new_cost2 < old_cost1 + old_cost2 and\n            np.random.random() < 0.6):\n            # Perform segment swap\n            segments[seg1_idx], segments[seg2_idx] = segments[seg2_idx], segments[seg1_idx]\n\n    # Dynamic segment merging\n    for _ in range(2):\n        if len(segments) < 2:\n            break\n\n        for i in range(len(segments)-1):\n            seg1 = segments[i]\n            seg2 = segments[i+1]\n\n            combined_cost1 = distance_matrix_1[seg1[-1], seg2[0]]\n            combined_cost2 = distance_matrix_2[seg1[-1], seg2[0]]\n\n            if combined_cost1 < threshold1 and combined_cost2 < threshold2:\n                segments[i] = seg1 + seg2\n                del segments[i+1]\n                break\n\n    # Constrained segment splitting\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        for i in range(len(segments)):\n            segment = segments[i]\n            if len(segment) < 4:\n                continue\n\n            # Calculate internal edge diversity\n            internal_costs1 = [distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1)]\n            internal_costs2 = [distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1)]\n            diversity1 = np.std(internal_costs1)\n            diversity2 = np.std(internal_costs2)\n\n            if diversity1 > 0.4 * np.mean(internal_costs1) or diversity2 > 0.4 * np.mean(internal_costs2):\n                split_pos = len(segment) // 2\n                segments[i] = segment[:split_pos]\n                segments.insert(i+1, segment[split_pos:])\n                break\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               7.985215232466958,
               9.28567084868693
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with probability proportional to its rank in combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    ranks = np.argsort(np.argsort(combined_scores))\n    probabilities = np.linspace(0.1, 1.0, len(archive))\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive tour segmentation\n    segments = []\n    current_segment = [new_solution[0]]\n    threshold1 = 1.3 * np.mean(distance_matrix_1)\n    threshold2 = 1.3 * np.mean(distance_matrix_2)\n\n    for i in range(1, n):\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        if edge_cost1 > threshold1 or edge_cost2 > threshold2:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Probabilistic path reconfiguration\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        if len(seg1) < 2 or len(seg2) < 2:\n            continue\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[seg1[-1], seg1[0]] +\n                    distance_matrix_1[seg2[-1], seg2[0]])\n        old_cost2 = (distance_matrix_2[seg1[-1], seg1[0]] +\n                    distance_matrix_2[seg2[-1], seg2[0]])\n\n        new_cost1 = (distance_matrix_1[seg1[-1], seg2[0]] +\n                    distance_matrix_1[seg2[-1], seg1[0]])\n        new_cost2 = (distance_matrix_2[seg1[-1], seg2[0]] +\n                    distance_matrix_2[seg2[-1], seg1[0]])\n\n        if (new_cost1 + new_cost2 < old_cost1 + old_cost2 and\n            np.random.random() < 0.6):\n            # Perform segment swap\n            segments[seg1_idx], segments[seg2_idx] = segments[seg2_idx], segments[seg1_idx]\n\n    # Dynamic segment merging\n    for _ in range(2):\n        if len(segments) < 2:\n            break\n\n        for i in range(len(segments)-1):\n            seg1 = segments[i]\n            seg2 = segments[i+1]\n\n            combined_cost1 = distance_matrix_1[seg1[-1], seg2[0]]\n            combined_cost2 = distance_matrix_2[seg1[-1], seg2[0]]\n\n            if combined_cost1 < threshold1 and combined_cost2 < threshold2:\n                segments[i] = seg1 + seg2\n                del segments[i+1]\n                break\n\n    # Constrained segment splitting\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        for i in range(len(segments)):\n            segment = segments[i]\n            if len(segment) < 4:\n                continue\n\n            # Calculate internal edge diversity\n            internal_costs1 = [distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1)]\n            internal_costs2 = [distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1)]\n            diversity1 = np.std(internal_costs1)\n            diversity2 = np.std(internal_costs2)\n\n            if diversity1 > 0.4 * np.mean(internal_costs1) or diversity2 > 0.4 * np.mean(internal_costs2):\n                split_pos = len(segment) // 2\n                segments[i] = segment[:split_pos]\n                segments.insert(i+1, segment[split_pos:])\n                break\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining adaptive objective-space segmentation with multi-dimensional path inversion and selective edge refinement, which first partitions the solution into dynamic segments based on the combined spatial proximity and edge strength in both objective spaces, then selectively inverts segments of the tour while considering their potential to improve both objectives, followed by a guided edge refinement phase that prioritizes edges with complementary improvement potential in both objectives while dynamically adjusting the refinement scope based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    segments.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        if seg1_end <= seg2_idx or seg2_end <= seg1_idx:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[seg1_idx-1], new_solution[seg1_idx]] +\n                   distance_matrix_1[new_solution[seg1_end-1], new_solution[seg1_end%n]] +\n                   distance_matrix_1[new_solution[seg2_idx-1], new_solution[seg2_idx]] +\n                   distance_matrix_1[new_solution[seg2_end-1], new_solution[seg2_end%n]] +\n                   distance_matrix_2[new_solution[seg1_idx-1], new_solution[seg1_idx]] +\n                   distance_matrix_2[new_solution[seg1_end-1], new_solution[seg1_end%n]] +\n                   distance_matrix_2[new_solution[seg2_idx-1], new_solution[seg2_idx]] +\n                   distance_matrix_2[new_solution[seg2_end-1], new_solution[seg2_end%n]])\n\n        candidate = new_solution.copy()\n        candidate[seg1_idx:seg1_end] = candidate[seg1_idx:seg1_end][::-1]\n        candidate[seg2_idx:seg2_end] = candidate[seg2_idx:seg2_end][::-1]\n\n        new_cost = (distance_matrix_1[candidate[seg1_idx-1], candidate[seg1_idx]] +\n                   distance_matrix_1[candidate[seg1_end-1], candidate[seg1_end%n]] +\n                   distance_matrix_1[candidate[seg2_idx-1], candidate[seg2_idx]] +\n                   distance_matrix_1[candidate[seg2_end-1], candidate[seg2_end%n]] +\n                   distance_matrix_2[candidate[seg1_idx-1], candidate[seg1_idx]] +\n                   distance_matrix_2[candidate[seg1_end-1], candidate[seg1_end%n]] +\n                   distance_matrix_2[candidate[seg2_idx-1], candidate[seg2_idx]] +\n                   distance_matrix_2[candidate[seg2_end-1], candidate[seg2_end%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                   distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                   distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                   distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        if abs(i - j) == 1:\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n        else:\n            if i < j:\n                candidate[i:j] = candidate[i:j][::-1]\n            else:\n                candidate[j:i] = candidate[j:i][::-1]\n\n        new_cost = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                   distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_1[candidate[j-1], candidate[j]] +\n                   distance_matrix_1[candidate[j], candidate[(j+1)%n]] +\n                   distance_matrix_2[candidate[i-1], candidate[i]] +\n                   distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_2[candidate[j-1], candidate[j]] +\n                   distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach that combines adaptive multi-objective path decomposition with dynamic segment reassembly, which first decomposes the solution into variable-length segments based on the combined spatial and objective-aware edge characteristics, then selectively reassembles these segments by considering their potential to improve both objectives, followed by a probabilistic segment rotation phase that dynamically adjusts the rotation direction based on the current solution's segment structure and the relative improvement potential in both objectives, and concludes with a constrained segment inversion phase that prioritizes segments with complementary improvement potential across both objectives, while maintaining feasibility through a permutation-aware validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate edge characteristics\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        combined_cost = edge_cost1 + edge_cost2\n\n        # Calculate spatial coherence\n        coord1_prev = instance[new_solution[i-1], :2]\n        coord1_curr = instance[new_solution[i], :2]\n        coord2_prev = instance[new_solution[i-1], 2:]\n        coord2_curr = instance[new_solution[i], 2:]\n        spatial_dist1 = np.linalg.norm(coord1_curr - coord1_prev)\n        spatial_dist2 = np.linalg.norm(coord2_curr - coord2_prev)\n\n        # Segment decision\n        if (combined_cost > 1.5 * np.mean([distance_matrix_1.mean(), distance_matrix_2.mean()]) or\n            spatial_dist1 > 2 * np.mean(spatial_dist1) or\n            spatial_dist2 > 2 * np.mean(spatial_dist2)):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Dynamic segment reassembly\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        # Select two random segments\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n        old_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n\n        new_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        new_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Reassemble segments\n            new_segments = segments.copy()\n            new_segments[seg1_idx] = seg2 + seg1\n            new_segments[seg2_idx] = []\n\n            # Update solution\n            new_solution = np.concatenate([s for s in new_segments if s])\n            segments = [s for s in new_segments if s]\n\n    # Probabilistic segment rotation\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 2:\n            continue\n\n        # Calculate rotation potential\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try both rotation directions\n        rotated1 = segment[1:] + [segment[0]]\n        rotated2 = [segment[-1]] + segment[:-1]\n\n        new_cost1_1 = sum(distance_matrix_1[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n        new_cost2_1 = sum(distance_matrix_2[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n\n        new_cost1_2 = sum(distance_matrix_1[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n        new_cost2_2 = sum(distance_matrix_2[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n\n        if (new_cost1_1 + new_cost2_1 < old_cost1 + old_cost2 and\n            np.random.random() < 0.7):\n            segments[seg_idx] = rotated1\n        elif (new_cost1_2 + new_cost2_2 < old_cost1 + old_cost2 and\n              np.random.random() < 0.7):\n            segments[seg_idx] = rotated2\n\n    # Constrained segment inversion\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 3:\n            continue\n\n        # Select inversion points\n        inv_start = np.random.randint(0, len(segment)-2)\n        inv_end = np.random.randint(inv_start+1, len(segment))\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_1[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n        old_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_2[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n\n        new_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_1[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n        new_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_2[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Perform inversion\n            segments[seg_idx] = segment[:inv_start] + segment[inv_start:inv_end+1][::-1] + segment[inv_end+1:]\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 305,
          "algorithm": "{The new algorithm introduces a novel approach called \"Adaptive Multi-Dimensional Path Fusion and Selective Edge Rebalancing\" that first identifies critical path segments by analyzing the combined edge costs and spatial coherence across both objective spaces, then dynamically fuses adjacent segments based on their complementary improvement potential while maintaining the tour's connectivity, followed by a probabilistic edge rebalancing phase that selectively adjusts the path by moving nodes between segments to improve both objectives, and finally applies a constrained edge-swapping mechanism that prioritizes edges with balanced improvement potential across both objectives while dynamically adjusting the swap scope based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility through a permutation-aware validation mechanism.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical path segments\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate combined edge characteristics\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        combined_cost = edge_cost1 + edge_cost2\n\n        # Calculate spatial coherence\n        coord1_prev = instance[new_solution[i-1], :2]\n        coord1_curr = instance[new_solution[i], :2]\n        coord2_prev = instance[new_solution[i-1], 2:]\n        coord2_curr = instance[new_solution[i], 2:]\n        spatial_dist1 = np.linalg.norm(coord1_curr - coord1_prev)\n        spatial_dist2 = np.linalg.norm(coord2_curr - coord2_prev)\n\n        # Segment decision\n        if (combined_cost > 1.5 * np.mean([distance_matrix_1.mean(), distance_matrix_2.mean()]) or\n            spatial_dist1 > 2 * np.mean(spatial_dist1) or\n            spatial_dist2 > 2 * np.mean(spatial_dist2)):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Dynamic path fusion\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        # Select adjacent segments\n        seg1_idx = np.random.randint(0, len(segments)-1)\n        seg2_idx = seg1_idx + 1\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        old_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        new_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        new_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Fuse segments\n            segments[seg1_idx] = seg1 + seg2\n            segments.pop(seg2_idx)\n\n    # Probabilistic edge rebalancing\n    for _ in range(5):\n        if len(segments) < 2:\n            break\n\n        # Select random segments\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        if len(seg1) < 2 or len(seg2) < 2:\n            continue\n\n        # Select nodes to move\n        node1 = np.random.choice(seg1)\n        node2 = np.random.choice(seg2)\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[seg1[np.where(seg1 == node1)[0][0]-1], node1] +\n                    distance_matrix_1[node1, seg1[(np.where(seg1 == node1)[0][0]+1)%len(seg1)]] +\n                    distance_matrix_1[seg2[np.where(seg2 == node2)[0][0]-1], node2] +\n                    distance_matrix_1[node2, seg2[(np.where(seg2 == node2)[0][0]+1)%len(seg2)]])\n        old_cost2 = (distance_matrix_2[seg1[np.where(seg1 == node1)[0][0]-1], node1] +\n                    distance_matrix_2[node1, seg1[(np.where(seg1 == node1)[0][0]+1)%len(seg1)]] +\n                    distance_matrix_2[seg2[np.where(seg2 == node2)[0][0]-1], node2] +\n                    distance_matrix_2[node2, seg2[(np.where(seg2 == node2)[0][0]+1)%len(seg2)]])\n\n        # Swap nodes\n        new_seg1 = seg1.copy()\n        new_seg2 = seg2.copy()\n        new_seg1[np.where(new_seg1 == node1)[0][0]] = node2\n        new_seg2[np.where(new_seg2 == node2)[0][0]] = node1\n\n        new_cost1 = (distance_matrix_1[new_seg1[np.where(new_seg1 == node2)[0][0]-1], node2] +\n                    distance_matrix_1[node2, new_seg1[(np.where(new_seg1 == node2)[0][0]+1)%len(new_seg1)]] +\n                    distance_matrix_1[new_seg2[np.where(new_seg2 == node1)[0][0]-1], node1] +\n                    distance_matrix_1[node1, new_seg2[(np.where(new_seg2 == node1)[0][0]+1)%len(new_seg2)]])\n        new_cost2 = (distance_matrix_2[new_seg1[np.where(new_seg1 == node2)[0][0]-1], node2] +\n                    distance_matrix_2[node2, new_seg1[(np.where(new_seg1 == node2)[0][0]+1)%len(new_seg1)]] +\n                    distance_matrix_2[new_seg2[np.where(new_seg2 == node1)[0][0]-1], node1] +\n                    distance_matrix_2[node1, new_seg2[(np.where(new_seg2 == node1)[0][0]+1)%len(new_seg2)]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            segments[seg1_idx] = new_seg1\n            segments[seg2_idx] = new_seg2\n\n    # Constrained edge-swapping\n    for _ in range(3):\n        if n < 4:\n            break\n\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j or abs(i - j) == 1 or abs(i - j) == n-1:\n            continue\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution = candidate\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               7.005291242105968,
               6.849377111646744
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical path segments\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate combined edge characteristics\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        combined_cost = edge_cost1 + edge_cost2\n\n        # Calculate spatial coherence\n        coord1_prev = instance[new_solution[i-1], :2]\n        coord1_curr = instance[new_solution[i], :2]\n        coord2_prev = instance[new_solution[i-1], 2:]\n        coord2_curr = instance[new_solution[i], 2:]\n        spatial_dist1 = np.linalg.norm(coord1_curr - coord1_prev)\n        spatial_dist2 = np.linalg.norm(coord2_curr - coord2_prev)\n\n        # Segment decision\n        if (combined_cost > 1.5 * np.mean([distance_matrix_1.mean(), distance_matrix_2.mean()]) or\n            spatial_dist1 > 2 * np.mean(spatial_dist1) or\n            spatial_dist2 > 2 * np.mean(spatial_dist2)):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Dynamic path fusion\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        # Select adjacent segments\n        seg1_idx = np.random.randint(0, len(segments)-1)\n        seg2_idx = seg1_idx + 1\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        old_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        new_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        new_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Fuse segments\n            segments[seg1_idx] = seg1 + seg2\n            segments.pop(seg2_idx)\n\n    # Probabilistic edge rebalancing\n    for _ in range(5):\n        if len(segments) < 2:\n            break\n\n        # Select random segments\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        if len(seg1) < 2 or len(seg2) < 2:\n            continue\n\n        # Select nodes to move\n        node1 = np.random.choice(seg1)\n        node2 = np.random.choice(seg2)\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[seg1[np.where(seg1 == node1)[0][0]-1], node1] +\n                    distance_matrix_1[node1, seg1[(np.where(seg1 == node1)[0][0]+1)%len(seg1)]] +\n                    distance_matrix_1[seg2[np.where(seg2 == node2)[0][0]-1], node2] +\n                    distance_matrix_1[node2, seg2[(np.where(seg2 == node2)[0][0]+1)%len(seg2)]])\n        old_cost2 = (distance_matrix_2[seg1[np.where(seg1 == node1)[0][0]-1], node1] +\n                    distance_matrix_2[node1, seg1[(np.where(seg1 == node1)[0][0]+1)%len(seg1)]] +\n                    distance_matrix_2[seg2[np.where(seg2 == node2)[0][0]-1], node2] +\n                    distance_matrix_2[node2, seg2[(np.where(seg2 == node2)[0][0]+1)%len(seg2)]])\n\n        # Swap nodes\n        new_seg1 = seg1.copy()\n        new_seg2 = seg2.copy()\n        new_seg1[np.where(new_seg1 == node1)[0][0]] = node2\n        new_seg2[np.where(new_seg2 == node2)[0][0]] = node1\n\n        new_cost1 = (distance_matrix_1[new_seg1[np.where(new_seg1 == node2)[0][0]-1], node2] +\n                    distance_matrix_1[node2, new_seg1[(np.where(new_seg1 == node2)[0][0]+1)%len(new_seg1)]] +\n                    distance_matrix_1[new_seg2[np.where(new_seg2 == node1)[0][0]-1], node1] +\n                    distance_matrix_1[node1, new_seg2[(np.where(new_seg2 == node1)[0][0]+1)%len(new_seg2)]])\n        new_cost2 = (distance_matrix_2[new_seg1[np.where(new_seg1 == node2)[0][0]-1], node2] +\n                    distance_matrix_2[node2, new_seg1[(np.where(new_seg1 == node2)[0][0]+1)%len(new_seg1)]] +\n                    distance_matrix_2[new_seg2[np.where(new_seg2 == node1)[0][0]-1], node1] +\n                    distance_matrix_2[node1, new_seg2[(np.where(new_seg2 == node1)[0][0]+1)%len(new_seg2)]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            segments[seg1_idx] = new_seg1\n            segments[seg2_idx] = new_seg2\n\n    # Constrained edge-swapping\n    for _ in range(3):\n        if n < 4:\n            break\n\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j or abs(i - j) == 1 or abs(i - j) == n-1:\n            continue\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution = candidate\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining adaptive objective-space segmentation with multi-dimensional path inversion and selective edge refinement, which first partitions the solution into dynamic segments based on the combined spatial proximity and edge strength in both objective spaces, then selectively inverts segments of the tour while considering their potential to improve both objectives, followed by a guided edge refinement phase that prioritizes edges with complementary improvement potential in both objectives while dynamically adjusting the refinement scope based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    segments.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        if seg1_end <= seg2_idx or seg2_end <= seg1_idx:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[seg1_idx-1], new_solution[seg1_idx]] +\n                   distance_matrix_1[new_solution[seg1_end-1], new_solution[seg1_end%n]] +\n                   distance_matrix_1[new_solution[seg2_idx-1], new_solution[seg2_idx]] +\n                   distance_matrix_1[new_solution[seg2_end-1], new_solution[seg2_end%n]] +\n                   distance_matrix_2[new_solution[seg1_idx-1], new_solution[seg1_idx]] +\n                   distance_matrix_2[new_solution[seg1_end-1], new_solution[seg1_end%n]] +\n                   distance_matrix_2[new_solution[seg2_idx-1], new_solution[seg2_idx]] +\n                   distance_matrix_2[new_solution[seg2_end-1], new_solution[seg2_end%n]])\n\n        candidate = new_solution.copy()\n        candidate[seg1_idx:seg1_end] = candidate[seg1_idx:seg1_end][::-1]\n        candidate[seg2_idx:seg2_end] = candidate[seg2_idx:seg2_end][::-1]\n\n        new_cost = (distance_matrix_1[candidate[seg1_idx-1], candidate[seg1_idx]] +\n                   distance_matrix_1[candidate[seg1_end-1], candidate[seg1_end%n]] +\n                   distance_matrix_1[candidate[seg2_idx-1], candidate[seg2_idx]] +\n                   distance_matrix_1[candidate[seg2_end-1], candidate[seg2_end%n]] +\n                   distance_matrix_2[candidate[seg1_idx-1], candidate[seg1_idx]] +\n                   distance_matrix_2[candidate[seg1_end-1], candidate[seg1_end%n]] +\n                   distance_matrix_2[candidate[seg2_idx-1], candidate[seg2_idx]] +\n                   distance_matrix_2[candidate[seg2_end-1], candidate[seg2_end%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                   distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                   distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                   distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        if abs(i - j) == 1:\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n        else:\n            if i < j:\n                candidate[i:j] = candidate[i:j][::-1]\n            else:\n                candidate[j:i] = candidate[j:i][::-1]\n\n        new_cost = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                   distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_1[candidate[j-1], candidate[j]] +\n                   distance_matrix_1[candidate[j], candidate[(j+1)%n]] +\n                   distance_matrix_2[candidate[i-1], candidate[i]] +\n                   distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_2[candidate[j-1], candidate[j]] +\n                   distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm introduces a novel approach by combining dynamic objective-space aware path decomposition with adaptive multi-dimensional node swapping and insertion, which first decomposes the solution into dynamic path segments based on the relative improvement potential in both objective spaces and the current solution's structure, then performs an adaptive node swapping process that simultaneously considers both objectives to identify and swap nodes that promise balanced improvement in both objectives while dynamically adjusting the swapping scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from sklearn.metrics import pairwise_distances\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = pairwise_distances(coords1)\n    dist2 = pairwise_distances(coords2)\n\n    improvement_potential = np.zeros(n)\n    for i in range(n):\n        node = base_solution[i]\n        improvement_potential[i] = (np.sum(distance_matrix_1[node, :]) + np.sum(distance_matrix_2[node, :])) / (n-1)\n\n    sorted_indices = np.argsort(improvement_potential)[::-1]\n    segments = []\n    current_segment = [sorted_indices[0]]\n    for i in range(1, n):\n        if improvement_potential[sorted_indices[i]] > 0.7 * improvement_potential[current_segment[0]]:\n            current_segment.append(sorted_indices[i])\n        else:\n            if len(current_segment) > 1:\n                segments.append(current_segment)\n            current_segment = [sorted_indices[i]]\n    if len(current_segment) > 1:\n        segments.append(current_segment)\n\n    if not segments:\n        segments = [list(range(n))]\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 1:\n            break\n\n        segment = segments[np.random.randint(0, len(segments))]\n        if len(segment) < 2:\n            continue\n\n        i, j = np.random.choice(segment, 2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            if temp_cost1 + temp_cost2 < best_cost:\n                if abs(temp_cost1 - temp_cost2) < 0.5 * (current_cost1 + current_cost2):\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 306,
          "algorithm": "{The new algorithm introduces a hybrid approach by combining adaptive objective-space clustering with dynamic path decomposition and multi-dimensional edge crossover, which first clusters the solution nodes based on their combined spatial proximity and improvement potential across both objective spaces, then decomposes the tour into dynamic path segments while considering the relative improvement potential in each cluster and the current solution's structure, followed by a guided edge crossover phase that selectively exchanges edges between segments while prioritizing edges with complementary improvement potential in both objectives, and dynamically adjusting the crossover scope based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from sklearn.cluster import KMeans\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.hstack((coords1, coords2))\n\n    n_clusters = max(2, min(5, n // 4))\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(combined_coords)\n    labels = kmeans.labels_\n\n    segments = []\n    for cluster in range(n_clusters):\n        cluster_indices = np.where(labels == cluster)[0]\n        if len(cluster_indices) > 1:\n            segments.append(cluster_indices)\n\n    if not segments:\n        segments = [np.arange(n)]\n\n    np.random.shuffle(segments)\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        seg1 = segments[0]\n        seg2 = segments[1]\n\n        if len(seg1) < 2 or len(seg2) < 2:\n            continue\n\n        i = np.random.choice(seg1)\n        j = np.random.choice(seg2)\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution = candidate\n\n    for _ in range(min(5, n//3)):\n        seg = segments[np.random.randint(0, len(segments))]\n        if len(seg) < 3:\n            continue\n\n        i, j = np.random.choice(seg, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[i], candidate[j]])\n\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[i], candidate[j]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution = candidate\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.118012779233355,
               6.19785163829042
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from sklearn.cluster import KMeans\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.hstack((coords1, coords2))\n\n    n_clusters = max(2, min(5, n // 4))\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(combined_coords)\n    labels = kmeans.labels_\n\n    segments = []\n    for cluster in range(n_clusters):\n        cluster_indices = np.where(labels == cluster)[0]\n        if len(cluster_indices) > 1:\n            segments.append(cluster_indices)\n\n    if not segments:\n        segments = [np.arange(n)]\n\n    np.random.shuffle(segments)\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        seg1 = segments[0]\n        seg2 = segments[1]\n\n        if len(seg1) < 2 or len(seg2) < 2:\n            continue\n\n        i = np.random.choice(seg1)\n        j = np.random.choice(seg2)\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution = candidate\n\n    for _ in range(min(5, n//3)):\n        seg = segments[np.random.randint(0, len(segments))]\n        if len(seg) < 3:\n            continue\n\n        i, j = np.random.choice(seg, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[i], candidate[j]])\n\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[i], candidate[j]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution = candidate\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
     }
]