[
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the lowest combined objective value) and applies a novel 4-opt-inspired local search by randomly selecting four edges and reconnecting them in a non-standard way to explore higher-quality neighborhoods, ensuring feasibility by reversing segments and maintaining a circular tour. The key design idea is to prioritize the most promising solution while introducing diversity through a creative edge-reconnection strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[l:j+1][::-1],\n        new_solution[k:l+1][::-1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9964296678185147,
            0.10547882318496704
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on normalized objective diversity, then applies a hybrid local search combining adaptive segment operations (reversal/insertion) with probabilistic edge swaps, dynamically adjusting segment sizes and operation probabilities while ensuring tour feasibility through circular maintenance. The selection prioritizes solutions with diverse objectives, and the local search balances segment-based and edge-based operations, favoring improvements in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalized objective diversity selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment parameters\n    segment_size = max(3, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Dynamic operation selection with probability adjustment\n    operation_prob = 0.7 if np.random.rand() < 0.5 else 0.3\n    if np.random.rand() < operation_prob:\n        # Segment-based operation with insertion\n        segment = new_solution[start:end]\n        new_pos = np.random.randint(0, n - segment_size + 1)\n        if new_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n    else:\n        # Edge-based operation with probabilistic swap\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if (delta1 < 0 and delta2 < 0) or (delta1 <= 0 and delta2 < -0.1 * abs(delta2)) or (delta2 <= 0 and delta1 < -0.1 * abs(delta1)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -1.0185430357878715,
            0.564102828502655
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions from the archive based on objective balance scores, identifies correlated segments using distance ratio thresholds, and applies segment-based path inversions to improve both objectives while maintaining feasibility through circularity and uniqueness checks. It prioritizes solutions with balanced objectives and focuses on segments where edge ratios in both spaces are similar, using a dynamic inversion strategy to explore local improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = np.abs(normalized_obj[:, 0] - normalized_obj[:, 1])\n    selected_idx = np.argmin(balance_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment identification based on distance ratios\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        a = current_segment[-1]\n        b = base_solution[i]\n        ratio1 = distance_matrix_1[a, b] / (distance_matrix_1[a, :].mean() + 1e-10)\n        ratio2 = distance_matrix_2[a, b] / (distance_matrix_2[a, :].mean() + 1e-10)\n\n        if abs(ratio1 - ratio2) < 0.3:  # Tight ratio threshold\n            current_segment.append(b)\n        else:\n            if len(current_segment) > 1:\n                segments.append(current_segment)\n            current_segment = [a, b]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment)\n\n    # Path inversion within segments\n    for segment in segments:\n        if len(segment) < 3:\n            continue\n\n        # Find inversion that improves both objectives\n        best_delta1, best_delta2 = 0, 0\n        best_inversion = None\n\n        for i in range(len(segment)):\n            for j in range(i+1, len(segment)):\n                a, b = segment[i], segment[j]\n                a_pos = np.where(new_solution == a)[0][0]\n                b_pos = np.where(new_solution == b)[0][0]\n\n                # Original edges\n                original_edges = [(new_solution[a_pos], new_solution[(a_pos+1)%n]),\n                                (new_solution[b_pos], new_solution[(b_pos+1)%n])]\n\n                # New edges after inversion\n                if a_pos < b_pos:\n                    inverted_part = new_solution[a_pos:b_pos+1][::-1]\n                    new_edges = [(inverted_part[0], inverted_part[-1]),\n                                (inverted_part[-1], new_solution[(b_pos+1)%n])]\n                else:\n                    inverted_part = np.concatenate([new_solution[a_pos:], new_solution[:b_pos+1]])[::-1]\n                    new_edges = [(inverted_part[0], inverted_part[-1]),\n                                (inverted_part[-1], new_solution[(b_pos+1)%n])]\n\n                # Calculate delta for both objectives\n                delta1 = sum(distance_matrix_1[u, v] for u, v in new_edges) - sum(distance_matrix_1[u, v] for u, v in original_edges)\n                delta2 = sum(distance_matrix_2[u, v] for u, v in new_edges) - sum(distance_matrix_2[u, v] for u, v in original_edges)\n\n                if delta1 < best_delta1 and delta2 < best_delta2:\n                    best_delta1, best_delta2 = delta1, delta2\n                    best_inversion = (a_pos, b_pos)\n\n        if best_inversion:\n            a_pos, b_pos = best_inversion\n            if a_pos < b_pos:\n                new_solution[a_pos:b_pos+1] = new_solution[a_pos:b_pos+1][::-1]\n            else:\n                inverted_part = np.concatenate([new_solution[a_pos:], new_solution[:b_pos+1]])[::-1]\n                new_solution[:b_pos+1] = inverted_part[b_pos+1:]\n                new_solution[a_pos:] = inverted_part[:len(new_solution)-b_pos-1]\n\n    # Ensure circularity and feasibility\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -1.0293022169243033,
            2.6165501475334167
        ]
    },
    {
        "algorithm": "The algorithm selects a nondominated solution with high crowding distance from the archive, identifies correlated segments by analyzing edge ratios in both objective spaces, and applies a correlated 3-opt local search to improve both objectives while maintaining tour feasibility. It prioritizes solutions with diverse trade-offs (high crowding distance) and focuses local search on segments where edge correlations between objectives are strong, avoiding the standard 2-opt approach.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    is_nondominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                is_nondominated[i] = False\n                break\n\n    nondominated_idx = np.where(is_nondominated)[0]\n    if len(nondominated_idx) == 0:\n        nondominated_idx = np.arange(len(archive))\n\n    # Select solution with highest crowding distance\n    crowding_distances = np.zeros(len(nondominated_idx))\n    for i, idx in enumerate(nondominated_idx):\n        neighbors = np.delete(nondominated_idx, np.where(nondominated_idx == idx)[0])\n        if len(neighbors) == 0:\n            crowding_distances[i] = float('inf')\n            continue\n        for obj in range(2):\n            sorted_idx = np.argsort(objectives[neighbors, obj])\n            if len(sorted_idx) <= 1:\n                continue\n            crowding_distances[i] += (objectives[neighbors[sorted_idx[1]], obj] - objectives[neighbors[sorted_idx[0]], obj]) / (objectives[neighbors[sorted_idx[-1]], obj] - objectives[neighbors[sorted_idx[0]], obj] + 1e-10)\n\n    selected_idx = nondominated_idx[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic segment fusion\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        a = current_segment[-1]\n        b = base_solution[i]\n        ratio1 = distance_matrix_1[a, b] / (distance_matrix_1[a, :].mean() + 1e-10)\n        ratio2 = distance_matrix_2[a, b] / (distance_matrix_2[a, :].mean() + 1e-10)\n        if abs(ratio1 - ratio2) < 0.3:\n            current_segment.append(b)\n        else:\n            if len(current_segment) > 1:\n                segments.append(current_segment)\n            current_segment = [a, b]\n    if len(current_segment) > 1:\n        segments.append(current_segment)\n\n    # Correlated 3-opt local search\n    for segment in segments:\n        if len(segment) < 3:\n            continue\n        for i in range(len(segment)):\n            for j in range(i+1, len(segment)):\n                for k in range(j+1, len(segment)):\n                    a, b, c = segment[i], segment[j], segment[k]\n                    a_pos = np.where(new_solution == a)[0][0]\n                    b_pos = np.where(new_solution == b)[0][0]\n                    c_pos = np.where(new_solution == c)[0][0]\n\n                    # Original edges\n                    original_edges = [(new_solution[a_pos], new_solution[(a_pos+1)%n]),\n                                    (new_solution[b_pos], new_solution[(b_pos+1)%n]),\n                                    (new_solution[c_pos], new_solution[(c_pos+1)%n])]\n\n                    # New edges after 3-opt\n                    new_edges = [(new_solution[a_pos], new_solution[c_pos]),\n                               (new_solution[b_pos], new_solution[a_pos]),\n                               (new_solution[c_pos], new_solution[b_pos])]\n\n                    # Calculate delta for both objectives\n                    delta1 = sum(distance_matrix_1[u, v] for u, v in new_edges) - sum(distance_matrix_1[u, v] for u, v in original_edges)\n                    delta2 = sum(distance_matrix_2[u, v] for u, v in new_edges) - sum(distance_matrix_2[u, v] for u, v in original_edges)\n\n                    if delta1 < 0 and delta2 < 0:\n                        # Apply the 3-opt move\n                        if a_pos < b_pos < c_pos:\n                            new_solution[a_pos:b_pos+1] = new_solution[a_pos:b_pos+1][::-1]\n                            new_solution[b_pos:c_pos+1] = new_solution[b_pos:c_pos+1][::-1]\n                        elif a_pos < c_pos < b_pos:\n                            new_solution[a_pos:c_pos+1] = new_solution[a_pos:c_pos+1][::-1]\n                        else:\n                            new_solution[b_pos:c_pos+1] = new_solution[b_pos:c_pos+1][::-1]\n\n    # Ensure circularity and feasibility\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -1.0486684943523956,
            5.2085713148117065
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective) and applies a novel 4-opt-inspired local search by randomly selecting four edges, reversing segments between them, and reconnecting them to explore a larger neighborhood while ensuring feasibility. It prioritizes solutions with lower total cost and dynamically modifies the tour by segment reversal and concatenation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        new_solution[b:c+1][::-1],\n        new_solution[d:],\n        new_solution[a+1:b+1][::-1],\n        new_solution[c+1:d+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9715020941909596,
            0.14212608337402344
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on crowding distance in the Pareto front, then generates a neighbor by adaptively extracting and inserting a rotated segment from another solution, ensuring feasibility through uniqueness checks and circular validation. It dynamically adjusts the segment size and rotation based on solution quality, prioritizing well-distributed solutions for better exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for Pareto front solutions\n    nondominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol1, obj1))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Sort nondominated solutions by crowding distance (descending)\n    crowding_distances = []\n    for sol, obj in nondominated:\n        # Calculate distances to neighbors in objective space\n        left = right = None\n        for other_sol, other_obj in nondominated:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                if left is None or (other_obj[0] > left[0] and other_obj[1] > left[1]):\n                    left = other_obj\n            if other_obj[0] > obj[0] and other_obj[1] > obj[1]:\n                if right is None or (other_obj[0] < right[0] and other_obj[1] < right[1]):\n                    right = other_obj\n        # Calculate crowding distance\n        if left is None or right is None:\n            crowding_distances.append(float('inf'))\n        else:\n            crowding_distances.append((right[0] - left[0]) + (right[1] - left[1]))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = nondominated[selected_idx][0].copy()\n\n    # Select a random solution from the entire archive for crossover\n    crossover_idx = np.random.randint(0, len(archive))\n    crossover_solution = archive[crossover_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment size based on solution quality\n    segment_size = max(2, int(0.3 * n * (1 - np.random.rand() * 0.4)))\n    start = np.random.randint(0, n - segment_size + 1)\n\n    # Extract the segment from the crossover solution\n    segment = crossover_solution[start:start + segment_size]\n\n    # Find the position to insert the segment in the selected solution\n    insert_pos = np.random.randint(0, n - segment_size + 1)\n\n    # Rotate the segment based on distance metrics\n    rotate_amount = np.random.randint(0, segment_size)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n\n    # Insert the rotated segment into the selected solution\n    new_solution = np.concatenate([\n        selected_solution[:insert_pos],\n        rotated_segment,\n        selected_solution[insert_pos + segment_size:]\n    ])\n\n    # Ensure uniqueness and validity\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -1.006136939204562,
            1.0287234783172607
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by balancing objective diversity (70%) and quality (30%), then applies a hybrid local search combining segment reversal, probabilistic edge swaps, and segment-edge hybrid operations, with adaptive probabilities and objective-aware improvements, while ensuring tour feasibility through circular validation. Critical design choices include dynamic operation selection (40% segment, 30% edge, 30% hybrid) and aggressive improvement acceptance criteria that prioritize simultaneous or significant unilateral objective improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Enhanced selection based on normalized objective diversity and solution quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.sum(normalized, axis=1)\n    quality = 1 / (1 + np.sum(objectives, axis=1))\n    combined_score = 0.7 * diversity + 0.3 * quality\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment selection mechanism\n    segment_size = max(3, int(np.ceil(n * 0.15 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Dynamic operation selection with adaptive probabilities\n    operation_type = np.random.choice(['segment', 'edge', 'hybrid'], p=[0.4, 0.3, 0.3])\n\n    if operation_type == 'segment':\n        # Adaptive segment reversal with position-based probability\n        segment = new_solution[start:end]\n        new_pos = np.random.randint(0, n - segment_size + 1)\n        if np.random.rand() < 0.6:  # Higher probability for reversal\n            segment = segment[::-1]\n        if new_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n\n    elif operation_type == 'edge':\n        # Probabilistic edge swap with objective-aware selection\n        for _ in range(3):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            # More aggressive improvement acceptance\n            if (delta1 < 0 and delta2 < 0) or (delta1 <= 0 and delta2 < -0.2 * abs(delta2)) or (delta2 <= 0 and delta1 < -0.2 * abs(delta1)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    else:  # hybrid operation\n        # Combined segment and edge operation\n        segment = new_solution[start:end]\n        segment = segment[::-1] if np.random.rand() < 0.5 else segment\n        new_pos = np.random.randint(0, n - segment_size + 1)\n        if new_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n\n        # Additional edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if (delta1 < 0 and delta2 < 0) or (delta1 <= 0 and delta2 < -0.15 * abs(delta2)) or (delta2 <= 0 and delta1 < -0.15 * abs(delta1)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9940962108637836,
            0.8415762186050415
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid metric (60% diversity, 40% quality) and applies a novel hybrid local search combining segment insertion (50%), edge flips (30%), and hybrid operations (20%), with aggressive improvement criteria favoring unilateral improvements in either objective. It ensures feasibility by maintaining a valid TSP tour structure throughout operations. The selection prioritizes solutions with diverse objectives while the local search dynamically balances exploration and exploitation through probabilistic operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on normalized diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.sum(normalized, axis=1)\n    quality = 1 / (1 + np.sum(objectives, axis=1))\n    combined_score = 0.6 * diversity + 0.4 * quality\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_size = max(2, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Operation selection with different probabilities\n    operation_type = np.random.choice(['segment', 'edge', 'hybrid'], p=[0.5, 0.3, 0.2])\n\n    if operation_type == 'segment':\n        # Segment insertion with position-based probability\n        segment = new_solution[start:end]\n        new_pos = np.random.randint(0, n - segment_size + 1)\n        if np.random.rand() < 0.7:  # Higher probability for insertion\n            if new_pos > start:\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n            else:\n                new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n\n    elif operation_type == 'edge':\n        # Probabilistic edge flip with relaxed improvement criteria\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i == j:\n                continue\n\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            if (delta1 < 0 or delta2 < 0) or (delta1 <= 0.1 * abs(delta1) and delta2 <= 0.1 * abs(delta2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    else:  # hybrid operation\n        # Combined segment and edge operation\n        segment = new_solution[start:end]\n        new_pos = np.random.randint(0, n - segment_size + 1)\n        if new_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n\n        # Additional edge flip\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            if (delta1 <= 0.2 * abs(delta1) and delta2 <= 0.2 * abs(delta2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9834172551405187,
            0.6872926354408264
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid quality-diversity metric (60% quality, 40% diversity), then applies a novel local search operator that adaptively combines segment inversion, probabilistic edge swaps, and dynamic path relinking, with segment size and operation probabilities adjusted based on position and improvement potential. It ensures feasibility by validating the tour structure and dynamically adjusting segment sizes, while prioritizing operations that improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection metric (60% quality, 40% diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.sum(normalized, axis=1)\n    quality = 1 / (1 + np.sum(objectives, axis=1))\n    combined_score = 0.6 * quality + 0.4 * diversity\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment parameters\n    segment_size = max(2, int(np.ceil(n * 0.25 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Adaptive operation selection\n    operation_weights = [0.5, 0.3, 0.2]  # segment, edge, path_relink\n    operation_type = np.random.choice(['segment', 'edge', 'path_relink'], p=operation_weights)\n\n    if operation_type == 'segment':\n        # Adaptive segment inversion with position bias\n        segment = new_solution[start:end]\n        inversion_prob = 0.8 if (start < n/3 or end > 2*n/3) else 0.3\n        if np.random.rand() < inversion_prob:\n            new_solution[start:end] = segment[::-1]\n\n    elif operation_type == 'edge':\n        # Probabilistic edge swap with adaptive acceptance\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            accept_prob = 0.7 if (delta1 < 0 or delta2 < 0) else 0.2\n            if np.random.rand() < accept_prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # path relinking\n        # Dynamic path relinking with multiple guide points\n        target_idx = np.random.randint(0, len(archive))\n        target_solution = archive[target_idx][0]\n        guide_points = sorted(np.random.choice(n, size=min(3, n//4), replace=False))\n        for i in range(len(guide_points)-1):\n            new_solution[guide_points[i]:guide_points[i+1]] = target_solution[guide_points[i]:guide_points[i+1]]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9847870719202687,
            0.7926353216171265
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-dominance filtering with a multi-phase local search that adaptively selects between segment shuffling, biased edge swaps, and objective-weighted path relinking, using dynamic segment sizes and operation probabilities that evolve based on recent improvement trends across both objectives. It prioritizes quality (70%) and diversity (20%) in solution selection, with a smaller weight (10%) for recent improvement, and dynamically adjusts segment sizes and operation weights based on objective values. The method ensures feasibility by maintaining circular tours and uses distance matrices to evaluate improvements in both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance filtering\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Multi-criteria selection (70% quality, 20% diversity, 10% recent improvement)\n    objectives = np.array([obj for _, obj in pareto_front])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.sum(normalized, axis=1)\n    quality = 1 / (1 + np.sum(objectives, axis=1))\n    recent_improvement = np.array([1 - (np.sum(obj) / np.sum(archive[i][1])) for i, (_, obj) in enumerate(pareto_front)])\n    combined_score = 0.7 * quality + 0.2 * diversity + 0.1 * recent_improvement\n    selected_idx = np.argmax(combined_score)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment parameters with objective weighting\n    obj_weights = objectives[selected_idx] / np.sum(objectives[selected_idx])\n    segment_size = max(2, int(np.ceil(n * 0.3 * (1 + np.random.rand() * obj_weights[0]))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Adaptive multi-phase operation selection\n    phase_weights = [0.4, 0.3, 0.3]  # segment, edge, path_relink\n    operation_type = np.random.choice(['segment', 'edge', 'path_relink'], p=phase_weights)\n\n    if operation_type == 'segment':\n        # Objective-weighted segment shuffling\n        segment = new_solution[start:end]\n        if np.random.rand() < 0.7 * obj_weights[0] + 0.3 * obj_weights[1]:\n            np.random.shuffle(segment)\n            new_solution[start:end] = segment\n\n    elif operation_type == 'edge':\n        # Bi-objective edge swap with adaptive probability\n        for _ in range(3):\n            i, j = np.random.choice(n, 2, replace=False)\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            accept_prob = 0.6 * (1 - delta1/np.max(distance_matrix_1)) + 0.4 * (1 - delta2/np.max(distance_matrix_2))\n            if np.random.rand() < accept_prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # path relinking\n        # Weighted path relinking with multiple guide points\n        target_idx = np.random.randint(0, len(pareto_front))\n        target_solution = pareto_front[target_idx][0]\n        guide_points = sorted(np.random.choice(n, size=min(4, n//3), replace=False))\n        for i in range(len(guide_points)-1):\n            if np.random.rand() < 0.8 * obj_weights[0] + 0.2 * obj_weights[1]:\n                new_solution[guide_points[i]:guide_points[i+1]] = target_solution[guide_points[i]:guide_points[i+1]]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -1.011559380074957,
            1.563021719455719
        ]
    }
]