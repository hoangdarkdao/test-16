[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects a solution from the archive based on high cost variance between objectives, then applies a hybrid local search combining segment reversals and edge swaps to generate a neighbor, ensuring feasibility by reverting to a simple swap if needed. The selection prioritizes solutions with diverse objective trade-offs, while the local search explores both large-scale and small-scale modifications to the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5751062064606985,
            3.102009952068329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects a solution from the archive based on high cost variance between objectives, then applies a hybrid local search combining segment reversals and edge swaps to generate a neighbor, ensuring feasibility by reverting to a simple swap if needed. The selection prioritizes solutions with diverse objective trade-offs, while the local search explores both large-scale and small-scale modifications to the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5751062064606985,
            3.102009952068329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects a solution from the archive based on high cost variance between objectives, then applies a hybrid local search combining segment reversals and edge swaps to generate a neighbor, ensuring feasibility by reverting to a simple swap if needed. The selection prioritizes solutions with diverse objective trade-offs, while the local search explores both large-scale and small-scale modifications to the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5751062064606985,
            3.102009952068329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6874673169254132,
            2.7654505372047424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6874673169254132,
            2.7654505372047424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6874673169254132,
            2.7654505372047424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The algorithm selects a solution from the archive by choosing the one with the lowest combined objective cost, then applies a hybrid local search combining a segment reversal (similar to 3-opt) with a conditional edge swap that improves both objectives simultaneously. The selection prioritizes solutions with better overall performance, while the local search operator intelligently modifies the tour by reversing segments and conditionally swapping edges to enhance both objectives, ensuring feasibility through careful index handling.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best Pareto front contribution (simplified approach)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of the tour\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Step 2: Reverse the segment (similar to 3-opt but simpler)\n    segment_reversed = segment[::-1]\n    new_solution[a:b] = segment_reversed\n\n    # Step 3: Custom edge swap to improve both objectives\n    # Select two random edges and swap their endpoints if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Original edges: (i, i+1) and (j, j+1)\n        # New edges: (i, j) and (i+1, j+1)\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5881993442561746,
            3.750802159309387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best Pareto front contribution (simplified approach)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of the tour\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Step 2: Reverse the segment (similar to 3-opt but simpler)\n    segment_reversed = segment[::-1]\n    new_solution[a:b] = segment_reversed\n\n    # Step 3: Custom edge swap to improve both objectives\n    # Select two random edges and swap their endpoints if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Original edges: (i, i+1) and (j, j+1)\n        # New edges: (i, j) and (i+1, j+1)\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8778406030823818,
            7.070494771003723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8778406030823818,
            7.070494771003723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The algorithm prioritizes solutions with lower combined objective costs, selects the best one, and applies a hybrid local search combining edge-swap and node-insertion moves to generate a neighbor solution while ensuring feasibility. It randomly selects segments for edge-swap and nodes for reinsertion, maintaining tour validity through assertions. The design balances exploration (random selection) with exploitation (edge-swap focus), ensuring high-quality neighbors while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower total cost in both objectives)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a hybrid move: edge-swap followed by node-insertion\n    if n >= 4:\n        # Edge-swap: swap two non-adjacent edges\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Node-insertion: move a random node to a new position\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    # (This step is redundant here since we're only doing swaps and insertions, but included for completeness)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.702664249594278,
            7.1097691655159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower total cost in both objectives)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a hybrid move: edge-swap followed by node-insertion\n    if n >= 4:\n        # Edge-swap: swap two non-adjacent edges\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Node-insertion: move a random node to a new position\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    # (This step is redundant here since we're only doing swaps and insertions, but included for completeness)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive based on high cost variance between objectives, then applies a hybrid local search combining segment reversals and edge swaps to generate a neighbor, ensuring feasibility by reverting to a simple swap if needed. The selection prioritizes solutions with diverse objective trade-offs, while the local search explores both large-scale and small-scale modifications to the tour.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm selects high-variance solutions from the archive to focus on promising regions, then applies a hybrid local search combining adaptive segment reordering (reversal/rotation) and objective-aware edge swaps, prioritizing modifications based on which objective space shows greater improvement potential while ensuring feasibility through validation checks. The method dynamically balances exploration of large and small-scale changes and evaluates improvements in both objectives to guide the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (promising for improvement)\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering based on objective improvement potential\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    # Try multiple segment operations and keep the best improvement\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    for _ in range(3):  # Try multiple segment operations\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Adaptive segment operation: choose between reversal and rotation\n        if np.random.rand() > 0.5:\n            segment = temp_solution[a:b+1]\n            temp_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))\n        else:\n            temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate improvement in both objectives\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Objective-aware edge swap\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    # Perform edge swap based on which objective shows more potential\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    if cost1 > cost2:\n        # More improvement potential in first objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n    else:\n        # More improvement potential in second objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\n",
        "score": [
            -0.9067708948115636,
            9.070596873760223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (promising for improvement)\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering based on objective improvement potential\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    # Try multiple segment operations and keep the best improvement\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    for _ in range(3):  # Try multiple segment operations\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Adaptive segment operation: choose between reversal and rotation\n        if np.random.rand() > 0.5:\n            segment = temp_solution[a:b+1]\n            temp_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))\n        else:\n            temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate improvement in both objectives\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Objective-aware edge swap\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    # Perform edge swap based on which objective shows more potential\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    if cost1 > cost2:\n        # More improvement potential in first objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n    else:\n        # More improvement potential in second objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive based on high cost variance between objectives, then applies a hybrid local search combining segment reversals and edge swaps to generate a neighbor, ensuring feasibility by reverting to a simple swap if needed. The selection prioritizes solutions with diverse objective trade-offs, while the local search explores both large-scale and small-scale modifications to the tour.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm selects high-variance solutions from the archive to focus on promising regions, then applies a hybrid local search combining adaptive segment reordering (reversal/rotation) and objective-aware edge swaps, prioritizing modifications based on which objective space shows greater improvement potential while ensuring feasibility through validation checks. The method dynamically balances exploration of large and small-scale changes and evaluates improvements in both objectives to guide the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (promising for improvement)\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering based on objective improvement potential\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    # Try multiple segment operations and keep the best improvement\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    for _ in range(3):  # Try multiple segment operations\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Adaptive segment operation: choose between reversal and rotation\n        if np.random.rand() > 0.5:\n            segment = temp_solution[a:b+1]\n            temp_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))\n        else:\n            temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate improvement in both objectives\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Objective-aware edge swap\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    # Perform edge swap based on which objective shows more potential\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    if cost1 > cost2:\n        # More improvement potential in first objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n    else:\n        # More improvement potential in second objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\n",
        "score": [
            -0.9067708948115636,
            9.070596873760223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (promising for improvement)\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering based on objective improvement potential\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    # Try multiple segment operations and keep the best improvement\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    for _ in range(3):  # Try multiple segment operations\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Adaptive segment operation: choose between reversal and rotation\n        if np.random.rand() > 0.5:\n            segment = temp_solution[a:b+1]\n            temp_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))\n        else:\n            temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate improvement in both objectives\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Objective-aware edge swap\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    # Perform edge swap based on which objective shows more potential\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    if cost1 > cost2:\n        # More improvement potential in first objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n    else:\n        # More improvement potential in second objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive based on high cost variance between objectives, then applies a hybrid local search combining segment reversals and edge swaps to generate a neighbor, ensuring feasibility by reverting to a simple swap if needed. The selection prioritizes solutions with diverse objective trade-offs, while the local search explores both large-scale and small-scale modifications to the tour.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_idx = np.argmax(np.abs(costs - np.mean(costs)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt-like move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 7,
        "algorithm": "The algorithm selects two diverse solutions from the archive (based on objective variance) and blends segments from them into a new solution, prioritizing cost reduction in both objectives while ensuring feasibility through segment replacement and edge swaps. It leverages segment costs to identify optimal replacements and performs additional edge swaps for further exploration, balancing diversity and local improvement. The key design ideas are segment blending, cost-aware replacement, and feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_indices = np.argsort(np.abs(costs - np.mean(costs)))[-2:]  # Select top 2 most diverse\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Initialize new solution as a copy of one of the selected solutions\n    new_solution = sol1.copy()\n    n = len(new_solution)\n\n    # Blend segments from both solutions while preserving feasibility\n    # Randomly select a segment from each solution\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Extract segments\n    segment1 = sol1[a:b+1]\n    segment2 = sol2[c:d+1]\n\n    # Find positions to insert segments while maintaining tour validity\n    # Strategy: Replace a segment in new_solution with the best matching segment from sol2\n    # Calculate segment costs in both objectives\n    def segment_cost(seg, matrix1, matrix2):\n        cost1 = sum(matrix1[int(seg[i]), int(seg[i+1])] for i in range(len(seg)-1))\n        cost1 += matrix1[int(seg[-1]), int(seg[0])]  # Close the loop\n        cost2 = sum(matrix2[int(seg[i]), int(seg[i+1])] for i in range(len(seg)-1))\n        cost2 += matrix2[int(seg[-1]), int(seg[0])]\n        return cost1, cost2\n\n    # Find the best segment in sol2 to replace in new_solution\n    best_segment = None\n    best_cost = (float('inf'), float('inf'))\n    for i in range(n - len(segment2) + 1):\n        candidate_segment = new_solution[i:i+len(segment2)]\n        cost1, cost2 = segment_cost(candidate_segment, distance_matrix_1, distance_matrix_2)\n        if cost1 < best_cost[0] and cost2 < best_cost[1]:\n            best_segment = candidate_segment\n            best_cost = (cost1, cost2)\n\n    if best_segment is not None:\n        # Replace the best segment with segment2\n        start_pos = np.where((new_solution == best_segment[0]).astype(int))[0][0]\n        new_solution[start_pos:start_pos+len(segment2)] = segment2\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original segment\n        new_solution[start_pos:start_pos+len(segment2)] = best_segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8268093657259432,
            8.154948830604553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions with high diversity (high cost variance between objectives)\n    costs = np.array([obj[1] - obj[0] for _, obj in archive])\n    selected_indices = np.argsort(np.abs(costs - np.mean(costs)))[-2:]  # Select top 2 most diverse\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Initialize new solution as a copy of one of the selected solutions\n    new_solution = sol1.copy()\n    n = len(new_solution)\n\n    # Blend segments from both solutions while preserving feasibility\n    # Randomly select a segment from each solution\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Extract segments\n    segment1 = sol1[a:b+1]\n    segment2 = sol2[c:d+1]\n\n    # Find positions to insert segments while maintaining tour validity\n    # Strategy: Replace a segment in new_solution with the best matching segment from sol2\n    # Calculate segment costs in both objectives\n    def segment_cost(seg, matrix1, matrix2):\n        cost1 = sum(matrix1[int(seg[i]), int(seg[i+1])] for i in range(len(seg)-1))\n        cost1 += matrix1[int(seg[-1]), int(seg[0])]  # Close the loop\n        cost2 = sum(matrix2[int(seg[i]), int(seg[i+1])] for i in range(len(seg)-1))\n        cost2 += matrix2[int(seg[-1]), int(seg[0])]\n        return cost1, cost2\n\n    # Find the best segment in sol2 to replace in new_solution\n    best_segment = None\n    best_cost = (float('inf'), float('inf'))\n    for i in range(n - len(segment2) + 1):\n        candidate_segment = new_solution[i:i+len(segment2)]\n        cost1, cost2 = segment_cost(candidate_segment, distance_matrix_1, distance_matrix_2)\n        if cost1 < best_cost[0] and cost2 < best_cost[1]:\n            best_segment = candidate_segment\n            best_cost = (cost1, cost2)\n\n    if best_segment is not None:\n        # Replace the best segment with segment2\n        start_pos = np.where((new_solution == best_segment[0]).astype(int))[0][0]\n        new_solution[start_pos:start_pos+len(segment2)] = segment2\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original segment\n        new_solution[start_pos:start_pos+len(segment2)] = best_segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 8,
        "algorithm": "The algorithm selects a promising solution from the archive based on combined objective values and diversity, then applies a hybrid local search combining adaptive segment reversal, probabilistic edge swaps, and random node insertions to generate feasible neighbors while balancing exploration and exploitation. It prioritizes solutions with lower combined costs but introduces randomness to maintain diversity, and the local search operations are designed to improve both objectives simultaneously while ensuring tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best combined objective and good diversity\n    def score(sol_obj):\n        sol, obj = sol_obj\n        combined = sum(obj)\n        # Add small random factor to encourage diversity\n        return combined + np.random.uniform(0, 0.1)\n\n    selected = min(archive, key=score)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n\n    # Hybrid local search with three operations\n    # 1. Adaptive segment reversal\n    segment_size = max(2, min(N//2, int(np.random.normal(N//3, N//6))))\n    start = np.random.randint(0, N - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Decide whether to reverse or shift based on local improvement potential\n    if np.random.random() < 0.5:\n        new_solution[start:end] = segment[::-1]\n    else:\n        shift = np.random.randint(1, segment_size)\n        new_solution[start:end] = np.roll(segment, shift)\n\n    # 2. Probabilistic edge swaps based on objective improvement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        old_dist = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_1[base_solution[j], base_solution[(j+1)%N]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_2[base_solution[j], base_solution[(j+1)%N]])\n\n        new_dist = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                    distance_matrix_1[base_solution[i], base_solution[(j+1)%N]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                    distance_matrix_2[base_solution[i], base_solution[(j+1)%N]])\n\n        if new_dist < old_dist and np.random.random() < 0.7:  # Accept with 70% probability if better\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Random node insertion for diversification\n    if np.random.random() < 0.3:  # 30% chance\n        pos = np.random.randint(0, N)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Return original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7489019833823927,
            4.512559413909912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best combined objective and good diversity\n    def score(sol_obj):\n        sol, obj = sol_obj\n        combined = sum(obj)\n        # Add small random factor to encourage diversity\n        return combined + np.random.uniform(0, 0.1)\n\n    selected = min(archive, key=score)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n\n    # Hybrid local search with three operations\n    # 1. Adaptive segment reversal\n    segment_size = max(2, min(N//2, int(np.random.normal(N//3, N//6))))\n    start = np.random.randint(0, N - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Decide whether to reverse or shift based on local improvement potential\n    if np.random.random() < 0.5:\n        new_solution[start:end] = segment[::-1]\n    else:\n        shift = np.random.randint(1, segment_size)\n        new_solution[start:end] = np.roll(segment, shift)\n\n    # 2. Probabilistic edge swaps based on objective improvement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        old_dist = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_1[base_solution[j], base_solution[(j+1)%N]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_2[base_solution[j], base_solution[(j+1)%N]])\n\n        new_dist = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                    distance_matrix_1[base_solution[i], base_solution[(j+1)%N]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                    distance_matrix_2[base_solution[i], base_solution[(j+1)%N]])\n\n        if new_dist < old_dist and np.random.random() < 0.7:  # Accept with 70% probability if better\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Random node insertion for diversification\n    if np.random.random() < 0.3:  # 30% chance\n        pos = np.random.randint(0, N)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Return original if invalid\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 9,
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on combined objective values, then applies a hybrid local search combining node insertion and segment relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with lower total costs, while the local search explores the solution space through strategic node and segment movements. The overall structure balances exploration and exploitation by leveraging both objective-based selection and creative neighborhood generation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Weighted random selection based on objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (objectives + 1e-10)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion followed by segment relocation\n    # Randomly select a node to insert elsewhere\n    node_idx = np.random.randint(0, N)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Insert the node at a random position\n    insert_pos = np.random.randint(0, N)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Relocate a random segment\n    a, b = sorted(np.random.choice(N-1, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.7984737832569211,
            4.593028247356415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Weighted random selection based on objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (objectives + 1e-10)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion followed by segment relocation\n    # Randomly select a node to insert elsewhere\n    node_idx = np.random.randint(0, N)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Insert the node at a random position\n    insert_pos = np.random.randint(0, N)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Relocate a random segment\n    a, b = sorted(np.random.choice(N-1, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 2 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### Ineffective Self-Reflection\n- **Keywords**: *Premature convergence, dominated solutions, hybrid operators, feasibility checks*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (e.g., segment inversion + edge exchanges), ensure feasibility via assertions or rollback, and balance randomness.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Dominated solutions risk local optima; hybrid operators improve quality; assertions/rollback maintain validity; controlled randomness avoids instability.*\n\n### Heuristic Design\n1. **Selection**: Randomly pick a nondominated solution from the archive.\n2. **Local Search**:\n   - **Segment Inversion**: Randomly invert a segment of the tour.\n   - **Hybrid Edge Exchanges**: Perform 1\u20132 random edge swaps within the inverted segment.\n3. **Feasibility**: Assert the new tour is valid (no duplicates/missing nodes).\n4. **Output**: Return the neighbor solution.\n\n**Why?**\n- Nondominated solutions ensure high-potential perturbation.\n- Hybrid operators balance structure and exploration.\n- Assertions guarantee validity.\n- Controlled randomness avoids excessive disruption.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 10,
        "algorithm": "The algorithm selects a nondominated solution from the archive (using a simplified selection criterion), applies segment inversion to a random segment of the tour, performs hybrid edge exchanges within the inverted segment, and ensures feasibility through assertions. The key design ideas are prioritizing nondominated solutions, using segment inversion for exploration, and hybrid edge exchanges for local refinement while maintaining tour validity. The algorithm balances exploration and exploitation while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9306005521413345,
            10.212932527065277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 2 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### Ineffective Self-Reflection\n- **Keywords**: *Premature convergence, dominated solutions, hybrid operators, feasibility checks*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (e.g., segment inversion + edge exchanges), ensure feasibility via assertions or rollback, and balance randomness.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Dominated solutions risk local optima; hybrid operators improve quality; assertions/rollback maintain validity; controlled randomness avoids instability.*\n\n### Heuristic Design\n1. **Selection**: Randomly pick a nondominated solution from the archive.\n2. **Local Search**:\n   - **Segment Inversion**: Randomly invert a segment of the tour.\n   - **Hybrid Edge Exchanges**: Perform 1\u20132 random edge swaps within the inverted segment.\n3. **Feasibility**: Assert the new tour is valid (no duplicates/missing nodes).\n4. **Output**: Return the neighbor solution.\n\n**Why?**\n- Nondominated solutions ensure high-potential perturbation.\n- Hybrid operators balance structure and exploration.\n- Assertions guarantee validity.\n- Controlled randomness avoids excessive disruption.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 10,
        "algorithm": "The algorithm selects a nondominated solution from the archive (using a simplified selection criterion), applies segment inversion to a random segment of the tour, performs hybrid edge exchanges within the inverted segment, and ensures feasibility through assertions. The key design ideas are prioritizing nondominated solutions, using segment inversion for exploration, and hybrid edge exchanges for local refinement while maintaining tour validity. The algorithm balances exploration and exploitation while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9306005521413345,
            10.212932527065277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive (using a simplified selection criterion), applies segment inversion to a random segment of the tour, performs hybrid edge exchanges within the inverted segment, and ensures feasibility through assertions. The key design ideas are prioritizing nondominated solutions, using segment inversion for exploration, and hybrid edge exchanges for local refinement while maintaining tour validity. The algorithm balances exploration and exploitation while ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection\n- **Keywords**: *Premature convergence, dominated solutions, hybrid operators, feasibility checks*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (e.g., segment inversion + edge exchanges), ensure feasibility via assertions or rollback, and balance randomness.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Dominated solutions risk local optima; hybrid operators improve quality; assertions/rollback maintain validity; controlled randomness avoids instability.*\n\n### Heuristic Design\n1. **Selection**: Randomly pick a nondominated solution from the archive.\n2. **Local Search**:\n   - **Segment Inversion**: Randomly invert a segment of the tour.\n   - **Hybrid Edge Exchanges**: Perform 1\u20132 random edge swaps within the inverted segment.\n3. **Feasibility**: Assert the new tour is valid (no duplicates/missing nodes).\n4. **Output**: Return the neighbor solution.\n\n**Why?**\n- Nondominated solutions ensure high-potential perturbation.\n- Hybrid operators balance structure and exploration.\n- Assertions guarantee validity.\n- Controlled randomness avoids excessive disruption.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 11,
        "algorithm": "The algorithm selects a solution from the archive based on objective diversity (prioritizing those with higher combined normalized costs), then applies a hybrid local search combining segment rotation and adaptive edge exchanges (scaled by diversity). It ensures feasibility by validating the solution and uses distance matrices to guide exchanges that improve at least one objective. The selection balances exploitation and exploration, while the local search dynamically adjusts perturbation intensity based on solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective diversity (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0))\n    diversity = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation (novel operator)\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, k)\n    new_solution[start:end+1] = rotated_segment\n\n    # Adaptive edge exchanges (novel operator)\n    num_exchanges = int(np.ceil(diversity[selected_idx] * 2))  # Scale with diversity\n    for _ in range(num_exchanges):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            # Check if exchange improves at least one objective\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.879161711948826,
            4.070042371749878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective diversity (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0))\n    diversity = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation (novel operator)\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, k)\n    new_solution[start:end+1] = rotated_segment\n\n    # Adaptive edge exchanges (novel operator)\n    num_exchanges = int(np.ceil(diversity[selected_idx] * 2))  # Scale with diversity\n    for _ in range(num_exchanges):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            # Check if exchange improves at least one objective\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive by choosing the one with the lowest combined objective cost, then applies a hybrid local search combining a segment reversal (similar to 3-opt) with a conditional edge swap that improves both objectives simultaneously. The selection prioritizes solutions with better overall performance, while the local search operator intelligently modifies the tour by reversing segments and conditionally swapping edges to enhance both objectives, ensuring feasibility through careful index handling.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best Pareto front contribution (simplified approach)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of the tour\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Step 2: Reverse the segment (similar to 3-opt but simpler)\n    segment_reversed = segment[::-1]\n    new_solution[a:b] = segment_reversed\n\n    # Step 3: Custom edge swap to improve both objectives\n    # Select two random edges and swap their endpoints if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Original edges: (i, i+1) and (j, j+1)\n        # New edges: (i, j) and (i+1, j+1)\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection\n- **Keywords**: *Premature convergence, dominated solutions, hybrid operators, feasibility checks*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (e.g., segment inversion + edge exchanges), ensure feasibility via assertions or rollback, and balance randomness.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Dominated solutions risk local optima; hybrid operators improve quality; assertions/rollback maintain validity; controlled randomness avoids instability.*\n\n### Heuristic Design\n1. **Selection**: Randomly pick a nondominated solution from the archive.\n2. **Local Search**:\n   - **Segment Inversion**: Randomly invert a segment of the tour.\n   - **Hybrid Edge Exchanges**: Perform 1\u20132 random edge swaps within the inverted segment.\n3. **Feasibility**: Assert the new tour is valid (no duplicates/missing nodes).\n4. **Output**: Return the neighbor solution.\n\n**Why?**\n- Nondominated solutions ensure high-potential perturbation.\n- Hybrid operators balance structure and exploration.\n- Assertions guarantee validity.\n- Controlled randomness avoids excessive disruption.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 12,
        "algorithm": "The algorithm selects a nondominated solution from the archive, applies a hybrid local search combining random segment shuffling and conditional edge swaps to improve both objectives, and ensures feasibility by validating the tour. It prioritizes solutions with higher objective sums for selection and uses distance matrices to evaluate cost improvements, with a focus on balancing exploration (random segment shuffling) and exploitation (conditional edge swaps).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution (simplified: highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: segment shuffle + conditional edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and shuffle it\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n    random.shuffle(segment)\n    new_solution[a:b] = segment\n\n    # Step 2: Conditional edge swap to improve both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Original edges: (i, i+1) and (j, j+1)\n        # New edges: (i, j) and (i+1, j+1)\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.6418839859496464,
            3.1250597834587097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution (simplified: highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: segment shuffle + conditional edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and shuffle it\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n    random.shuffle(segment)\n    new_solution[a:b] = segment\n\n    # Step 2: Conditional edge swap to improve both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Original edges: (i, i+1) and (j, j+1)\n        # New edges: (i, j) and (i+1, j+1)\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 13,
        "algorithm": "The algorithm selects a promising solution from the archive by combining both objectives (70% weight on the first objective) and applies a hybrid local search combining segment rotation and adaptive edge swaps, ensuring feasibility through validation. The segment rotation operator randomly rotates a segment of the tour, while the adaptive edge swap operator intelligently swaps edges based on distance improvements in the first objective space. The solution is validated to ensure no nodes are skipped or revisited.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (combination of both objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment rotation (novel operator)\n    start = np.random.randint(0, n-1)\n    k = np.random.randint(1, min(5, n-start))  # Rotate segment of size k\n    segment = new_solution[start:start+k]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+k] = rotated_segment\n\n    # Adaptive edge swap (novel operator)\n    for _ in range(3):  # Perform 3 adaptive swaps\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9228767999126478,
            2.924859583377838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (combination of both objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment rotation (novel operator)\n    start = np.random.randint(0, n-1)\n    k = np.random.randint(1, min(5, n-start))  # Rotate segment of size k\n    segment = new_solution[start:start+k]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+k] = rotated_segment\n\n    # Adaptive edge swap (novel operator)\n    for _ in range(3):  # Perform 3 adaptive swaps\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 14,
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (60% first objective, 40% second objective), then applies a hybrid local search combining node relocation (randomly moving a node) and segment rotation (rotating a segment of the tour). It ensures feasibility by validating that all nodes are unique in the generated solution. The weighted objective selection prioritizes the first objective, while the novel local search operators introduce diversity in the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective combination\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    selected_solution = max(archive, key=lambda x: np.dot(x[1], weights))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 2: Node relocation (novel operator)\n    i, j = np.random.randint(0, n, size=2)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Segment rotation (novel operator)\n    start, end = np.random.randint(0, n-2, size=2)\n    if start > end:\n        start, end = end, start\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, 1)  # Rotate left by 1\n    new_solution[start:end+1] = rotated_segment\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8808630008369889,
            4.121443569660187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on weighted objective combination\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    selected_solution = max(archive, key=lambda x: np.dot(x[1], weights))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 2: Node relocation (novel operator)\n    i, j = np.random.randint(0, n, size=2)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Segment rotation (novel operator)\n    start, end = np.random.randint(0, n-2, size=2)\n    if start > end:\n        start, end = end, start\n    segment = new_solution[start:end+1]\n    rotated_segment = np.roll(segment, 1)  # Rotate left by 1\n    new_solution[start:end+1] = rotated_segment\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 6 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects high-variance solutions from the archive to focus on promising regions, then applies a hybrid local search combining adaptive segment reordering (reversal/rotation) and objective-aware edge swaps, prioritizing modifications based on which objective space shows greater improvement potential while ensuring feasibility through validation checks. The method dynamically balances exploration of large and small-scale changes and evaluates improvements in both objectives to guide the search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (promising for improvement)\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering based on objective improvement potential\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    # Try multiple segment operations and keep the best improvement\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    for _ in range(3):  # Try multiple segment operations\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Adaptive segment operation: choose between reversal and rotation\n        if np.random.rand() > 0.5:\n            segment = temp_solution[a:b+1]\n            temp_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))\n        else:\n            temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate improvement in both objectives\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Objective-aware edge swap\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    # Perform edge swap based on which objective shows more potential\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    if cost1 > cost2:\n        # More improvement potential in first objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n    else:\n        # More improvement potential in second objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive based on combined objective values and diversity, then applies a hybrid local search combining adaptive segment reversal, probabilistic edge swaps, and random node insertions to generate feasible neighbors while balancing exploration and exploitation. It prioritizes solutions with lower combined costs but introduces randomness to maintain diversity, and the local search operations are designed to improve both objectives simultaneously while ensuring tour validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best combined objective and good diversity\n    def score(sol_obj):\n        sol, obj = sol_obj\n        combined = sum(obj)\n        # Add small random factor to encourage diversity\n        return combined + np.random.uniform(0, 0.1)\n\n    selected = min(archive, key=score)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n\n    # Hybrid local search with three operations\n    # 1. Adaptive segment reversal\n    segment_size = max(2, min(N//2, int(np.random.normal(N//3, N//6))))\n    start = np.random.randint(0, N - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Decide whether to reverse or shift based on local improvement potential\n    if np.random.random() < 0.5:\n        new_solution[start:end] = segment[::-1]\n    else:\n        shift = np.random.randint(1, segment_size)\n        new_solution[start:end] = np.roll(segment, shift)\n\n    # 2. Probabilistic edge swaps based on objective improvement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        old_dist = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_1[base_solution[j], base_solution[(j+1)%N]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_2[base_solution[j], base_solution[(j+1)%N]])\n\n        new_dist = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                    distance_matrix_1[base_solution[i], base_solution[(j+1)%N]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                    distance_matrix_2[base_solution[i], base_solution[(j+1)%N]])\n\n        if new_dist < old_dist and np.random.random() < 0.7:  # Accept with 70% probability if better\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Random node insertion for diversification\n    if np.random.random() < 0.3:  # 30% chance\n        pos = np.random.randint(0, N)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Return original if invalid\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using weighted random selection based on combined objective values, then applies a hybrid local search combining node insertion and segment relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with lower total costs, while the local search explores the solution space through strategic node and segment movements. The overall structure balances exploration and exploitation by leveraging both objective-based selection and creative neighborhood generation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Weighted random selection based on objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (objectives + 1e-10)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion followed by segment relocation\n    # Randomly select a node to insert elsewhere\n    node_idx = np.random.randint(0, N)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Insert the node at a random position\n    insert_pos = np.random.randint(0, N)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Relocate a random segment\n    a, b = sorted(np.random.choice(N-1, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive (using a simplified selection criterion), applies segment inversion to a random segment of the tour, performs hybrid edge exchanges within the inverted segment, and ensures feasibility through assertions. The key design ideas are prioritizing nondominated solutions, using segment inversion for exploration, and hybrid edge exchanges for local refinement while maintaining tour validity. The algorithm balances exploration and exploitation while ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s a refined **Ineffective Self-Reflection** response for your heuristic design:\n\n- **Keywords**: *Nondominated bias, hybrid operators, feasibility safeguards, adaptive randomness*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (segment inversion + edge swaps), enforce feasibility via assertions, and balance randomness with deterministic improvements.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Nondominated solutions ensure high-potential refinement; hybrid operators improve quality; assertions maintain validity; controlled randomness avoids instability.*\n\nThis aligns with your goal of avoiding dominated solutions and ensuring high-quality, feasible neighbors.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 15,
        "algorithm": "The algorithm selects a nondominated solution from the archive, applies adaptive segment inversion and hybrid edge exchanges within the inverted segment to generate a neighbor solution, prioritizing improvements in both objectives while ensuring feasibility through validation checks. It intelligently balances exploration and exploitation by considering both cost reductions in both objectives and allowing probabilistic acceptance of partial improvements. The method goes beyond standard local search by combining segment inversion with targeted edge exchanges, ensuring diverse neighborhood exploration while maintaining solution validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective improvement potential\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    original_cost1 = calculate_improvement(new_solution, 0)\n    original_cost2 = calculate_improvement(new_solution, 1)\n\n    # Try inversion and check improvement\n    temp_solution = new_solution.copy()\n    temp_solution[start:end+1] = segment[::-1]\n    new_cost1 = calculate_improvement(temp_solution, 0)\n    new_cost2 = calculate_improvement(temp_solution, 1)\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n       (np.random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n        new_solution = temp_solution\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_cost1 = calculate_improvement(temp_solution, 0)\n                temp_cost2 = calculate_improvement(temp_solution, 1)\n\n                if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n                   (np.random.random() < 0.2 and (temp_cost1 < original_cost1 or temp_cost2 < original_cost2)):\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9669036262573005,
            7.068971633911133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective improvement potential\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    original_cost1 = calculate_improvement(new_solution, 0)\n    original_cost2 = calculate_improvement(new_solution, 1)\n\n    # Try inversion and check improvement\n    temp_solution = new_solution.copy()\n    temp_solution[start:end+1] = segment[::-1]\n    new_cost1 = calculate_improvement(temp_solution, 0)\n    new_cost2 = calculate_improvement(temp_solution, 1)\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n       (np.random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n        new_solution = temp_solution\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_cost1 = calculate_improvement(temp_solution, 0)\n                temp_cost2 = calculate_improvement(temp_solution, 1)\n\n                if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n                   (np.random.random() < 0.2 and (temp_cost1 < original_cost1 or temp_cost2 < original_cost2)):\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 6 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective costs) and applies a hybrid local search combining segment inversion and random edge exchanges to generate a neighbor solution while ensuring feasibility. It uses segment inversion to reverse a random segment of the tour and performs random edge exchanges to further perturb the solution, with checks to maintain validity. The approach balances exploration and exploitation by combining structural modifications with random perturbations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., with high crowding distance or Pareto-dominated)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion (novel operator)\n    start, end = np.random.randint(0, n-1, size=2)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Crossover-like edge exchange (novel operator)\n    for _ in range(2):  # Perform 2 random edge exchanges\n        i, j = np.random.randint(0, n, size=2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no revisits or skips)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects high-variance solutions from the archive to focus on promising regions, then applies a hybrid local search combining adaptive segment reordering (reversal/rotation) and objective-aware edge swaps, prioritizing modifications based on which objective space shows greater improvement potential while ensuring feasibility through validation checks. The method dynamically balances exploration of large and small-scale changes and evaluates improvements in both objectives to guide the search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (promising for improvement)\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering based on objective improvement potential\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    # Try multiple segment operations and keep the best improvement\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    for _ in range(3):  # Try multiple segment operations\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Adaptive segment operation: choose between reversal and rotation\n        if np.random.rand() > 0.5:\n            segment = temp_solution[a:b+1]\n            temp_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))\n        else:\n            temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate improvement in both objectives\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Objective-aware edge swap\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    # Perform edge swap based on which objective shows more potential\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    if cost1 > cost2:\n        # More improvement potential in first objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n    else:\n        # More improvement potential in second objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive based on combined objective values and diversity, then applies a hybrid local search combining adaptive segment reversal, probabilistic edge swaps, and random node insertions to generate feasible neighbors while balancing exploration and exploitation. It prioritizes solutions with lower combined costs but introduces randomness to maintain diversity, and the local search operations are designed to improve both objectives simultaneously while ensuring tour validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best combined objective and good diversity\n    def score(sol_obj):\n        sol, obj = sol_obj\n        combined = sum(obj)\n        # Add small random factor to encourage diversity\n        return combined + np.random.uniform(0, 0.1)\n\n    selected = min(archive, key=score)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n\n    # Hybrid local search with three operations\n    # 1. Adaptive segment reversal\n    segment_size = max(2, min(N//2, int(np.random.normal(N//3, N//6))))\n    start = np.random.randint(0, N - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Decide whether to reverse or shift based on local improvement potential\n    if np.random.random() < 0.5:\n        new_solution[start:end] = segment[::-1]\n    else:\n        shift = np.random.randint(1, segment_size)\n        new_solution[start:end] = np.roll(segment, shift)\n\n    # 2. Probabilistic edge swaps based on objective improvement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        old_dist = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_1[base_solution[j], base_solution[(j+1)%N]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_2[base_solution[j], base_solution[(j+1)%N]])\n\n        new_dist = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                    distance_matrix_1[base_solution[i], base_solution[(j+1)%N]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                    distance_matrix_2[base_solution[i], base_solution[(j+1)%N]])\n\n        if new_dist < old_dist and np.random.random() < 0.7:  # Accept with 70% probability if better\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Random node insertion for diversification\n    if np.random.random() < 0.3:  # 30% chance\n        pos = np.random.randint(0, N)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Return original if invalid\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using weighted random selection based on combined objective values, then applies a hybrid local search combining node insertion and segment relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with lower total costs, while the local search explores the solution space through strategic node and segment movements. The overall structure balances exploration and exploitation by leveraging both objective-based selection and creative neighborhood generation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Weighted random selection based on objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (objectives + 1e-10)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion followed by segment relocation\n    # Randomly select a node to insert elsewhere\n    node_idx = np.random.randint(0, N)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Insert the node at a random position\n    insert_pos = np.random.randint(0, N)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Relocate a random segment\n    a, b = sorted(np.random.choice(N-1, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive (using a simplified selection criterion), applies segment inversion to a random segment of the tour, performs hybrid edge exchanges within the inverted segment, and ensures feasibility through assertions. The key design ideas are prioritizing nondominated solutions, using segment inversion for exploration, and hybrid edge exchanges for local refinement while maintaining tour validity. The algorithm balances exploration and exploitation while ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s a refined **Ineffective Self-Reflection** response for your heuristic design:\n\n- **Keywords**: *Nondominated bias, hybrid operators, feasibility safeguards, adaptive randomness*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (segment inversion + edge swaps), enforce feasibility via assertions, and balance randomness with deterministic improvements.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Nondominated solutions ensure high-potential refinement; hybrid operators improve quality; assertions maintain validity; controlled randomness avoids instability.*\n\nThis aligns with your goal of avoiding dominated solutions and ensuring high-quality, feasible neighbors.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 15,
        "algorithm": "The algorithm selects a nondominated solution from the archive, applies adaptive segment inversion and hybrid edge exchanges within the inverted segment to generate a neighbor solution, prioritizing improvements in both objectives while ensuring feasibility through validation checks. It intelligently balances exploration and exploitation by considering both cost reductions in both objectives and allowing probabilistic acceptance of partial improvements. The method goes beyond standard local search by combining segment inversion with targeted edge exchanges, ensuring diverse neighborhood exploration while maintaining solution validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective improvement potential\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    original_cost1 = calculate_improvement(new_solution, 0)\n    original_cost2 = calculate_improvement(new_solution, 1)\n\n    # Try inversion and check improvement\n    temp_solution = new_solution.copy()\n    temp_solution[start:end+1] = segment[::-1]\n    new_cost1 = calculate_improvement(temp_solution, 0)\n    new_cost2 = calculate_improvement(temp_solution, 1)\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n       (np.random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n        new_solution = temp_solution\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_cost1 = calculate_improvement(temp_solution, 0)\n                temp_cost2 = calculate_improvement(temp_solution, 1)\n\n                if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n                   (np.random.random() < 0.2 and (temp_cost1 < original_cost1 or temp_cost2 < original_cost2)):\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9669036262573005,
            7.068971633911133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective improvement potential\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    original_cost1 = calculate_improvement(new_solution, 0)\n    original_cost2 = calculate_improvement(new_solution, 1)\n\n    # Try inversion and check improvement\n    temp_solution = new_solution.copy()\n    temp_solution[start:end+1] = segment[::-1]\n    new_cost1 = calculate_improvement(temp_solution, 0)\n    new_cost2 = calculate_improvement(temp_solution, 1)\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n       (np.random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n        new_solution = temp_solution\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_cost1 = calculate_improvement(temp_solution, 0)\n                temp_cost2 = calculate_improvement(temp_solution, 1)\n\n                if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n                   (np.random.random() < 0.2 and (temp_cost1 < original_cost1 or temp_cost2 < original_cost2)):\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n        \n        The current objectives are: NHV = 0.6874673169254132, Runtime = 2.7654505372047424 (lower is better for both).\n        \n        Please create a new algorithm that is a modified version of the provided one, but with a strong focus on reducing runtime (e.g., optimize loops, use efficient data structures, remove redundant computations) while trying to maintain or improve NHV if possible.\n        \n        1. First, identify parts of the code that may cause high runtime and suggest optimizations.\n        2. Next, describe your new algorithm and main steps in one detailed sentence, incorporating runtime optimizations. The description must be inside boxed {}.\n        3. Finally, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        \n        Check syntax and code carefully before returning the final function. Do not give additional explanations.\nAdditionally, incorporate this long-term reflection for higher-level guidance:\nHere\u2019s a refined **Ineffective Self-Reflection** response for your heuristic design:\n\n- **Keywords**: *Nondominated bias, hybrid operators, feasibility safeguards, adaptive randomness*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (segment inversion + edge swaps), enforce feasibility via assertions, and balance randomness with deterministic improvements.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Nondominated solutions ensure high-potential refinement; hybrid operators improve quality; assertions maintain validity; controlled randomness avoids instability.*\n\nThis aligns with your goal of avoiding dominated solutions and ensuring high-quality, feasible neighbors.",
        "sample_order": 16,
        "algorithm": "This algorithm selects the best nondominated solution (lowest combined objective) from the archive, applies a hybrid local search combining segment reversal and edge swaps with optimized feasibility checks, and ensures the neighbor solution remains feasible by reverting invalid moves. It prioritizes solutions with better combined objectives and uses efficient set-based checks to avoid redundant computations. The structure balances exploration (random segment selection) and exploitation (edge swaps) while minimizing runtime.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the best nondominated solution (lowest combined objective)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n    N = len(new_solution)\n\n    # Optimized segment reversal with set-based feasibility check\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_segment = segment[::-1]\n    new_solution[a:b+1] = new_segment\n\n    # Fast feasibility check using sets (avoids np.unique)\n    if len(set(new_solution)) != N:\n        new_solution[a:b+1] = segment  # Revert if invalid\n\n    # Optimized edge swap (in-place swap)\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6244136476817188,
            2.6775330901145935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the best nondominated solution (lowest combined objective)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n    N = len(new_solution)\n\n    # Optimized segment reversal with set-based feasibility check\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_segment = segment[::-1]\n    new_solution[a:b+1] = new_segment\n\n    # Fast feasibility check using sets (avoids np.unique)\n    if len(set(new_solution)) != N:\n        new_solution[a:b+1] = segment  # Revert if invalid\n\n    # Optimized edge swap (in-place swap)\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor solution while ensuring feasibility. It intelligently modifies a random segment of the tour and performs additional edge swaps to explore diverse neighborhoods, balancing exploration and exploitation. The method prioritizes solutions with better combined objectives and uses randomized segment operations to avoid local optima.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment to create a new path\n    new_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = new_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to the original segment\n        new_solution[a:b+1] = segment\n\n    # Additional edge swap to further explore the neighborhood\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n        \n        The current objectives are: NHV = 0.6874673169254132, Runtime = 2.7654505372047424 (lower is better for both).\n        \n        Please create a new algorithm that is a modified version of the provided one, but with a strong focus on reducing runtime (e.g., optimize loops, use efficient data structures, remove redundant computations) while trying to maintain or improve NHV if possible.\n        \n        1. First, identify parts of the code that may cause high runtime and suggest optimizations.\n        2. Next, describe your new algorithm and main steps in one detailed sentence, incorporating runtime optimizations. The description must be inside boxed {}.\n        3. Finally, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        \n        Check syntax and code carefully before returning the final function. Do not give additional explanations.\nAdditionally, incorporate this long-term reflection for higher-level guidance:\nHere\u2019s a refined **Ineffective Self-Reflection** response for your heuristic design:\n\n- **Keywords**: *Nondominated bias, hybrid operators, feasibility safeguards, adaptive randomness*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (segment inversion + edge swaps), enforce feasibility via assertions, and balance randomness with deterministic improvements.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Nondominated solutions ensure high-potential refinement; hybrid operators improve quality; assertions maintain validity; controlled randomness avoids instability.*\n\nThis aligns with your goal of avoiding dominated solutions and ensuring high-quality, feasible neighbors.",
        "sample_order": 16,
        "algorithm": "This algorithm selects the best nondominated solution (lowest combined objective) from the archive, applies a hybrid local search combining segment reversal and edge swaps with optimized feasibility checks, and ensures the neighbor solution remains feasible by reverting invalid moves. It prioritizes solutions with better combined objectives and uses efficient set-based checks to avoid redundant computations. The structure balances exploration (random segment selection) and exploitation (edge swaps) while minimizing runtime.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the best nondominated solution (lowest combined objective)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n    N = len(new_solution)\n\n    # Optimized segment reversal with set-based feasibility check\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_segment = segment[::-1]\n    new_solution[a:b+1] = new_segment\n\n    # Fast feasibility check using sets (avoids np.unique)\n    if len(set(new_solution)) != N:\n        new_solution[a:b+1] = segment  # Revert if invalid\n\n    # Optimized edge swap (in-place swap)\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6244136476817188,
            2.6775330901145935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the best nondominated solution (lowest combined objective)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n    N = len(new_solution)\n\n    # Optimized segment reversal with set-based feasibility check\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_segment = segment[::-1]\n    new_solution[a:b+1] = new_segment\n\n    # Fast feasibility check using sets (avoids np.unique)\n    if len(set(new_solution)) != N:\n        new_solution[a:b+1] = segment  # Revert if invalid\n\n    # Optimized edge swap (in-place swap)\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "r1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects high-variance solutions from the archive to focus on promising regions, then applies a hybrid local search combining adaptive segment reordering (reversal/rotation) and objective-aware edge swaps, prioritizing modifications based on which objective space shows greater improvement potential while ensuring feasibility through validation checks. The method dynamically balances exploration of large and small-scale changes and evaluates improvements in both objectives to guide the search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (promising for improvement)\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering based on objective improvement potential\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    # Try multiple segment operations and keep the best improvement\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    for _ in range(3):  # Try multiple segment operations\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Adaptive segment operation: choose between reversal and rotation\n        if np.random.rand() > 0.5:\n            segment = temp_solution[a:b+1]\n            temp_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))\n        else:\n            temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate improvement in both objectives\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Objective-aware edge swap\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    # Perform edge swap based on which objective shows more potential\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    if cost1 > cost2:\n        # More improvement potential in first objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n    else:\n        # More improvement potential in second objective space\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = best_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive, applies adaptive segment inversion and hybrid edge exchanges within the inverted segment to generate a neighbor solution, prioritizing improvements in both objectives while ensuring feasibility through validation checks. It intelligently balances exploration and exploitation by considering both cost reductions in both objectives and allowing probabilistic acceptance of partial improvements. The method goes beyond standard local search by combining segment inversion with targeted edge exchanges, ensuring diverse neighborhood exploration while maintaining solution validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective improvement potential\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    original_cost1 = calculate_improvement(new_solution, 0)\n    original_cost2 = calculate_improvement(new_solution, 1)\n\n    # Try inversion and check improvement\n    temp_solution = new_solution.copy()\n    temp_solution[start:end+1] = segment[::-1]\n    new_cost1 = calculate_improvement(temp_solution, 0)\n    new_cost2 = calculate_improvement(temp_solution, 1)\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n       (np.random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n        new_solution = temp_solution\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_cost1 = calculate_improvement(temp_solution, 0)\n                temp_cost2 = calculate_improvement(temp_solution, 1)\n\n                if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n                   (np.random.random() < 0.2 and (temp_cost1 < original_cost1 or temp_cost2 < original_cost2)):\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a refined **Ineffective Self-Reflection** response for your heuristic design:\n\n- **Keywords**: *Nondominated bias, hybrid operators, feasibility safeguards, adaptive randomness*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (segment inversion + edge swaps), enforce feasibility via assertions, and balance randomness with deterministic improvements.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Nondominated solutions ensure high-potential refinement; hybrid operators improve quality; assertions maintain validity; controlled randomness avoids instability.*\n\nThis aligns with your goal of avoiding dominated solutions and ensuring high-quality, feasible neighbors.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 17,
        "algorithm": "The algorithm selects a solution from the archive with high objective diversity, then applies a hybrid local search combining adaptive segment rotation (right/left based on which objective has higher potential) and targeted edge exchanges (swapping nodes to reduce costs in the more promising objective space), ensuring feasibility through validation checks. The method prioritizes objectives with higher potential improvement while maintaining valid TSP tours through uniqueness checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_std = np.std(objectives, axis=0)\n    selected_idx = np.argmax(objective_std)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_improvement(solution, obj_space):\n        dm = distance_matrix_1 if obj_space == 0 else distance_matrix_2\n        return sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    # Adaptive segment rotation based on objective potential\n    for _ in range(3):\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = temp_solution[a:b+1]\n\n        # Determine rotation direction based on which objective shows more potential\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n\n        if cost1 > cost2:\n            # Rotate right if first objective has more potential\n            temp_solution[a:b+1] = np.roll(segment, 1)\n        else:\n            # Rotate left if second objective has more potential\n            temp_solution[a:b+1] = np.roll(segment, -1)\n\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        total_cost = calculate_improvement(temp_solution, 0) + calculate_improvement(temp_solution, 1)\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Targeted edge exchanges based on objective potential\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    for _ in range(2):\n        temp_solution = best_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Swap edges based on which objective shows more potential\n        if cost1 > cost2:\n            # More potential in first objective space\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n        else:\n            # More potential in second objective space\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\n",
        "score": [
            -0.5448498608914676,
            6.072622358798981
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity\n    objectives = np.array([obj[1] for _, obj in archive])\n    objective_std = np.std(objectives, axis=0)\n    selected_idx = np.argmax(objective_std)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_improvement(solution, obj_space):\n        dm = distance_matrix_1 if obj_space == 0 else distance_matrix_2\n        return sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n\n    best_cost = float('inf')\n    best_solution = new_solution.copy()\n\n    # Adaptive segment rotation based on objective potential\n    for _ in range(3):\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = temp_solution[a:b+1]\n\n        # Determine rotation direction based on which objective shows more potential\n        cost1 = calculate_improvement(temp_solution, 0)\n        cost2 = calculate_improvement(temp_solution, 1)\n\n        if cost1 > cost2:\n            # Rotate right if first objective has more potential\n            temp_solution[a:b+1] = np.roll(segment, 1)\n        else:\n            # Rotate left if second objective has more potential\n            temp_solution[a:b+1] = np.roll(segment, -1)\n\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        total_cost = calculate_improvement(temp_solution, 0) + calculate_improvement(temp_solution, 1)\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = temp_solution.copy()\n\n    # Targeted edge exchanges based on objective potential\n    if best_cost == float('inf'):\n        best_solution = new_solution.copy()\n\n    cost1 = calculate_improvement(best_solution, 0)\n    cost2 = calculate_improvement(best_solution, 1)\n\n    for _ in range(2):\n        temp_solution = best_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Swap edges based on which objective shows more potential\n        if cost1 > cost2:\n            # More potential in first objective space\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 0)\n                if new_cost < cost1:\n                    best_solution = temp_solution.copy()\n                    cost1 = new_cost\n        else:\n            # More potential in second objective space\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            if len(np.unique(temp_solution)) == n:\n                new_cost = calculate_improvement(temp_solution, 1)\n                if new_cost < cost2:\n                    best_solution = temp_solution.copy()\n                    cost2 = new_cost\n\n    return best_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive, applies a hybrid local search combining random segment shuffling and conditional edge swaps to improve both objectives, and ensures feasibility by validating the tour. It prioritizes solutions with higher objective sums for selection and uses distance matrices to evaluate cost improvements, with a focus on balancing exploration (random segment shuffling) and exploitation (conditional edge swaps).\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution (simplified: highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: segment shuffle + conditional edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and shuffle it\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n    random.shuffle(segment)\n    new_solution[a:b] = segment\n\n    # Step 2: Conditional edge swap to improve both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Original edges: (i, i+1) and (j, j+1)\n        # New edges: (i, j) and (i+1, j+1)\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive, applies adaptive segment inversion and hybrid edge exchanges within the inverted segment to generate a neighbor solution, prioritizing improvements in both objectives while ensuring feasibility through validation checks. It intelligently balances exploration and exploitation by considering both cost reductions in both objectives and allowing probabilistic acceptance of partial improvements. The method goes beyond standard local search by combining segment inversion with targeted edge exchanges, ensuring diverse neighborhood exploration while maintaining solution validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a nondominated solution (simplified for this example)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion based on objective improvement potential\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution, obj_space):\n        if obj_space == 0:\n            dm = distance_matrix_1\n        else:\n            dm = distance_matrix_2\n        current_cost = sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n        return current_cost\n\n    original_cost1 = calculate_improvement(new_solution, 0)\n    original_cost2 = calculate_improvement(new_solution, 1)\n\n    # Try inversion and check improvement\n    temp_solution = new_solution.copy()\n    temp_solution[start:end+1] = segment[::-1]\n    new_cost1 = calculate_improvement(temp_solution, 0)\n    new_cost2 = calculate_improvement(temp_solution, 1)\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n       (np.random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n        new_solution = temp_solution\n\n    # Hybrid edge exchanges within the inverted segment\n    segment_length = end - start + 1\n    if segment_length > 2:\n        for _ in range(2):\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_cost1 = calculate_improvement(temp_solution, 0)\n                temp_cost2 = calculate_improvement(temp_solution, 1)\n\n                if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n                   (np.random.random() < 0.2 and (temp_cost1 < original_cost1 or temp_cost2 < original_cost2)):\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a refined **Ineffective Self-Reflection** response for your heuristic design:\n\n- **Keywords**: *Nondominated bias, hybrid operators, feasibility safeguards, adaptive randomness*\n- **Advice**: *Prioritize nondominated solutions for perturbation, use hybrid operators (segment inversion + edge swaps), enforce feasibility via assertions, and balance randomness with deterministic improvements.*\n- **Avoid**: *Over-reliance on dominated solutions, pure segment reversal, excessive randomness, or invalid solutions.*\n- **Explanation**: *Nondominated solutions ensure high-potential refinement; hybrid operators improve quality; assertions maintain validity; controlled randomness avoids instability.*\n\nThis aligns with your goal of avoiding dominated solutions and ensuring high-quality, feasible neighbors.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 18,
        "algorithm": "The algorithm selects a nondominated solution from the archive, applies adaptive segment rotation to perturb it, then performs targeted node swaps to improve both objectives while ensuring feasibility. It prioritizes solutions with higher combined objective values and balances exploration/exploitation through random segment rotation and probabilistic acceptance of improvements. The method combines novel segment-based perturbation with local search to generate high-quality neighbors for bi-objective TSP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution (highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation based on objective improvement potential\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Rotate the segment left or right\n    segment = new_solution[start:end]\n    if random.random() < 0.5:\n        rotated_segment = np.roll(segment, 1)\n    else:\n        rotated_segment = np.roll(segment, -1)\n\n    new_solution[start:end] = rotated_segment\n\n    # Targeted node insertion for both objectives\n    def calculate_cost(solution, dm):\n        return sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Find insertion points that improve both objectives\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            temp_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n            temp_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n            if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n               (random.random() < 0.3 and (temp_cost1 < original_cost1 or temp_cost2 < original_cost2)):\n                new_solution = temp_solution\n                original_cost1, original_cost2 = temp_cost1, temp_cost2\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9116462594666753,
            4.1588873863220215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution (highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation based on objective improvement potential\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Rotate the segment left or right\n    segment = new_solution[start:end]\n    if random.random() < 0.5:\n        rotated_segment = np.roll(segment, 1)\n    else:\n        rotated_segment = np.roll(segment, -1)\n\n    new_solution[start:end] = rotated_segment\n\n    # Targeted node insertion for both objectives\n    def calculate_cost(solution, dm):\n        return sum(dm[solution[i], solution[(i+1)%n]] for i in range(n))\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Find insertion points that improve both objectives\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            temp_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n            temp_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n            if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n               (random.random() < 0.3 and (temp_cost1 < original_cost1 or temp_cost2 < original_cost2)):\n                new_solution = temp_solution\n                original_cost1, original_cost2 = temp_cost1, temp_cost2\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "operation": "e2"
    }
]