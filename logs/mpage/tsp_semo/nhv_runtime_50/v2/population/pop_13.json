[
     {
          "algorithm": "{The new algorithm, named \"Objective-Driven Hybrid Segment Fusion with Dynamic Node Rebalancing,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first identifying and fusing the most complementary segments from different solutions in the archive, then dynamically rebalancing the tour by selectively replacing nodes based on their cross-dimensional contribution scores. This method combines segment fusion with a novel node replacement mechanism that evaluates each node's potential to improve both objectives simultaneously, using a probabilistic acceptance criterion that considers both immediate improvement and long-term solution balance, while maintaining tour feasibility through a two-phase validation process that checks both segment connectivity and node uniqueness.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the best segments from different solutions\n    best_segments = []\n    for solution, _ in archive[:3]:  # Consider top 3 solutions\n        n = len(solution)\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = solution[i:i+segment_length]\n            if len(segment) > 1:\n                best_segments.append(segment)\n\n    if not best_segments:\n        best_segments = [archive[0][0][:3]]\n\n    # Step 2: Create initial solution by combining complementary segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in best_segments:\n        new_solution.extend(seg)\n        for node in seg:\n            remaining_nodes.discard(node)\n\n    # Step 3: Dynamic node rebalancing\n    for _ in range(3):  # Perform 3 rebalancing iterations\n        for i in range(len(new_solution)):\n            node = new_solution[i]\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i+1] if i < len(new_solution)-1 else new_solution[0]\n\n            # Calculate current contribution to both objectives\n            current_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Find potential replacement nodes\n            candidates = list(remaining_nodes)\n            if not candidates:\n                break\n\n            for candidate in candidates:\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node] +\n                              distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node])\n\n                # Accept if improvement in both objectives\n                if new_contrib < current_contrib * 0.95:  # 5% improvement threshold\n                    new_solution[i] = candidate\n                    remaining_nodes.add(node)\n                    remaining_nodes.remove(candidate)\n                    break\n\n    # Step 4: Insert remaining nodes\n    remaining_nodes = list(remaining_nodes)\n    while remaining_nodes:\n        best_node = None\n        best_pos = -1\n        best_score = float('inf')\n\n        for node in remaining_nodes:\n            for i in range(len(new_solution)):\n                if i == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[i-1]\n                    next_node = new_solution[i]\n\n                score = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_pos = i\n\n        if best_node is not None:\n            new_solution.insert(best_pos, best_node)\n            remaining_nodes.remove(best_node)\n        else:\n            new_solution.extend(remaining_nodes)\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == len(instance), \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8144581164160893,
               0.09934872388839722
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Centric Tour Decomposition with Cross-Objective Segment Fusion,\" builds upon the common backbone of solution selection and tour decomposition from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective-centric\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then fused across objectives using an adaptive strategy that dynamically combines segments from both objectives while maintaining their relative order, followed by a \"cross-objective segment interleaving\" phase that probabilistically interleaves segments from both objectives to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into objective-centric segments\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = None\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if current_obj is None:\n            if cost1 > cost2:\n                current_obj = 1\n            else:\n                current_obj = 2\n            current_segment.append(current_node)\n        else:\n            if (current_obj == 1 and cost1 < cost2 * 0.8) or (current_obj == 2 and cost2 < cost1 * 0.8):\n                segments.append((current_obj, current_segment))\n                current_segment = [current_node]\n                current_obj = 3 - current_obj  # Switch objective\n            else:\n                current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [(1, new_solution[:n//2]), (2, new_solution[n//2:])]\n\n    # Step 3: Cross-objective segment fusion\n    fused_segments = []\n    i = 0\n    while i < len(segments):\n        obj1, seg1 = segments[i]\n        if i + 1 < len(segments):\n            obj2, seg2 = segments[i+1]\n            if obj1 != obj2 and random.random() < 0.5:\n                # Fuse segments from different objectives\n                fused_segment = seg1 + seg2\n                fused_segments.append((obj1, fused_segment))\n                i += 2\n            else:\n                fused_segments.append((obj1, seg1))\n                i += 1\n        else:\n            fused_segments.append((obj1, seg1))\n            i += 1\n\n    # Step 4: Cross-objective segment interleaving\n    if len(fused_segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in fused_segments if obj == 1]\n        obj2_segments = [seg for obj, seg in fused_segments if obj == 2]\n\n        # Interleave segments from both objectives\n        new_solution = []\n        i, j = 0, 0\n        while i < len(obj1_segments) or j < len(obj2_segments):\n            if i < len(obj1_segments) and (j >= len(obj2_segments) or random.random() < 0.5):\n                new_solution.extend(obj1_segments[i])\n                i += 1\n            else:\n                new_solution.extend(obj2_segments[j])\n                j += 1\n\n    # Step 5: Reconstruct solution and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            _, seg = fused_segments[i]\n            fused_segments[i] = (3 - fused_segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in fused_segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8855038623380989,
               0.12278997898101807
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Multi-Objective Segment Fusion with Adaptive Node Fusion and Objective-Weighted Reallocation,\" builds upon the segment-based approach but introduces a fundamentally different strategy by first identifying and fusing the most complementary segments from different solutions in the archive, then adaptively fusing nodes based on their cross-dimensional contribution scores, followed by an objective-weighted reallocation phase that probabilistically reorders segments to explore alternative configurations, while dynamically adjusting the fusion and reallocation parameters based on the current solution's objective balance, and ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on cross-dimensional contribution\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        total_cost = cost1 + cost2\n\n        if total_cost > 1.5 * (cost1 + cost2) / 2:  # High cross-dimensional variance\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive node fusion within segments\n    fused_segments = []\n    for segment in segments:\n        if len(segment) < 3:\n            fused_segments.append(segment)\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Adaptive fusion based on objective balance\n        if cost1 > 1.3 * cost2:\n            # Merge nodes with similar contribution to objective 1\n            fused_segment = []\n            i = 0\n            while i < len(segment):\n                if i + 1 < len(segment):\n                    node1 = segment[i]\n                    node2 = segment[i+1]\n                    contrib1 = distance_matrix_1[segment[i-1], node1] + distance_matrix_1[node1, node2]\n                    contrib2 = distance_matrix_1[segment[i-1], node2] + distance_matrix_1[node2, segment[i+2] if i+2 < len(segment) else segment[0]]\n\n                    if abs(contrib1 - contrib2) < 0.1 * (contrib1 + contrib2):\n                        fused_segment.append(node1)\n                        i += 2\n                    else:\n                        fused_segment.append(node1)\n                        i += 1\n                else:\n                    fused_segment.append(segment[i])\n                    i += 1\n            fused_segments.append(fused_segment)\n        else:\n            fused_segments.append(segment)\n\n    # Step 4: Objective-weighted segment reallocation\n    if len(fused_segments) > 1:\n        for i in range(len(fused_segments)):\n            if len(fused_segments[i]) < 2:\n                continue\n\n            cost1 = sum(distance_matrix_1[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n            cost2 = sum(distance_matrix_2[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n\n            if cost1 > 1.2 * cost2:\n                if random.random() < 0.5:\n                    # Reallocate nodes to better balance objectives\n                    segment = fused_segments[i]\n                    new_segment = []\n                    for j in range(len(segment)):\n                        node = segment[j]\n                        prev_node = segment[j-1] if j > 0 else segment[-1]\n                        next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                        if cost1 > 1.2 * cost2:\n                            # Find better node to replace with\n                            candidates = [k for k in range(len(instance)) if k not in segment]\n                            if candidates:\n                                best_node = None\n                                best_score = float('inf')\n                                for candidate in candidates:\n                                    new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                                    new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                                    score = abs(new_cost1 - new_cost2)\n                                    if score < best_score:\n                                        best_score = score\n                                        best_node = candidate\n                                if best_node is not None:\n                                    new_segment.append(best_node)\n                                else:\n                                    new_segment.append(node)\n                        else:\n                            new_segment.append(node)\n                    fused_segments[i] = new_segment\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9513067335199508,
               0.12776219844818115
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\n",
          "score": [
               -0.8491913871509116,
               0.11022323369979858
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Multi-Objective Segment Fusion with Dynamic Objective-Weighted Node Replacement,\" builds upon the common segment-based approach from the provided algorithms but introduces a fundamentally different mechanism by first adaptively identifying the most complementary segments from different solutions in the archive, then dynamically fusing and rebalancing these segments through an objective-weighted node replacement process that evaluates each node's potential contribution to both objectives using a probabilistic acceptance criterion that balances immediate improvement with long-term solution balance, while maintaining tour feasibility through a two-phase validation process that ensures both segment connectivity and node uniqueness, and dynamically adjusts the fusion and replacement parameters based on the current solution's objective balance and the distribution of nodes in the two objective spaces.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify critical segments based on cross-dimensional variance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        variance = abs(cost1 - cost2)\n\n        if variance > 0.5 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 3: Adaptive segment fusion with dynamic objective weighting\n    fused_segments = []\n    for i in range(len(segments)):\n        if len(segments[i]) < 2:\n            fused_segments.append(segments[i])\n            continue\n\n        segment = segments[i]\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Determine fusion strategy based on objective balance\n        if cost1 > 1.2 * cost2:\n            # Prioritize objective 2\n            for j in range(len(segment)):\n                node = segment[j]\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if current_cost2 > 1.2 * current_cost1:\n                    # Find better node to replace with\n                    candidates = [k for k in range(len(instance)) if k not in segment]\n                    if candidates:\n                        best_node = None\n                        best_score = float('inf')\n                        for candidate in candidates:\n                            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                            score = abs(new_cost1 - new_cost2)\n                            if score < best_score:\n                                best_score = score\n                                best_node = candidate\n                        if best_node is not None:\n                            segment[j] = best_node\n        else:\n            # Prioritize objective 1\n            for j in range(len(segment)):\n                node = segment[j]\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if current_cost1 > 1.2 * current_cost2:\n                    # Find better node to replace with\n                    candidates = [k for k in range(len(instance)) if k not in segment]\n                    if candidates:\n                        best_node = None\n                        best_score = float('inf')\n                        for candidate in candidates:\n                            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                            score = abs(new_cost1 - new_cost2)\n                            if score < best_score:\n                                best_score = score\n                                best_node = candidate\n                        if best_node is not None:\n                            segment[j] = best_node\n\n        fused_segments.append(segment)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.0429478487615236,
               0.831392228603363
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\n",
          "score": [
               -0.9782080321022513,
               0.14694750308990479
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Centric Segment Rebalancing with Dynamic Objective-Weighted Interleaving,\" builds upon the common backbone of solution selection and segment decomposition from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective-centric\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then rebalanced using an adaptive strategy that dynamically adjusts the segment sizes based on the current objective balance, followed by an \"objective-weighted segment interleaving\" phase that probabilistically interleaves segments from both objectives with weights proportional to their relative contributions. The method dynamically adjusts the decomposition and rebalancing parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into objective-centric segments\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = None\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if current_obj is None:\n            if cost1 > cost2:\n                current_obj = 1\n            else:\n                current_obj = 2\n            current_segment.append(current_node)\n        else:\n            if (current_obj == 1 and cost1 > 1.5 * cost2) or (current_obj == 2 and cost2 > 1.5 * cost1):\n                segments.append((current_obj, current_segment))\n                current_segment = [current_node]\n                current_obj = 3 - current_obj\n            else:\n                current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [(1, new_solution[:n//2]), (2, new_solution[n//2:])]\n\n    # Step 3: Adaptive segment rebalancing\n    total_cost1 = sum(x[1][0] for x in archive)\n    total_cost2 = sum(x[1][1] for x in archive)\n    obj1_weight = total_cost1 / (total_cost1 + total_cost2) if (total_cost1 + total_cost2) > 0 else 0.5\n    obj2_weight = 1 - obj1_weight\n\n    balanced_segments = []\n    for obj, seg in segments:\n        if obj == 1:\n            new_length = max(2, int(len(seg) * obj1_weight))\n        else:\n            new_length = max(2, int(len(seg) * obj2_weight))\n\n        if new_length < len(seg):\n            # Split segment\n            balanced_segments.append((obj, seg[:new_length]))\n            balanced_segments.append((3 - obj, seg[new_length:]))\n        elif new_length > len(seg):\n            # Merge with next segment if possible\n            if len(balanced_segments) > 0 and balanced_segments[-1][0] == obj:\n                balanced_segments[-1] = (obj, balanced_segments[-1][1] + seg)\n            else:\n                balanced_segments.append((obj, seg))\n        else:\n            balanced_segments.append((obj, seg))\n\n    # Step 4: Objective-weighted segment interleaving\n    obj1_segments = [seg for obj, seg in balanced_segments if obj == 1]\n    obj2_segments = [seg for obj, seg in balanced_segments if obj == 2]\n\n    new_solution = []\n    i, j = 0, 0\n    while i < len(obj1_segments) or j < len(obj2_segments):\n        if i < len(obj1_segments) and (j >= len(obj2_segments) or random.random() < obj1_weight):\n            new_solution.extend(obj1_segments[i])\n            i += 1\n        else:\n            new_solution.extend(obj2_segments[j])\n            j += 1\n\n    # Step 5: Reconstruct solution and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(balanced_segments) > 1:\n            i = random.randint(0, len(balanced_segments)-1)\n            _, seg = balanced_segments[i]\n            balanced_segments[i] = (3 - balanced_segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in balanced_segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9649067500895167,
               0.15749871730804443
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Balancing Path Reinforcement with Multi-Dimensional Node Alignment,\" begins by selecting the least balanced solution from the archive to focus on improving its objective trade-offs, then employs a novel \"multi-dimensional node alignment\" technique that simultaneously considers both objective spaces to identify critical nodes that serve as alignment points for path reinforcement. These alignment nodes are dynamically selected based on their cross-objective contribution scores, and the algorithm then performs a \"path reinforcement cascade\" where it iteratively strengthens edges connected to these alignment nodes while maintaining feasibility through a \"dimensional consistency validation\" mechanism that ensures no node is skipped or revisited. The method adaptively balances between local and global improvements by probabilistically exploring alternative paths that improve both objectives, with a \"hybrid edge optimization\" phase that selectively replaces edges with alternatives that offer better trade-offs between the objectives while preserving the tour's structural integrity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the least balanced solution to focus on improving its trade-offs\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify multi-dimensional alignment nodes\n    alignment_nodes = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Node is an alignment point if it has significantly different contributions to both objectives\n        if abs(cost1 - cost2) > 0.3 * (cost1 + cost2):\n            alignment_nodes.append((i, node, cost1, cost2))\n\n    # Step 2: Path reinforcement cascade around alignment nodes\n    for (i, node, cost1, cost2) in alignment_nodes:\n        if random.random() < 0.7:  # 70% chance to reinforce this node's connections\n            # Find potential replacement edges\n            candidates = []\n            for j in range(n):\n                if j != i and j != (i-1)%n and j != (i+1)%n:\n                    # Calculate potential new edges\n                    prev = new_solution[(j-1)%n]\n                    next_node = new_solution[(j+1)%n]\n\n                    new_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n                    new_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n                    # Check if this is a better trade-off\n                    if (new_cost1 < cost1 and new_cost2 <= 1.1 * cost2) or \\\n                       (new_cost2 < cost2 and new_cost1 <= 1.1 * cost1):\n                        candidates.append((j, new_cost1, new_cost2))\n\n            # Select best candidate if available\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: abs(x[1] - x[2]))\n                j, _, _ = best_candidate\n\n                # Perform swap to reinforce alignment node's position\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Hybrid edge optimization\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to optimize this edge\n            prev = new_solution[i-1]\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            current_cost1 = distance_matrix_1[prev, current] + distance_matrix_1[current, next_node]\n            current_cost2 = distance_matrix_2[prev, current] + distance_matrix_2[current, next_node]\n\n            # Find alternative path\n            for j in range(n):\n                if j != i and j != (i-1)%n and j != (i+1)%n:\n                    alt_prev = new_solution[j]\n                    alt_current = new_solution[(j+1)%n]\n                    alt_next = new_solution[(j+2)%n]\n\n                    new_cost1 = distance_matrix_1[alt_prev, current] + distance_matrix_1[current, alt_next]\n                    new_cost2 = distance_matrix_2[alt_prev, current] + distance_matrix_2[current, alt_next]\n\n                    # Check if this is a better trade-off\n                    if (new_cost1 < current_cost1 and new_cost2 <= 1.1 * current_cost2) or \\\n                       (new_cost2 < current_cost2 and new_cost1 <= 1.1 * current_cost1):\n                        # Perform 2-opt swap\n                        if i < j:\n                            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                        else:\n                            new_solution[j+1:i+1] = new_solution[j+1:i+1][::-1]\n                        break\n\n    # Step 4: Dimensional consistency validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Rebuild solution if invalid\n        new_solution = np.random.permutation(np.arange(n))\n\n    # Ensure circular tour\n    new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.0068185831289216,
               1.560471773147583
          ]
     },
     {
          "algorithm": "{This novel algorithm, named \"Multi-Objective Path Evolution with Adaptive Segment Recombination and Objective-Aware Edge Reinforcement,\" begins by selecting the solution from the archive with the highest combined objective diversity, then employs a unique \"objective space projection\" technique to analyze the solution's structure in both objective spaces simultaneously, creating a hybrid representation that preserves the relative importance of each objective. The algorithm then performs a \"dynamic segment recombination\" phase where it probabilistically breaks and reconnects segments of the tour based on their cross-objective trade-off potential, using a novel \"objective trade-off entropy\" metric to guide the recombination process. Following this, an \"adaptive edge reinforcement\" step selectively strengthens or weakens edges based on their contribution to improving both objectives, with a \"bi-objective edge selection\" mechanism that evaluates each edge's impact on both objectives before modification. The method includes a \"path topology preservation\" validation step that ensures the solution maintains structural diversity while improving the objectives, and employs a \"multi-objective edge optimization\" phase to refine the tour by replacing edges with alternatives that offer better trade-offs between the objectives, all while maintaining tour feasibility through a comprehensive validation mechanism.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with highest combined objective diversity\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Objective space projection and segment identification\n    segments = []\n    current_segment = [new_solution[0]]\n    objective_weights = [0, 0]\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Update objective weights\n        objective_weights[0] += cost1\n        objective_weights[1] += cost2\n\n        # Determine if edge belongs to a new segment\n        if (cost1 > 1.2 * cost2 and abs(objective_weights[0] - objective_weights[1]) > 0.1 * (objective_weights[0] + objective_weights[1])) or \\\n           (cost2 > 1.2 * cost1 and abs(objective_weights[0] - objective_weights[1]) > 0.1 * (objective_weights[0] + objective_weights[1])):\n            segments.append(current_segment)\n            current_segment = [current_node]\n            objective_weights = [0, 0]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic segment recombination\n    for i in range(len(segments)):\n        if len(segments[i]) < 3:\n            continue\n\n        # Calculate segment trade-off entropy\n        cost1 = sum(distance_matrix_1[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n        cost2 = sum(distance_matrix_2[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n        trade_off_entropy = abs(cost1 - cost2) / (cost1 + cost2)\n\n        # Recombine segments with high trade-off entropy\n        if trade_off_entropy > 0.3 and random.random() < 0.6:\n            # Find another segment to merge with\n            j = random.randint(0, len(segments)-1)\n            if i != j and len(segments[j]) > 1:\n                # Merge segments\n                segments[i] = segments[i] + segments[j][1:]\n                segments.pop(j)\n\n    # Step 4: Adaptive edge reinforcement\n    for i in range(len(new_solution)-1):\n        prev_node = new_solution[i]\n        current_node = new_solution[i+1]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Calculate edge reinforcement probability\n        if cost1 > 1.1 * cost2:\n            # Strengthen edge for objective 2\n            if random.random() < 0.4:\n                # Find alternative path that improves objective 2\n                for j in range(len(new_solution)-1):\n                    if j != i and j != i+1:\n                        alt_prev = new_solution[j]\n                        alt_current = new_solution[j+1]\n                        alt_cost1 = distance_matrix_1[alt_prev, alt_current]\n                        alt_cost2 = distance_matrix_2[alt_prev, alt_current]\n\n                        if alt_cost2 < cost2 and alt_cost1 <= 1.2 * cost1:\n                            # Swap edges\n                            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n                            break\n        elif cost2 > 1.1 * cost1:\n            # Strengthen edge for objective 1\n            if random.random() < 0.4:\n                # Find alternative path that improves objective 1\n                for j in range(len(new_solution)-1):\n                    if j != i and j != i+1:\n                        alt_prev = new_solution[j]\n                        alt_current = new_solution[j+1]\n                        alt_cost1 = distance_matrix_1[alt_prev, alt_current]\n                        alt_cost2 = distance_matrix_2[alt_prev, alt_current]\n\n                        if alt_cost1 < cost1 and alt_cost2 <= 1.2 * cost2:\n                            # Swap edges\n                            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n                            break\n\n    # Step 5: Path topology preservation validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Rebuild solution if invalid\n        new_solution = np.random.permutation(np.arange(n))\n        new_solution = np.append(new_solution, new_solution[0])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9719592061172813,
               0.3942081332206726
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Dynamic Objective-Polarity Swarm Optimization with Cross-Dimensional Node Clustering,\" combines elements of the provided approaches but introduces a fundamentally different strategy. It first identifies the most balanced solution in the archive, then decomposes the tour into clusters of nodes based on their dominant objective polarity (either primarily contributing to objective 1 or objective 2), using a novel \"objective-polarity\" metric that classifies each node's contribution to one of the two objectives. These clusters are then dynamically optimized by swapping nodes between clusters based on their cross-dimensional contribution scores, while simultaneously applying a swarm-inspired optimization that probabilistically explores alternative configurations by allowing nodes to \"migrate\" between clusters based on their relative objective contributions. The method dynamically adjusts the cluster formation and migration parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a cluster validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Classify nodes into objective-polarity clusters\n    cluster1 = []\n    cluster2 = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        if cost1 > cost2 * 1.2:\n            cluster1.append(node)\n        elif cost2 > cost1 * 1.2:\n            cluster2.append(node)\n        else:\n            if len(cluster1) <= len(cluster2):\n                cluster1.append(node)\n            else:\n                cluster2.append(node)\n\n    # Step 2: Dynamic node migration between clusters\n    for _ in range(2):\n        for i in range(len(cluster1)):\n            node = cluster1[i]\n            # Calculate potential improvement if moved to cluster2\n            prev_node = cluster1[i-1] if i > 0 else cluster1[-1]\n            next_node = cluster1[(i+1)%len(cluster1)] if len(cluster1) > 1 else cluster1[0]\n\n            current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Find best position in cluster2\n            best_pos = -1\n            best_score = float('inf')\n            for j in range(len(cluster2)+1):\n                if j == 0:\n                    prev = cluster2[-1] if len(cluster2) > 0 else cluster2[0]\n                    next_node = cluster2[0] if len(cluster2) > 0 else cluster2[-1]\n                elif j == len(cluster2):\n                    prev = cluster2[-1]\n                    next_node = cluster2[0]\n                else:\n                    prev = cluster2[j-1]\n                    next_node = cluster2[j]\n\n                new_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n                new_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n                score = abs(new_cost1 - new_cost2)\n                if score < best_score:\n                    best_score = score\n                    best_pos = j\n\n            if best_pos != -1:\n                # Calculate expected improvement\n                current_score = abs(current_cost1 - current_cost2)\n                if best_score < current_score * 0.9:\n                    # Perform migration\n                    cluster1.pop(i)\n                    if best_pos == len(cluster2):\n                        cluster2.append(node)\n                    else:\n                        cluster2.insert(best_pos, node)\n                    break\n\n    # Step 3: Reconstruct solution from clusters\n    new_solution = []\n    i, j = 0, 0\n    while i < len(cluster1) or j < len(cluster2):\n        if i < len(cluster1) and (j >= len(cluster2) or random.random() < 0.5):\n            new_solution.append(cluster1[i])\n            i += 1\n        else:\n            new_solution.append(cluster2[j])\n            j += 1\n\n    # Ensure circularity\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9672244263339664,
               0.23158270120620728
          ]
     }
]