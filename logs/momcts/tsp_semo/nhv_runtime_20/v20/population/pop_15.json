[
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the lowest combined objective value) and applies a novel 4-opt-inspired local search by randomly selecting four edges and reconnecting them in a non-standard way to explore higher-quality neighborhoods, ensuring feasibility by reversing segments and maintaining a circular tour. The key design idea is to prioritize the most promising solution while introducing diversity through a creative edge-reconnection strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[l:j+1][::-1],\n        new_solution[k:l+1][::-1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9964296678185147,
            0.10547882318496704
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective) and applies a novel 4-opt-inspired local search by randomly selecting four edges, reversing segments between them, and reconnecting them to explore a larger neighborhood while ensuring feasibility. It prioritizes solutions with lower total cost and dynamically modifies the tour by segment reversal and concatenation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        new_solution[b:c+1][::-1],\n        new_solution[d:],\n        new_solution[a+1:b+1][::-1],\n        new_solution[c+1:d+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9715020941909596,
            0.14212608337402344
        ]
    },
    {
        "algorithm": "The algorithm selects a base solution from the archive based on objective diversity, then applies a hybrid local search combining adaptive segment relocations and node exchanges, ensuring feasibility through circular tour maintenance and evaluating improvements using an objective-weighted acceptance criterion. It prioritizes solutions with diverse objectives and uses probabilistic acceptance to balance improvements across both spaces, while maintaining valid TSP tours through segment manipulation and exchange operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_size = max(2, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n\n    # Remove segment and insert at new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Node exchange with objective-weighted acceptance\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Calculate cost changes\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Objective-weighted improvement criterion\n        delta1 = new_cost1 - old_cost1\n        delta2 = new_cost2 - old_cost2\n        acceptance_prob = 1.0 / (1.0 + np.exp(0.5 * (delta1 + delta2)))\n\n        if np.random.rand() < acceptance_prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9739385286197475,
            0.7466378808021545
        ]
    },
    {
        "algorithm": "This algorithm selects extreme solutions from the archive (prioritizing those with highest combined objective values) and applies a hybrid local search combining dynamic segment rotations and node swaps, focusing on balanced improvements in both objectives while ensuring tour validity through circularity checks. The method uses probabilistic segment rotation and selective node swaps based on objective improvements, with a bias toward solutions that show potential for further optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with extreme objective values\n    objectives = np.array([obj for _, obj in archive])\n    extreme_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[extreme_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    segment_size = max(3, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    if np.random.rand() < 0.7:\n        # Rotate segment\n        segment = new_solution[start:end]\n        rotated = np.roll(segment, np.random.randint(1, segment_size))\n        new_solution[start:end] = rotated\n    else:\n        # Swap nodes with probability based on objective improvement\n        for _ in range(5):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= 0.95 * old_cost1 and new_cost2 <= 0.95 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9648589443513792,
            0.49024927616119385
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of objectives (60% for the first objective, 40% for the second), then applies a hybrid local search combining edge swaps (70% chance) with segment reversals (30% chance) to explore diverse neighborhoods while ensuring feasibility. It also includes an occasional random edge flip (30% chance) for additional diversity, and guarantees a circular tour by appending the start node if needed. The method prioritizes the first objective in selection but balances exploration of both objectives in perturbation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    if random.random() < 0.7:  # 70% chance for edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation for diversity\n    if random.random() < 0.3:  # 30% chance for random edge flip\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.8907118218798389,
            0.2272680401802063
        ]
    },
    {
        "algorithm": "The algorithm combines nondominated solution selection with a hybrid local search that dynamically alternates between segment-based operations (reversal/rotation) and edge-based swaps, prioritizing objective diversity and adaptive segment sizes while ensuring feasibility through probabilistic operation selection and circular tour maintenance. It balances exploration (via segment operations) and exploitation (via edge swaps) with a focus on improving both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in nondominated])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment size and operation selection\n    segment_size = max(2, int(np.ceil(n * 0.15 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Dynamic operation selection based on objective improvement potential\n    if np.random.rand() < 0.6:\n        # Segment-based operation\n        if np.random.rand() < 0.5:\n            # Dynamic segment reversal\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Dynamic segment rotation\n            segment = new_solution[start:end]\n            rotated = np.roll(segment, np.random.randint(1, segment_size))\n            new_solution[start:end] = rotated\n    else:\n        # Edge-based operation\n        for _ in range(3):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= 0.9 * old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= 0.9 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9706242552447388,
            1.0275250673294067
        ]
    },
    {
        "algorithm": "The algorithm selects the most diverse solution from the archive (based on the sum of consecutive distances in both objective spaces) and applies a novel 3-opt-inspired local search by randomly selecting three edges and reconnecting them in a non-standard way to explore diverse neighborhoods while ensuring feasibility by reversing segments and maintaining a circular tour. The selection prioritizes diversity, and the local search introduces controlled perturbations to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity (sum of consecutive distances in both spaces)\n    selected_solution = max(archive, key=lambda x: sum(distance_matrix_1[x[0][i], x[0][i+1]] + distance_matrix_2[x[0][i], x[0][i+1]] for i in range(len(x[0])-1)))[0].copy()\n\n    # Apply a novel 3-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create a new tour by reconnecting the edges in a different order\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[k:j+1][::-1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9519669511674939,
            6.079950988292694
        ]
    },
    {
        "algorithm": "The heuristic selects the solution with the highest combined objective value from the archive, then applies a novel 3-opt-inspired local search by randomly selecting three edges and reconnecting them in a way that maintains feasibility while exploring higher-quality neighborhoods. The algorithm prioritizes solutions with worse combined objectives (sum of both costs) to focus on less explored regions, and ensures the generated neighbor remains a valid TSP tour by reversing segments of the path and reconnecting them.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 3-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[j:k+1][::-1],\n        new_solution[k+1:],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.8796892138585624,
            0.27913469076156616
        ]
    },
    {
        "algorithm": "The algorithm prioritizes nondominated solutions from the archive, dynamically selects segments based on objective diversity, and employs a hybrid local search combining adaptive segment reversals and edge swaps to generate improved neighbor solutions while ensuring feasibility. It focuses on regions of the Pareto front with high improvement potential by evaluating edge swaps in both objective spaces and dynamically adjusting segment sizes. The selection of segments and edges is guided by a diversity metric, and the algorithm maintains a circular tour by ensuring the neighbor solution remains a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select a solution based on objective diversity\n    objectives = np.array([obj for _, obj in nondominated])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective diversity\n    segment_size = max(2, int(np.ceil(n * 0.1 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Hybrid local search: adaptive segment reversal and edge swaps\n    if np.random.rand() < 0.5:\n        # Reverse segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        # Swap edges\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Edge selection based on objective improvement\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 <= old_cost2) or (new_cost1 <= old_cost1 and new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9470726877155471,
            1.2816454768180847
        ]
    },
    {
        "algorithm": "The algorithm combines nondominated solution selection with a dynamic segment inversion strategy, where segment sizes adapt to objective diversity in the archive. It prioritizes nondominated solutions (or the least-dominated ones if none exist) and inverts variable-length segments to explore neighborhoods, ensuring feasibility by maintaining circularity. The segment size is determined by the relative diversity of objectives, balancing exploration of both spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions from the archive\n    nondominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and (obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1])):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol1, obj1))\n\n    if not nondominated:\n        selected_solution = archive[np.argmin([sum(obj) for _, obj in archive])][0].copy()\n    else:\n        selected_solution = random.choice(nondominated)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective diversity in the archive\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_ratio = np.max(obj_range) / (np.sum(obj_range) + 1e-8)\n\n    # Determine segment size based on objective diversity\n    segment_size = max(2, int(np.ceil(n * 0.1 * (1 + diversity_ratio * np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Invert the selected segment to explore new neighborhoods\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9142397439276189,
            1.085079550743103
        ]
    }
]