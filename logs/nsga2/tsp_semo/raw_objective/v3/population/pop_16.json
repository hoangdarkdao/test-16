[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.693109339446275,
            4.482075269241729
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.7339966968769716,
            8.558740670390453
        ]
    }
]