[
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive objective-space segmentation with multi-dimensional path inversion and selective edge refinement, which first partitions the solution into dynamic segments based on the combined spatial proximity and edge strength in both objective spaces, then selectively inverts segments of the tour while considering their potential to improve both objectives, followed by a guided edge refinement phase that prioritizes edges with complementary improvement potential in both objectives while dynamically adjusting the refinement scope based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    segments.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        if seg1_end <= seg2_idx or seg2_end <= seg1_idx:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[seg1_idx-1], new_solution[seg1_idx]] +\n                   distance_matrix_1[new_solution[seg1_end-1], new_solution[seg1_end%n]] +\n                   distance_matrix_1[new_solution[seg2_idx-1], new_solution[seg2_idx]] +\n                   distance_matrix_1[new_solution[seg2_end-1], new_solution[seg2_end%n]] +\n                   distance_matrix_2[new_solution[seg1_idx-1], new_solution[seg1_idx]] +\n                   distance_matrix_2[new_solution[seg1_end-1], new_solution[seg1_end%n]] +\n                   distance_matrix_2[new_solution[seg2_idx-1], new_solution[seg2_idx]] +\n                   distance_matrix_2[new_solution[seg2_end-1], new_solution[seg2_end%n]])\n\n        candidate = new_solution.copy()\n        candidate[seg1_idx:seg1_end] = candidate[seg1_idx:seg1_end][::-1]\n        candidate[seg2_idx:seg2_end] = candidate[seg2_idx:seg2_end][::-1]\n\n        new_cost = (distance_matrix_1[candidate[seg1_idx-1], candidate[seg1_idx]] +\n                   distance_matrix_1[candidate[seg1_end-1], candidate[seg1_end%n]] +\n                   distance_matrix_1[candidate[seg2_idx-1], candidate[seg2_idx]] +\n                   distance_matrix_1[candidate[seg2_end-1], candidate[seg2_end%n]] +\n                   distance_matrix_2[candidate[seg1_idx-1], candidate[seg1_idx]] +\n                   distance_matrix_2[candidate[seg1_end-1], candidate[seg1_end%n]] +\n                   distance_matrix_2[candidate[seg2_idx-1], candidate[seg2_idx]] +\n                   distance_matrix_2[candidate[seg2_end-1], candidate[seg2_end%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                   distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                   distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                   distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        candidate = new_solution.copy()\n        if abs(i - j) == 1:\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n        else:\n            if i < j:\n                candidate[i:j] = candidate[i:j][::-1]\n            else:\n                candidate[j:i] = candidate[j:i][::-1]\n\n        new_cost = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                   distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_1[candidate[j-1], candidate[j]] +\n                   distance_matrix_1[candidate[j], candidate[(j+1)%n]] +\n                   distance_matrix_2[candidate[i-1], candidate[i]] +\n                   distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                   distance_matrix_2[candidate[j-1], candidate[j]] +\n                   distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.349129161401871,
               5.584827327931071
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining hierarchical clustering with multi-objective aware node relocation and insertion, which first partitions the solution into hierarchical clusters based on both spatial proximity and edge strength in both objective spaces, then performs a multi-dimensional relocation process that simultaneously considers both objectives to identify and move nodes to positions that promise improvement in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while dynamically adjusting the search depth based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.cluster.hierarchy import linkage, fcluster\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    Z = linkage(combined_dist + edge_strength, method='ward')\n    clusters = fcluster(Z, t=max(2, n//5), criterion='maxclust')\n\n    cluster_indices = {}\n    for idx, cluster in enumerate(clusters):\n        if cluster not in cluster_indices:\n            cluster_indices[cluster] = []\n        cluster_indices[cluster].append(idx)\n\n    sorted_clusters = sorted(cluster_indices.keys(), key=lambda x: -len(cluster_indices[x]))\n\n    for _ in range(min(3, len(sorted_clusters))):\n        if len(sorted_clusters) < 2:\n            break\n\n        cluster1 = sorted_clusters[0]\n        cluster2 = sorted_clusters[1]\n\n        node1_idx = np.random.choice(cluster_indices[cluster1])\n        node2_idx = np.random.choice(cluster_indices[cluster2])\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[node1_idx], new_solution[node2_idx] = new_solution[node2_idx], new_solution[node1_idx]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                  distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                  distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.74549398042133,
               6.26912932989482
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive multi-objective cluster-based segmentation with dynamic multi-dimensional node relocation and insertion, which first partitions the solution into dynamic clusters based on the combined spatial proximity and edge strength in both objective spaces, then performs a multi-dimensional node relocation process that simultaneously considers both objective spaces to identify and move nodes to positions that promise balanced improvement in both objectives while dynamically adjusting the relocation scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n    from sklearn.cluster import KMeans\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.hstack((coords1, coords2))\n\n    n_clusters = max(2, min(5, n // 5))\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(combined_coords)\n    clusters = kmeans.labels_\n\n    cluster_segments = []\n    for cluster_id in range(n_clusters):\n        cluster_indices = np.where(clusters == cluster_id)[0]\n        if len(cluster_indices) < 2:\n            continue\n\n        cluster_strength = 0\n        for i in range(len(cluster_indices)-1):\n            for j in range(i+1, len(cluster_indices)):\n                idx1 = cluster_indices[i]\n                idx2 = cluster_indices[j]\n                node1 = base_solution[idx1]\n                node2 = base_solution[idx2]\n                cluster_strength += (distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2])\n\n        cluster_segments.append((cluster_indices, cluster_strength))\n\n    cluster_segments.sort(key=lambda x: -x[1])\n\n    for _ in range(min(3, len(cluster_segments))):\n        if len(cluster_segments) < 2:\n            break\n\n        cluster1_indices, _ = cluster_segments[0]\n        cluster2_indices, _ = cluster_segments[1]\n\n        node1_idx = np.random.choice(cluster1_indices)\n        node2_idx = np.random.choice(cluster2_indices)\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[node1_idx], new_solution[node2_idx] = new_solution[node2_idx], new_solution[node1_idx]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            if temp_cost1 + temp_cost2 < best_cost:\n                if abs(temp_cost1 - temp_cost2) < 0.3 * (current_cost1 + current_cost2):\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.913262251851728,
               5.736991732219094
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive multi-objective tour segmentation with dynamic node reallocation and insertion, which first segments the solution into dynamic path segments based on the combined spatial proximity and edge strength in both objective spaces, then performs a multi-dimensional node reallocation process that simultaneously considers both objective spaces to identify and move nodes to positions that promise improvement in both objectives while dynamically adjusting the relocation scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    # Calculate combined spatial proximity and edge strength\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    # Dynamic tour segmentation\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment strength\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    # Sort segments by strength (descending)\n    segments.sort(key=lambda x: -x[2])\n\n    # Multi-dimensional node relocation with dynamic scope\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        # Select two segments with high strength\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        # Calculate dynamic relocation scope\n        scope = min(3, max(1, (seg1_end - seg1_idx) // 2))\n\n        # Select nodes from each segment within the scope\n        node1_idx = np.random.randint(seg1_idx, min(seg1_end, seg1_idx + scope))\n        node2_idx = np.random.randint(seg2_idx, min(seg2_end, seg2_idx + scope))\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                        distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                        distance_matrix_1[new_solution[node2_idx-1], node2] +\n                        distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        current_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                        distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                        distance_matrix_2[new_solution[node2_idx-1], node2] +\n                        distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        # Try relocating nodes between segments\n        candidate = new_solution.copy()\n\n        # Option 1: Move node1 to segment2 and node2 to segment1\n        temp_solution = candidate.copy()\n        temp_solution[node1_idx], temp_solution[node2_idx] = temp_solution[node2_idx], temp_solution[node1_idx]\n\n        new_cost1 = (distance_matrix_1[temp_solution[node1_idx-1], temp_solution[node1_idx]] +\n                    distance_matrix_1[temp_solution[node1_idx], temp_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[temp_solution[node2_idx-1], temp_solution[node2_idx]] +\n                    distance_matrix_1[temp_solution[node2_idx], temp_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[node1_idx-1], temp_solution[node1_idx]] +\n                    distance_matrix_2[temp_solution[node1_idx], temp_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[temp_solution[node2_idx-1], temp_solution[node2_idx]] +\n                    distance_matrix_2[temp_solution[node2_idx], temp_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            candidate = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n        # Option 2: Move node1 to segment2\n        temp_solution = candidate.copy()\n        temp_node = temp_solution[node1_idx]\n        temp_solution = np.delete(temp_solution, node1_idx)\n        insert_pos = np.random.randint(seg2_idx, min(seg2_end, seg2_idx + scope))\n        temp_solution = np.insert(temp_solution, insert_pos, temp_node)\n\n        new_cost1 = (distance_matrix_1[temp_solution[insert_pos-1], temp_solution[insert_pos]] +\n                    distance_matrix_1[temp_solution[insert_pos], temp_solution[(insert_pos+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[insert_pos-1], temp_solution[insert_pos]] +\n                    distance_matrix_2[temp_solution[insert_pos], temp_solution[(insert_pos+1)%n]])\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            candidate = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n        # Option 3: Move node2 to segment1\n        temp_solution = candidate.copy()\n        temp_node = temp_solution[node2_idx]\n        temp_solution = np.delete(temp_solution, node2_idx)\n        insert_pos = np.random.randint(seg1_idx, min(seg1_end, seg1_idx + scope))\n        temp_solution = np.insert(temp_solution, insert_pos, temp_node)\n\n        new_cost1 = (distance_matrix_1[temp_solution[insert_pos-1], temp_solution[insert_pos]] +\n                    distance_matrix_1[temp_solution[insert_pos], temp_solution[(insert_pos+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[insert_pos-1], temp_solution[insert_pos]] +\n                    distance_matrix_2[temp_solution[insert_pos], temp_solution[(insert_pos+1)%n]])\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            candidate = temp_solution\n\n        new_solution = candidate\n\n    # Guided insertion with global structure consideration\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        # Remove the node\n        candidate = np.delete(new_solution, i)\n\n        # Find the best position to reinsert the node\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            # Consider global structure impact\n            if len(temp) > 5:\n                # Check if the insertion maintains balanced improvement\n                if (abs(temp_cost1 - temp_cost2) < 0.3 * (current_cost1 + current_cost2)):\n                    if temp_cost1 + temp_cost2 < best_cost:\n                        best_cost = temp_cost1 + temp_cost2\n                        best_pos = j\n            else:\n                if temp_cost1 + temp_cost2 < best_cost:\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.810657527827963,
               6.002488523835153
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach that combines adaptive multi-objective path decomposition with dynamic segment reassembly, which first decomposes the solution into variable-length segments based on the combined spatial and objective-aware edge characteristics, then selectively reassembles these segments by considering their potential to improve both objectives, followed by a probabilistic segment rotation phase that dynamically adjusts the rotation direction based on the current solution's segment structure and the relative improvement potential in both objectives, and concludes with a constrained segment inversion phase that prioritizes segments with complementary improvement potential across both objectives, while maintaining feasibility through a permutation-aware validation mechanism.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate edge characteristics\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        combined_cost = edge_cost1 + edge_cost2\n\n        # Calculate spatial coherence\n        coord1_prev = instance[new_solution[i-1], :2]\n        coord1_curr = instance[new_solution[i], :2]\n        coord2_prev = instance[new_solution[i-1], 2:]\n        coord2_curr = instance[new_solution[i], 2:]\n        spatial_dist1 = np.linalg.norm(coord1_curr - coord1_prev)\n        spatial_dist2 = np.linalg.norm(coord2_curr - coord2_prev)\n\n        # Segment decision\n        if (combined_cost > 1.5 * np.mean([distance_matrix_1.mean(), distance_matrix_2.mean()]) or\n            spatial_dist1 > 2 * np.mean(spatial_dist1) or\n            spatial_dist2 > 2 * np.mean(spatial_dist2)):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Dynamic segment reassembly\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        # Select two random segments\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n        old_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n\n        new_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        new_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Reassemble segments\n            new_segments = segments.copy()\n            new_segments[seg1_idx] = seg2 + seg1\n            new_segments[seg2_idx] = []\n\n            # Update solution\n            new_solution = np.concatenate([s for s in new_segments if s])\n            segments = [s for s in new_segments if s]\n\n    # Probabilistic segment rotation\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 2:\n            continue\n\n        # Calculate rotation potential\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try both rotation directions\n        rotated1 = segment[1:] + [segment[0]]\n        rotated2 = [segment[-1]] + segment[:-1]\n\n        new_cost1_1 = sum(distance_matrix_1[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n        new_cost2_1 = sum(distance_matrix_2[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n\n        new_cost1_2 = sum(distance_matrix_1[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n        new_cost2_2 = sum(distance_matrix_2[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n\n        if (new_cost1_1 + new_cost2_1 < old_cost1 + old_cost2 and\n            np.random.random() < 0.7):\n            segments[seg_idx] = rotated1\n        elif (new_cost1_2 + new_cost2_2 < old_cost1 + old_cost2 and\n              np.random.random() < 0.7):\n            segments[seg_idx] = rotated2\n\n    # Constrained segment inversion\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 3:\n            continue\n\n        # Select inversion points\n        inv_start = np.random.randint(0, len(segment)-2)\n        inv_end = np.random.randint(inv_start+1, len(segment))\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_1[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n        old_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_2[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n\n        new_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_1[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n        new_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_2[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Perform inversion\n            segments[seg_idx] = segment[:inv_start] + segment[inv_start:inv_end+1][::-1] + segment[inv_end+1:]\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.011622709829145,
               5.6133114640121295
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive multi-objective path decomposition with dynamic multi-dimensional edge replacement and selective node reinsertion, which first partitions the solution into dynamic path segments based on the combined spatial proximity and edge strength in both objective spaces, then selectively replaces edges in these segments with alternative edges that promise balanced improvement in both objectives while dynamically adjusting the replacement scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a guided node reinsertion phase that prioritizes nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n    from sklearn.cluster import KMeans\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.hstack((coords1, coords2))\n\n    n_clusters = max(2, min(5, n // 5))\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(combined_coords)\n    clusters = kmeans.labels_\n\n    for cluster_id in range(n_clusters):\n        cluster_indices = np.where(clusters == cluster_id)[0]\n        if len(cluster_indices) < 2:\n            continue\n\n        for i in range(len(cluster_indices)-1):\n            for j in range(i+1, len(cluster_indices)):\n                idx1 = cluster_indices[i]\n                idx2 = cluster_indices[j]\n                node1 = new_solution[idx1]\n                node2 = new_solution[idx2]\n\n                old_cost1 = distance_matrix_1[node1, node2]\n                old_cost2 = distance_matrix_2[node1, node2]\n\n                candidate_edges = []\n                for k in range(n):\n                    if k != idx1 and k != idx2:\n                        node_k = new_solution[k]\n                        new_cost1 = distance_matrix_1[node1, node_k] + distance_matrix_1[node_k, node2]\n                        new_cost2 = distance_matrix_2[node1, node_k] + distance_matrix_2[node_k, node2]\n                        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n                            candidate_edges.append((k, new_cost1 + new_cost2))\n\n                if candidate_edges:\n                    candidate_edges.sort(key=lambda x: x[1])\n                    best_k, _ = candidate_edges[0]\n                    new_solution = np.insert(new_solution, idx2, new_solution[best_k])\n                    new_solution = np.delete(new_solution, best_k if best_k < idx2 else best_k + 1)\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            if temp_cost1 + temp_cost2 < best_cost:\n                if abs(temp_cost1 - temp_cost2) < 0.3 * (current_cost1 + current_cost2):\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.660841309447333,
               6.280915763508785
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach that combines adaptive multi-objective path decomposition with dynamic segment reassembly, which first decomposes the solution into variable-length segments based on the combined spatial and objective-aware edge characteristics, then selectively reassembles these segments by considering their potential to improve both objectives, followed by a probabilistic segment rotation phase that dynamically adjusts the rotation direction based on the current solution's segment structure and the relative improvement potential in both objectives, and concludes with a constrained segment inversion phase that prioritizes segments with complementary improvement potential across both objectives, while maintaining feasibility through a permutation-aware validation mechanism.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate edge characteristics\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        combined_cost = edge_cost1 + edge_cost2\n\n        # Calculate spatial coherence\n        coord1_prev = instance[new_solution[i-1], :2]\n        coord1_curr = instance[new_solution[i], :2]\n        coord2_prev = instance[new_solution[i-1], 2:]\n        coord2_curr = instance[new_solution[i], 2:]\n        spatial_dist1 = np.linalg.norm(coord1_curr - coord1_prev)\n        spatial_dist2 = np.linalg.norm(coord2_curr - coord2_prev)\n\n        # Segment decision\n        if (combined_cost > 1.5 * np.mean([distance_matrix_1.mean(), distance_matrix_2.mean()]) or\n            spatial_dist1 > 2 * np.mean(spatial_dist1) or\n            spatial_dist2 > 2 * np.mean(spatial_dist2)):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Dynamic segment reassembly\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        # Select two random segments\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n        old_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]] +\n                     distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]])\n\n        new_cost1 = (distance_matrix_1[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_1[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n        new_cost2 = (distance_matrix_2[new_solution[np.where(new_solution == seg1[-1])[0][0]], new_solution[np.where(new_solution == seg1[0])[0][0]]] +\n                    distance_matrix_2[new_solution[np.where(new_solution == seg2[-1])[0][0]], new_solution[np.where(new_solution == seg2[0])[0][0]]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Reassemble segments\n            new_segments = segments.copy()\n            new_segments[seg1_idx] = seg2 + seg1\n            new_segments[seg2_idx] = []\n\n            # Update solution\n            new_solution = np.concatenate([s for s in new_segments if s])\n            segments = [s for s in new_segments if s]\n\n    # Probabilistic segment rotation\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 2:\n            continue\n\n        # Calculate rotation potential\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try both rotation directions\n        rotated1 = segment[1:] + [segment[0]]\n        rotated2 = [segment[-1]] + segment[:-1]\n\n        new_cost1_1 = sum(distance_matrix_1[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n        new_cost2_1 = sum(distance_matrix_2[rotated1[i], rotated1[i+1]] for i in range(len(rotated1)-1))\n\n        new_cost1_2 = sum(distance_matrix_1[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n        new_cost2_2 = sum(distance_matrix_2[rotated2[i], rotated2[i+1]] for i in range(len(rotated2)-1))\n\n        if (new_cost1_1 + new_cost2_1 < old_cost1 + old_cost2 and\n            np.random.random() < 0.7):\n            segments[seg_idx] = rotated1\n        elif (new_cost1_2 + new_cost2_2 < old_cost1 + old_cost2 and\n              np.random.random() < 0.7):\n            segments[seg_idx] = rotated2\n\n    # Constrained segment inversion\n    for _ in range(2):\n        if len(segments) < 1:\n            break\n\n        seg_idx = np.random.choice(len(segments))\n        segment = segments[seg_idx]\n\n        if len(segment) < 3:\n            continue\n\n        # Select inversion points\n        inv_start = np.random.randint(0, len(segment)-2)\n        inv_end = np.random.randint(inv_start+1, len(segment))\n\n        # Calculate potential improvement\n        old_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_1[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n        old_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_start]] +\n                    distance_matrix_2[segment[inv_end], segment[(inv_end+1)%len(segment)]])\n\n        new_cost1 = (distance_matrix_1[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_1[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n        new_cost2 = (distance_matrix_2[segment[inv_start-1], segment[inv_end]] +\n                    distance_matrix_2[segment[inv_start], segment[(inv_end+1)%len(segment)]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            # Perform inversion\n            segments[seg_idx] = segment[:inv_start] + segment[inv_start:inv_end+1][::-1] + segment[inv_end+1:]\n\n    # Reconstruct solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.9730457089789875,
               5.61856834039389
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining dynamic objective-space aware path decomposition with adaptive multi-dimensional node swapping and insertion, which first decomposes the solution into dynamic path segments based on the relative improvement potential in both objective spaces and the current solution's structure, then performs an adaptive node swapping process that simultaneously considers both objectives to identify and swap nodes that promise balanced improvement in both objectives while dynamically adjusting the swapping scope based on the current solution's structure and the relative improvement potential in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while considering the global structure of the tour to ensure balanced improvement across both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from sklearn.metrics import pairwise_distances\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = pairwise_distances(coords1)\n    dist2 = pairwise_distances(coords2)\n\n    improvement_potential = np.zeros(n)\n    for i in range(n):\n        node = base_solution[i]\n        improvement_potential[i] = (np.sum(distance_matrix_1[node, :]) + np.sum(distance_matrix_2[node, :])) / (n-1)\n\n    sorted_indices = np.argsort(improvement_potential)[::-1]\n    segments = []\n    current_segment = [sorted_indices[0]]\n    for i in range(1, n):\n        if improvement_potential[sorted_indices[i]] > 0.7 * improvement_potential[current_segment[0]]:\n            current_segment.append(sorted_indices[i])\n        else:\n            if len(current_segment) > 1:\n                segments.append(current_segment)\n            current_segment = [sorted_indices[i]]\n    if len(current_segment) > 1:\n        segments.append(current_segment)\n\n    if not segments:\n        segments = [list(range(n))]\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 1:\n            break\n\n        segment = segments[np.random.randint(0, len(segments))]\n        if len(segment) < 2:\n            continue\n\n        i, j = np.random.choice(segment, 2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], node_j] +\n                    distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], node_i] +\n                    distance_matrix_1[node_i, new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], node_j] +\n                    distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], node_i] +\n                    distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            if temp_cost1 + temp_cost2 < best_cost:\n                if abs(temp_cost1 - temp_cost2) < 0.5 * (current_cost1 + current_cost2):\n                    best_cost = temp_cost1 + temp_cost2\n                    best_pos = j\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.813085790070849,
               5.842082912455715
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive multi-dimensional tour fragmentation with guided segment reintegration and probabilistic edge refinement, which first partitions the solution into dynamic segments based on the harmonic mean of spatial distances and edge costs across both objective spaces, then selectively reintegrates segments by considering their potential to improve both objectives while dynamically adjusting the segment boundaries based on the current solution's structure and the relative improvement potential in both objectives, followed by a probabilistic edge refinement phase that prioritizes edges with complementary improvement potential in both objectives while dynamically adjusting the refinement scope based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive multi-dimensional tour fragmentation\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate spatial distances\n        coord1_prev = instance[new_solution[i-1], :2]\n        coord1_curr = instance[new_solution[i], :2]\n        coord2_prev = instance[new_solution[i-1], 2:]\n        coord2_curr = instance[new_solution[i], 2:]\n        spatial_dist1 = np.linalg.norm(coord1_curr - coord1_prev)\n        spatial_dist2 = np.linalg.norm(coord2_curr - coord2_prev)\n\n        # Calculate edge costs\n        edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        # Calculate harmonic mean for segmentation decision\n        spatial_mean = 2 / (1/spatial_dist1 + 1/spatial_dist2)\n        cost_mean = 2 / (1/edge_cost1 + 1/edge_cost2)\n\n        if (spatial_mean > 1.2 * np.mean([spatial_dist1, spatial_dist2]) or\n            cost_mean > 1.2 * np.mean([edge_cost1, edge_cost2])):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Guided segment reintegration\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        # Select segments based on their potential improvement\n        seg_scores = []\n        for i, seg in enumerate(segments):\n            seg_start = new_solution[np.where(new_solution == seg[0])[0][0]]\n            seg_end = new_solution[np.where(new_solution == seg[-1])[0][0]]\n            prev_node = new_solution[(np.where(new_solution == seg[0])[0][0] - 1) % n]\n            next_node = new_solution[(np.where(new_solution == seg[-1])[0][0] + 1) % n]\n\n            cost1 = (distance_matrix_1[prev_node, seg_start] +\n                    distance_matrix_1[seg_end, next_node])\n            cost2 = (distance_matrix_2[prev_node, seg_start] +\n                    distance_matrix_2[seg_end, next_node])\n            seg_scores.append(cost1 + cost2)\n\n        if not seg_scores:\n            break\n\n        seg_scores = np.array(seg_scores)\n        seg_probs = np.exp(-seg_scores / np.max(seg_scores)) / np.sum(np.exp(-seg_scores / np.max(seg_scores)))\n        seg1_idx, seg2_idx = np.random.choice(len(segments), 2, p=seg_probs, replace=False)\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Calculate potential improvement\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        seg1_pos = np.where(candidate == seg1[0])[0][0]\n        seg2_pos = np.where(candidate == seg2[0])[0][0]\n\n        if seg1_pos < seg2_pos:\n            candidate[seg1_pos:seg1_pos+len(seg1)] = seg2\n            candidate[seg2_pos:seg2_pos+len(seg2)] = seg1\n        else:\n            candidate[seg2_pos:seg2_pos+len(seg2)] = seg1\n            candidate[seg1_pos:seg1_pos+len(seg1)] = seg2\n\n        new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution = candidate\n            segments[seg1_idx] = seg2\n            segments[seg2_idx] = seg1\n\n    # Probabilistic edge refinement\n    for _ in range(5):\n        if n < 4:\n            break\n\n        # Select edges to refine\n        edge_scores = []\n        for i in range(n):\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n            edge_scores.append(cost1 + cost2)\n\n        edge_scores = np.array(edge_scores)\n        edge_probs = np.exp(-edge_scores / np.max(edge_scores)) / np.sum(np.exp(-edge_scores / np.max(edge_scores)))\n        i = np.random.choice(n, p=edge_probs)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        if np.random.random() < 0.5:\n            # Try to insert node before i\n            j = np.random.choice([x for x in range(n) if x != i and x != (i-1)%n and x != (i+1)%n])\n            if j < i:\n                candidate[j:i] = candidate[j:i][::-1]\n            else:\n                candidate[i:j] = candidate[i:j][::-1]\n        else:\n            # Try to swap nodes\n            j = np.random.choice([x for x in range(n) if x != i and x != (i-1)%n and x != (i+1)%n])\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate costs\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n        new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n\n        if (new_cost1 + new_cost2 < old_cost1 + old_cost2 and\n            np.random.random() < 0.7 * (old_cost1 + old_cost2) / (new_cost1 + new_cost2)):\n            new_solution = candidate\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.706864110685455,
               5.251959939000631
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive multi-objective path segmentation with dynamic node redistribution and multi-dimensional insertion, which first partitions the solution into adaptive segments based on the combined spatial proximity and edge strength in both objective spaces, then performs a dynamic redistribution process that simultaneously considers both objectives to identify and move nodes to positions that promise improvement in both objectives, followed by a multi-dimensional insertion phase that prioritizes nodes with complementary improvement potential in both objectives while dynamically adjusting the search depth based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    segment_size = max(3, min(7, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(segment)-1) for j in range(i+1, len(segment)))\n        segments.append((i, i+segment_size, strength))\n\n    segments.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        node1_idx = np.random.randint(seg1_idx, seg1_end)\n        node2_idx = np.random.randint(seg2_idx, seg2_end)\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[node1_idx], new_solution[node2_idx] = new_solution[node2_idx], new_solution[node1_idx]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                  distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                  distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.816458441541598,
               5.358897423780872
          ]
     }
]