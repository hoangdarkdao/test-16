[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.765381223706096,
            6.829708949278469
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.765381223706096,
            6.829708949278469
        ]
    }
]