[
    {
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a novel \"cross-segment insertion\" operator that inserts a randomly selected segment from one part of the tour into another position, followed by a \"multi-segment reversal\" that reverses multiple non-overlapping segments to create a more diverse neighborhood.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment insertion\n    if n > 3:\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Insert the segment at a new position\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n        # Reinsert the segment at the new position\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if insertion causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Multi-segment reversal\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        # Reverse both segments\n        new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n        new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8749075943578248,
            0.14364105463027954
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: -(x[1][0] + x[1][1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current costs for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Adaptive segment selection based on objective costs\n    if current_cost1 > current_cost2:\n        # Focus on improving the first objective\n        segment_length = max(2, min(5, n // 4))\n        i = np.random.randint(0, n - segment_length)\n        j = i + segment_length\n    else:\n        # Focus on improving the second objective\n        segment_length = max(2, min(5, n // 3))\n        i = np.random.randint(0, n - segment_length)\n        j = i + segment_length\n\n    # Apply segment reversal\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge-swap operation with cost validation\n    if np.random.random() < 0.5:\n        a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if abs(a - b) > 1:\n            # Check if swap improves at least one objective\n            old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n            new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n            old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n            new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8617086163167975,
            0.554394543170929
        ]
    },
    {
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a novel \"cross-segment insertion\" operator that inserts a randomly selected segment from one part of the tour into another position, followed by a \"multi-segment reversal\" that reverses multiple non-overlapping segments to create a more diverse neighborhood.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment insertion\n    if n > 3:\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Insert the segment at a new position\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n        # Reinsert the segment at the new position\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if insertion causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Multi-segment reversal\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        # Reverse both segments\n        new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n        new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8749075943578248,
            0.14364105463027954
        ]
    }
]