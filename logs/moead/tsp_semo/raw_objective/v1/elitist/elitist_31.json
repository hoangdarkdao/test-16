[
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.726633453615786,
            6.6230135648169055
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.726633453615786,
            6.6230135648169055
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], -max(x[1][0], x[1][1])))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end]\n\n    # Step 2: Find the best insertion point for the segment\n    best_pos = start\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= start and pos <= end:\n            continue\n\n        # Remove segment and insert at new position\n        temp_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:pos],\n            segment,\n            new_solution[pos:]\n        ])\n\n        # Calculate improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[(end)%n]]\n        new_cost1 = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_1[temp_solution[(pos+len(segment))%n], temp_solution[(pos+len(segment)+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[(end)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_2[temp_solution[(pos+len(segment))%n], temp_solution[(pos+len(segment)+1)%n]]\n\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best found insertion\n    if best_pos != start:\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Step 3: Apply a probabilistic edge swap for further improvement\n    if random.random() < 0.5:\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.522828957677136,
            5.497725174163544
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for objective 1 and 2\n    scores = [(weights[0] * obj[0] + weights[1] * obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two segments and reverse one\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly select a node and insert it at a better position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n\n    # Find the best insertion position\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - 1):\n        if pos == k or pos == k - 1:\n            continue\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = distance_matrix_1[temp_solution[pos-1], node] + distance_matrix_1[node, temp_solution[pos+1]]\n        cost2 = distance_matrix_2[temp_solution[pos-1], node] + distance_matrix_2[node, temp_solution[pos+1]]\n        total_cost = weights[0] * cost1 + weights[1] * cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.319003356661469,
            6.535960789224223
        ]
    },
    {
        "algorithm": "{This novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Sort by Pareto dominance (simplified by sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Top 4 candidates\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        return np.array([])  # Handle empty archive\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Hybrid local search: Segment reversal with edge exchange\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two edges and attempt a swap\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.783127783487385,
            6.088048186591086
        ]
    },
    {
        "algorithm": "{This novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a novel segment relocation and edge insertion operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 50% or random if too few\n        candidates = sorted_archive[:max(1, len(archive)//2)]\n        selected_idx = random.randint(0, len(candidates)-1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel segment relocation and edge insertion\n    # Select a segment to relocate\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, n-1)\n\n    # Extract the segment\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Find insertion point that minimizes both objectives\n    best_insert = 0\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for i in range(n-1):\n        if i >= seg_start and i <= seg_end:\n            continue\n\n        # Calculate cost for inserting after position i\n        cost1 = distance_matrix_1[new_solution[i], segment[0]] + distance_matrix_1[segment[-1], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], segment[0]] + distance_matrix_2[segment[-1], new_solution[(i+1)%n]]\n\n        if i > seg_start:  # Account for removed edges\n            cost1 += distance_matrix_1[new_solution[seg_start-1], new_solution[seg_end+1]]\n            cost2 += distance_matrix_2[new_solution[seg_start-1], new_solution[seg_end+1]]\n\n        if cost1 < best_cost1 or (cost1 == best_cost1 and cost2 < best_cost2):\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_insert = i\n\n    # Insert the segment\n    if best_insert > seg_start:\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:best_insert+1],\n            segment,\n            new_solution[best_insert+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:best_insert+1],\n            segment,\n            new_solution[best_insert+1:seg_start],\n            new_solution[seg_end+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            4.92634912170131,
            8.877590845860304
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        max_diversity = -1\n        selected_idx = 0\n        for i in range(len(archive)):\n            diversity = abs(archive[i][1][0] - archive[i][1][1])\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply segment rotation\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Apply edge insertion if beneficial\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c == d:\n        d = (d + 1) % n\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[d-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[d-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.insert(new_solution, c, new_solution[d])\n        new_solution = np.delete(new_solution, d + (1 if d > c else 0))\n\n    return new_solution\n\n",
        "score": [
            4.642535375401237,
            9.873569304166386
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a hybrid local search that combines segment insertion and node swapping with a probabilistic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by first objective (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        # Select from top 20% of solutions\n        selected_idx = random.randint(0, max(1, len(sorted_archive) // 5 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly swap two nodes with probability based on cost improvement\n    i, j = random.sample(range(n), 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Accept swap if at least one objective improves\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.808306659805302,
            9.712745174338405
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified: select the one with the best combined score)\n        scores = [sum(obj) for _, obj in archive]\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.105070278368307,
            5.931977199948847
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for idx, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = idx\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select three random non-adjacent nodes\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Perform a 3-opt move (a, b, c) -> (a, c, b)\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 3: Check if the move improves at least one objective\n    def calculate_cost(sol, matrix):\n        cost = 0\n        for i in range(n):\n            cost += matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if (new_cost1 > current_cost1 and new_cost2 > current_cost2):\n        # If the move worsens both objectives, try another approach\n        # Step 4: Perform a node insertion\n        node = random.randint(0, n-1)\n        pos = random.randint(0, n-1)\n        if node != pos:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node]], new_solution[pos:node], new_solution[node+1:]])\n\n    return new_solution\n\n",
        "score": [
            6.3534887732394685,
            5.736407845752355
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(i, j)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[k-j+i:], segment[:k-j+i]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node into a different position\n    m = random.randint(0, n - 1)\n    node = new_solution[m]\n    new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.102176592890957,
            6.013121299168331
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(obj[0] - obj[1] for obj in objectives)\n        selected_idx = [i for i, obj in enumerate(objectives) if abs(obj[0] - obj[1]) == max_diff][0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    if k < i or k > j:\n        inserted_segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], inserted_segment, new_solution[k+1:]])\n\n    # Apply edge reversal if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n    reversed_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k+1]] + distance_matrix_1[new_solution[k+1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n    reversed_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k+1]] + distance_matrix_2[new_solution[k+1], new_solution[k]]\n\n    if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.372027483411268,
            5.052907828361045
        ]
    }
]