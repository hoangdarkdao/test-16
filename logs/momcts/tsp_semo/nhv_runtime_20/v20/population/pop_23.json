[
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the lowest combined objective value) and applies a novel 4-opt-inspired local search by randomly selecting four edges and reconnecting them in a non-standard way to explore higher-quality neighborhoods, ensuring feasibility by reversing segments and maintaining a circular tour. The key design idea is to prioritize the most promising solution while introducing diversity through a creative edge-reconnection strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[l:j+1][::-1],\n        new_solution[k:l+1][::-1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9964296678185147,
            0.10547882318496704
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on normalized objective diversity, then applies a hybrid local search combining adaptive segment operations (reversal/insertion) with probabilistic edge swaps, dynamically adjusting segment sizes and operation probabilities while ensuring tour feasibility through circular maintenance. The selection prioritizes solutions with diverse objectives, and the local search balances segment-based and edge-based operations, favoring improvements in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalized objective diversity selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment parameters\n    segment_size = max(3, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Dynamic operation selection with probability adjustment\n    operation_prob = 0.7 if np.random.rand() < 0.5 else 0.3\n    if np.random.rand() < operation_prob:\n        # Segment-based operation with insertion\n        segment = new_solution[start:end]\n        new_pos = np.random.randint(0, n - segment_size + 1)\n        if new_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n    else:\n        # Edge-based operation with probabilistic swap\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if (delta1 < 0 and delta2 < 0) or (delta1 <= 0 and delta2 < -0.1 * abs(delta2)) or (delta2 <= 0 and delta1 < -0.1 * abs(delta1)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -1.0185430357878715,
            0.564102828502655
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective) and applies a novel 4-opt-inspired local search by randomly selecting four edges, reversing segments between them, and reconnecting them to explore a larger neighborhood while ensuring feasibility. It prioritizes solutions with lower total cost and dynamically modifies the tour by segment reversal and concatenation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        new_solution[b:c+1][::-1],\n        new_solution[d:],\n        new_solution[a+1:b+1][::-1],\n        new_solution[c+1:d+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9715020941909596,
            0.14212608337402344
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on crowding distance in the Pareto front, then generates a neighbor by adaptively extracting and inserting a rotated segment from another solution, ensuring feasibility through uniqueness checks and circular validation. It dynamically adjusts the segment size and rotation based on solution quality, prioritizing well-distributed solutions for better exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for Pareto front solutions\n    nondominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol1, obj1))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Sort nondominated solutions by crowding distance (descending)\n    crowding_distances = []\n    for sol, obj in nondominated:\n        # Calculate distances to neighbors in objective space\n        left = right = None\n        for other_sol, other_obj in nondominated:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                if left is None or (other_obj[0] > left[0] and other_obj[1] > left[1]):\n                    left = other_obj\n            if other_obj[0] > obj[0] and other_obj[1] > obj[1]:\n                if right is None or (other_obj[0] < right[0] and other_obj[1] < right[1]):\n                    right = other_obj\n        # Calculate crowding distance\n        if left is None or right is None:\n            crowding_distances.append(float('inf'))\n        else:\n            crowding_distances.append((right[0] - left[0]) + (right[1] - left[1]))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = nondominated[selected_idx][0].copy()\n\n    # Select a random solution from the entire archive for crossover\n    crossover_idx = np.random.randint(0, len(archive))\n    crossover_solution = archive[crossover_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment size based on solution quality\n    segment_size = max(2, int(0.3 * n * (1 - np.random.rand() * 0.4)))\n    start = np.random.randint(0, n - segment_size + 1)\n\n    # Extract the segment from the crossover solution\n    segment = crossover_solution[start:start + segment_size]\n\n    # Find the position to insert the segment in the selected solution\n    insert_pos = np.random.randint(0, n - segment_size + 1)\n\n    # Rotate the segment based on distance metrics\n    rotate_amount = np.random.randint(0, segment_size)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n\n    # Insert the rotated segment into the selected solution\n    new_solution = np.concatenate([\n        selected_solution[:insert_pos],\n        rotated_segment,\n        selected_solution[insert_pos + segment_size:]\n    ])\n\n    # Ensure uniqueness and validity\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -1.006136939204562,
            1.0287234783172607
        ]
    },
    {
        "algorithm": "The algorithm selects a base solution from the archive based on objective diversity, then applies a hybrid local search combining adaptive segment relocations and node exchanges, ensuring feasibility through circular tour maintenance and evaluating improvements using an objective-weighted acceptance criterion. It prioritizes solutions with diverse objectives and uses probabilistic acceptance to balance improvements across both spaces, while maintaining valid TSP tours through segment manipulation and exchange operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_size = max(2, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n\n    # Remove segment and insert at new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Node exchange with objective-weighted acceptance\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Calculate cost changes\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Objective-weighted improvement criterion\n        delta1 = new_cost1 - old_cost1\n        delta2 = new_cost2 - old_cost2\n        acceptance_prob = 1.0 / (1.0 + np.exp(0.5 * (delta1 + delta2)))\n\n        if np.random.rand() < acceptance_prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9739385286197475,
            0.7466378808021545
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by balancing objective diversity (70%) and quality (30%), then applies a hybrid local search combining segment reversal, probabilistic edge swaps, and segment-edge hybrid operations, with adaptive probabilities and objective-aware improvements, while ensuring tour feasibility through circular validation. Critical design choices include dynamic operation selection (40% segment, 30% edge, 30% hybrid) and aggressive improvement acceptance criteria that prioritize simultaneous or significant unilateral objective improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Enhanced selection based on normalized objective diversity and solution quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.sum(normalized, axis=1)\n    quality = 1 / (1 + np.sum(objectives, axis=1))\n    combined_score = 0.7 * diversity + 0.3 * quality\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment selection mechanism\n    segment_size = max(3, int(np.ceil(n * 0.15 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Dynamic operation selection with adaptive probabilities\n    operation_type = np.random.choice(['segment', 'edge', 'hybrid'], p=[0.4, 0.3, 0.3])\n\n    if operation_type == 'segment':\n        # Adaptive segment reversal with position-based probability\n        segment = new_solution[start:end]\n        new_pos = np.random.randint(0, n - segment_size + 1)\n        if np.random.rand() < 0.6:  # Higher probability for reversal\n            segment = segment[::-1]\n        if new_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n\n    elif operation_type == 'edge':\n        # Probabilistic edge swap with objective-aware selection\n        for _ in range(3):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            # More aggressive improvement acceptance\n            if (delta1 < 0 and delta2 < 0) or (delta1 <= 0 and delta2 < -0.2 * abs(delta2)) or (delta2 <= 0 and delta1 < -0.2 * abs(delta1)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    else:  # hybrid operation\n        # Combined segment and edge operation\n        segment = new_solution[start:end]\n        segment = segment[::-1] if np.random.rand() < 0.5 else segment\n        new_pos = np.random.randint(0, n - segment_size + 1)\n        if new_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n\n        # Additional edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if (delta1 < 0 and delta2 < 0) or (delta1 <= 0 and delta2 < -0.15 * abs(delta2)) or (delta2 <= 0 and delta1 < -0.15 * abs(delta1)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9940962108637836,
            0.8415762186050415
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of objectives (60% for the first objective, 40% for the second), then applies a hybrid local search combining edge swaps (70% chance) with segment reversals (30% chance) to explore diverse neighborhoods while ensuring feasibility. It also includes an occasional random edge flip (30% chance) for additional diversity, and guarantees a circular tour by appending the start node if needed. The method prioritizes the first objective in selection but balances exploration of both objectives in perturbation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    if random.random() < 0.7:  # 70% chance for edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation for diversity\n    if random.random() < 0.3:  # 30% chance for random edge flip\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.8907118218798389,
            0.2272680401802063
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on Pareto dominance and diversity, then applies a hybrid local search combining edge insertion and probabilistic relocation, dynamically adjusting the search range based on the solution's dominance score while ensuring feasibility through circularity checks. It prioritizes solutions on the Pareto front with high diversity, and the local search operator probabilistically balances exploration and exploitation by dynamically adjusting the relocation range. The method ensures feasibility by maintaining circular tours and avoids standard 2-opt by incorporating probabilistic node relocation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Select from Pareto front with diversity\n        pareto_objectives = objectives[pareto_front]\n        diversity_scores = np.sum((pareto_objectives - np.mean(pareto_objectives, axis=0)) ** 2, axis=1)\n        selected_idx = pareto_front[np.argmax(diversity_scores)]\n    else:\n        # Select from all solutions with diversity\n        diversity_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate Pareto dominance score\n    dominated_count = 0\n    for other_obj in objectives:\n        if (other_obj[0] <= objectives[selected_idx][0] and other_obj[1] <= objectives[selected_idx][1]) and (other_obj[0] < objectives[selected_idx][0] or other_obj[1] < objectives[selected_idx][1]):\n            dominated_count += 1\n    dominance_score = dominated_count / len(objectives)\n\n    # Determine relocation range based on dominance score\n    reloc_range = max(2, min(n // 3, int(np.ceil(n * 0.2 * (1 + dominance_score * np.random.rand())))))\n    pos = np.random.randint(0, n)\n    start = max(0, pos - reloc_range)\n    end = min(n, pos + reloc_range)\n\n    # Hybrid operator: edge insertion + probabilistic relocation\n    if np.random.rand() < 0.7:\n        # Edge insertion\n        i, j = np.random.randint(start, end, size=2)\n        if i != j:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i+1:j], new_solution[i:i+1], new_solution[j+1:]])\n    else:\n        # Probabilistic relocation\n        i = np.random.randint(start, end)\n        j = np.random.randint(0, n)\n        if i != j:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], new_solution[i:i+1], new_solution[j:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -1.004521427124855,
            2.7379573583602905
        ]
    },
    {
        "algorithm": "The algorithm combines nondominated solution selection with a hybrid local search that dynamically alternates between segment-based operations (reversal/rotation) and edge-based swaps, prioritizing objective diversity and adaptive segment sizes while ensuring feasibility through probabilistic operation selection and circular tour maintenance. It balances exploration (via segment operations) and exploitation (via edge swaps) with a focus on improving both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in nondominated])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment size and operation selection\n    segment_size = max(2, int(np.ceil(n * 0.15 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Dynamic operation selection based on objective improvement potential\n    if np.random.rand() < 0.6:\n        # Segment-based operation\n        if np.random.rand() < 0.5:\n            # Dynamic segment reversal\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Dynamic segment rotation\n            segment = new_solution[start:end]\n            rotated = np.roll(segment, np.random.randint(1, segment_size))\n            new_solution[start:end] = rotated\n    else:\n        # Edge-based operation\n        for _ in range(3):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= 0.9 * old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= 0.9 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9706242552447388,
            1.0275250673294067
        ]
    },
    {
        "algorithm": "This algorithm selects extreme solutions from the archive (prioritizing those with highest combined objective values) and applies a hybrid local search combining dynamic segment rotations and node swaps, focusing on balanced improvements in both objectives while ensuring tour validity through circularity checks. The method uses probabilistic segment rotation and selective node swaps based on objective improvements, with a bias toward solutions that show potential for further optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with extreme objective values\n    objectives = np.array([obj for _, obj in archive])\n    extreme_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[extreme_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    segment_size = max(3, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    if np.random.rand() < 0.7:\n        # Rotate segment\n        segment = new_solution[start:end]\n        rotated = np.roll(segment, np.random.randint(1, segment_size))\n        new_solution[start:end] = rotated\n    else:\n        # Swap nodes with probability based on objective improvement\n        for _ in range(5):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= 0.95 * old_cost1 and new_cost2 <= 0.95 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9648589443513792,
            0.49024927616119385
        ]
    }
]