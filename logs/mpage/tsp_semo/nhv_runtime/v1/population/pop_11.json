[
     {
          "algorithm": "{The new algorithm will first identify solutions in the archive that show potential for improvement by analyzing both their objective values and the diversity of their node sequences, then apply a novel 'multi-dimensional cluster inversion' strategy that randomly groups nodes into clusters based on their geometric proximity in both coordinate spaces, inverts each cluster's sequence while maintaining spatial coherence, and optimally reassigns edges between clusters by considering both distance matrices, all while ensuring feasibility by verifying that the resulting tour remains a valid permutation of all nodes and maintaining the circular nature of the tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement score considering both objectives and diversity\n        obj_score = (obj[0] + obj[1]) / 2\n        diversity_score = len(set(sol)) / len(sol)\n        improvement_score = obj_score * diversity_score\n        candidates.append((sol, improvement_score))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected = candidates[0][0].copy()\n\n    # Step 2: Apply multi-dimensional cluster inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Create clusters based on geometric proximity in both spaces\n    clusters = []\n    remaining = list(range(n))\n    while len(remaining) > 0:\n        # Randomly select a seed node\n        seed = random.choice(remaining)\n        cluster = [seed]\n        remaining.remove(seed)\n\n        # Find nearby nodes in both spaces\n        for node in remaining[:]:\n            x1_seed, y1_seed, x2_seed, y2_seed = instance[selected[seed]]\n            x1_node, y1_node, x2_node, y2_node = instance[selected[node]]\n\n            # Calculate distances in both spaces\n            dist1 = np.sqrt((x1_seed - x1_node)**2 + (y1_seed - y1_node)**2)\n            dist2 = np.sqrt((x2_seed - x2_node)**2 + (y2_seed - y2_node)**2)\n\n            # Add to cluster if close in both spaces\n            if dist1 < np.mean(distance_matrix_1) * 0.5 and dist2 < np.mean(distance_matrix_2) * 0.5:\n                cluster.append(node)\n                remaining.remove(node)\n\n        if len(cluster) > 1:\n            clusters.append(cluster)\n\n    # Invert each cluster while maintaining spatial coherence\n    for cluster in clusters:\n        # Find the cluster's centroid in both spaces\n        centroid1_x = np.mean([instance[selected[node]][0] for node in cluster])\n        centroid1_y = np.mean([instance[selected[node]][1] for node in cluster])\n        centroid2_x = np.mean([instance[selected[node]][2] for node in cluster])\n        centroid2_y = np.mean([instance[selected[node]][3] for node in cluster])\n\n        # Sort nodes in the cluster by angle relative to centroid in both spaces\n        def angle_sort_key(node):\n            x1, y1, x2, y2 = instance[selected[node]]\n            angle1 = np.arctan2(y1 - centroid1_y, x1 - centroid1_x)\n            angle2 = np.arctan2(y2 - centroid2_y, x2 - centroid2_x)\n            return (angle1 + angle2) / 2\n\n        cluster_sorted = sorted(cluster, key=angle_sort_key)\n        new_solution[cluster] = [selected[node] for node in cluster_sorted[::-1]]\n\n    # Step 3: Optimally reassign edges between clusters\n    for i in range(len(clusters)-1):\n        cluster1 = clusters[i]\n        cluster2 = clusters[i+1]\n\n        # Find best edge to connect clusters\n        best_improvement = 0\n        best_edge = None\n\n        for a in cluster1:\n            for b in cluster2:\n                # Current edges\n                prev_a = selected[a-1] if a > 0 else selected[-1]\n                next_a = selected[(a+1)%n]\n                prev_b = selected[b-1] if b > 0 else selected[-1]\n                next_b = selected[(b+1)%n]\n\n                # Current costs\n                current_cost1 = (distance_matrix_1[prev_a, selected[a]] +\n                                distance_matrix_1[selected[a], next_a] +\n                                distance_matrix_1[prev_b, selected[b]] +\n                                distance_matrix_1[selected[b], next_b])\n                current_cost2 = (distance_matrix_2[prev_a, selected[a]] +\n                                distance_matrix_2[selected[a], next_a] +\n                                distance_matrix_2[prev_b, selected[b]] +\n                                distance_matrix_2[selected[b], next_b])\n\n                # New costs if we connect a to b\n                new_cost1 = (distance_matrix_1[prev_a, selected[a]] +\n                            distance_matrix_1[selected[a], selected[b]] +\n                            distance_matrix_1[selected[b], next_a] +\n                            distance_matrix_1[prev_b, selected[b]] +\n                            distance_matrix_1[selected[b], next_b])\n                new_cost2 = (distance_matrix_2[prev_a, selected[a]] +\n                            distance_matrix_2[selected[a], selected[b]] +\n                            distance_matrix_2[selected[b], next_a] +\n                            distance_matrix_2[prev_b, selected[b]] +\n                            distance_matrix_2[selected[b], next_b])\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (a, b)\n\n        # Apply the best edge connection\n        if best_edge:\n            a, b = best_edge\n            a_pos = np.where(new_solution == selected[a])[0][0]\n            b_pos = np.where(new_solution == selected[b])[0][0]\n\n            if a_pos > b_pos:\n                a_pos, b_pos = b_pos, a_pos\n\n            new_solution[a_pos+1:b_pos] = new_solution[a_pos+1:b_pos][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.036349290086442,
               2.395252764225006
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 2, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment rotation\n    if end < n:\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, perform a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9636209173816817,
               0.14570850133895874
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel multi-objective adaptive segment exchange mechanism that combines a probabilistic segment selection strategy with an objective-aware segment relocation operator. It first identifies solutions with high potential by analyzing their objective-space coverage and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively exchanges entire segments between the current solution and a reference solution, where the segment selection probability and relocation depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the segment relocation mechanism explores different solution structures by probabilistically relocating segments to positions that improve both objectives. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while maintaining a focus on segment-based operations that can efficiently explore the solution space in the bi-objective context.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of coverage and dominance)\n    coverage_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.5 * coverage_scores + 0.5 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply adaptive segment exchange with objective-aware relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment selection with probability based on objective improvements\n    segment_length = max(2, min(n // 5, np.random.randint(2, n // 3)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Objective-aware segment relocation\n    if len(archive) > 1:\n        # Select a reference solution\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n\n        # Calculate potential improvement for the segment\n        current_segment = base_solution[start:end]\n        ref_segment = ref_solution[start:end]\n\n        # Calculate cost difference\n        current_cost1 = sum(distance_matrix_1[current_segment[i], current_segment[i+1]] for i in range(len(current_segment)-1))\n        current_cost1 += distance_matrix_1[current_segment[-1], current_segment[0]]\n        ref_cost1 = sum(distance_matrix_1[ref_segment[i], ref_segment[i+1]] for i in range(len(ref_segment)-1))\n        ref_cost1 += distance_matrix_1[ref_segment[-1], ref_segment[0]]\n\n        current_cost2 = sum(distance_matrix_2[current_segment[i], current_segment[i+1]] for i in range(len(current_segment)-1))\n        current_cost2 += distance_matrix_2[current_segment[-1], current_segment[0]]\n        ref_cost2 = sum(distance_matrix_2[ref_segment[i], ref_segment[i+1]] for i in range(len(ref_segment)-1))\n        ref_cost2 += distance_matrix_2[ref_segment[-1], ref_segment[0]]\n\n        # Decide whether to exchange based on objective improvement\n        if (ref_cost1 < current_cost1 and ref_cost2 < current_cost2):\n            new_solution[start:end] = ref_segment.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0345572131886867,
               0.27952826023101807
          ]
     },
     {
          "algorithm": "{The new algorithm will first identify the solution in the archive with the highest combined objective value, then apply a novel \"objective-balancing segment inversion\" operator that partitions the tour into segments based on the ratio of objective values along the tour, inverts segments where the ratio of objectives deviates significantly from the global average ratio, and carefully reinserts these inverted segments at positions that maximize the potential for objective balance, while ensuring all nodes are visited exactly once and maintaining tour validity through comprehensive feasibility checks at each step.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate global objective ratio\n    global_ratio = archive[selected_idx][1][0] / archive[selected_idx][1][1] if archive[selected_idx][1][1] != 0 else float('inf')\n\n    # Calculate segment objective ratios\n    segment_length = max(2, n // 5)\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = new_solution[i:i+segment_length]\n        segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        segment_ratio = segment_cost1 / segment_cost2 if segment_cost2 != 0 else float('inf')\n        segments.append((i, segment, segment_ratio))\n\n    # Identify segments to invert\n    segments_to_invert = [seg for seg in segments if abs(seg[2] - global_ratio) > 0.3 * global_ratio]\n\n    if not segments_to_invert:\n        # If no segments to invert, perform a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select a segment to invert\n    seg_idx = np.random.choice(len(segments_to_invert))\n    start_pos, segment, _ = segments_to_invert[seg_idx]\n    inverted_segment = segment[::-1]\n\n    # Find optimal insertion position\n    best_pos = -1\n    min_ratio_diff = float('inf')\n\n    for pos in range(0, n, segment_length):\n        if pos == start_pos:\n            continue\n\n        # Temporarily insert the inverted segment\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            inverted_segment,\n            new_solution[pos+len(segment):]\n        ])\n\n        # Calculate new ratio\n        temp_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        temp_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        temp_ratio = temp_cost1 / temp_cost2 if temp_cost2 != 0 else float('inf')\n\n        ratio_diff = abs(temp_ratio - global_ratio)\n        if ratio_diff < min_ratio_diff:\n            min_ratio_diff = ratio_diff\n            best_pos = pos\n\n    if best_pos != -1:\n        # Perform the inversion at the best position\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            inverted_segment,\n            new_solution[best_pos+len(segment):]\n        ])\n\n    # Ensure all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9541874004240105,
               0.1874428391456604
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive clustering with a dynamic segment inversion mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a cluster-based perturbation with a segment inversion-inspired move, where the cluster size and inversion depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the segment inversion mechanism explores intermediate solutions by flipping segments of the tour to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while also incorporating spatial information from the instance to guide the local search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.5 * diversity_scores + 0.5 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive clustering with dynamic segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive cluster-based perturbation\n    cluster_size = max(2, min(n // 4, np.random.randint(2, n // 3)))\n    num_clusters = max(2, n // cluster_size)\n\n    # Create clusters by grouping consecutive nodes\n    clusters = []\n    for i in range(num_clusters):\n        start = i * cluster_size\n        end = min((i + 1) * cluster_size, n)\n        clusters.append(new_solution[start:end])\n\n    # Dynamic segment inversion: invert clusters based on spatial proximity\n    if len(clusters) > 1:\n        for i in range(len(clusters)):\n            if np.random.random() < 0.3:  # 30% chance to invert a cluster\n                clusters[i] = clusters[i][::-1]\n\n    # Reconstruct the solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0289927276199635,
               0.35933321714401245
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion\n    if end < n:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.002562955635491,
               0.30344176292419434
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    n = len(new_solution)\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion and rotation\n    if np.random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9650079795455078,
               0.296312153339386
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    tradeoff_scores = np.abs(normalized_objectives[:, 0] - normalized_objectives[:, 1])\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid adaptive perturbation with dynamic path relinking\n    n = len(new_solution)\n    segment_length = max(2, min(n // 3, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.2, 0.6)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion and rotation\n    if np.random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, perform a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.6874219148715597,
               0.1907387375831604
          ]
     },
     {
          "algorithm": "{The new algorithm will first select a solution from the archive based on its diversity in the objective space (prioritizing solutions that are less similar to others), then apply a novel \"objective-balanced segment exchange\" operator that identifies segments of the tour where the objectives show significant imbalance, exchanges these segments with other segments from different parts of the tour, and reorders them in a way that balances the objectives while ensuring all nodes remain visited exactly once. The algorithm will use a novel selection criterion that considers both the solution's objective values and their distribution in the archive to identify solutions that may benefit from more exploration, and will employ a segment exchange mechanism that intelligently redistributes the tour's segments based on the identified imbalances between objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most unique objective combination\n    obj_values = np.array([obj for _, obj in archive])\n    obj_ranges = np.max(obj_values, axis=0) - np.min(obj_values, axis=0)\n    if np.any(obj_ranges == 0):\n        # If all objectives are identical, select randomly\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        # Normalize objectives\n        normalized = (obj_values - np.min(obj_values, axis=0)) / obj_ranges\n        # Calculate diversity score (sum of normalized distances to all other solutions)\n        diversity_scores = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            diversity_scores[i] = np.sum(distances)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-balanced segment exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Calculate objective imbalance for each segment\n        segment_length = max(2, n // 3)\n        imbalance_scores = []\n        for i in range(0, n - segment_length + 1, segment_length // 2):\n            segment = new_solution[i:i+segment_length]\n            # Calculate segment costs\n            cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            imbalance = abs(cost1 - cost2) / (cost1 + cost2 + 1e-10)\n            imbalance_scores.append((imbalance, i))\n\n        # Sort segments by imbalance (most imbalanced first)\n        imbalance_scores.sort(reverse=True, key=lambda x: x[0])\n        if not imbalance_scores:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Select the most imbalanced segment\n            _, i = imbalance_scores[0]\n            segment = new_solution[i:i+segment_length]\n\n            # Find another segment to exchange with\n            j = random.randint(0, n - segment_length)\n            while abs(j - i) < segment_length:\n                j = random.randint(0, n - segment_length)\n\n            # Exchange the segments\n            other_segment = new_solution[j:j+segment_length]\n            new_solution[i:i+segment_length] = other_segment\n            new_solution[j:j+segment_length] = segment\n\n            # Reorder the exchanged segments to balance objectives\n            if random.random() > 0.5:\n                new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Ensure all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple valid move\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9652069961525331,
               1.7772496342658997
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-phase approach that first identifies the most balanced solution from the archive by evaluating the trade-off between the two objectives, then applies a novel hybrid local search operator that combines a dynamic node clustering mechanism with a probabilistic edge exchange strategy. This operator first partitions the solution into spatially coherent clusters based on both objective spaces, then probabilistically exchanges edges between clusters while maintaining feasibility, with the exchange probability and cluster size dynamically adjusted based on the solution's objective balance and the instance's spatial characteristics. The algorithm ensures feasibility by always maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the probabilistic edge exchange mechanism explores intermediate solutions by creating diverse connections between clusters to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while also incorporating spatial information from the instance to guide the local search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution (minimize the difference between objectives)\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply dynamic node clustering and probabilistic edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine cluster size based on instance size and objective balance\n        obj1, obj2 = archive[selected_idx][1]\n        balance_factor = 1 - np.abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n        cluster_size = max(2, min(n // 4, int(balance_factor * (n // 2))))\n\n        # Cluster nodes based on spatial proximity in both objective spaces\n        clusters = []\n        remaining_nodes = set(range(n))\n        while remaining_nodes:\n            current_node = remaining_nodes.pop()\n            cluster = [current_node]\n            # Expand cluster until reaching desired size\n            while len(cluster) < cluster_size and remaining_nodes:\n                # Find the nearest neighbor in both objective spaces\n                nearest = None\n                min_dist = float('inf')\n                for node in remaining_nodes:\n                    dist1 = distance_matrix_1[cluster[-1], node]\n                    dist2 = distance_matrix_2[cluster[-1], node]\n                    total_dist = 0.5 * dist1 + 0.5 * dist2\n                    if total_dist < min_dist:\n                        min_dist = total_dist\n                        nearest = node\n                if nearest is not None:\n                    cluster.append(nearest)\n                    remaining_nodes.remove(nearest)\n            clusters.append(cluster)\n\n        # Probabilistic edge exchange between clusters\n        for i in range(len(clusters)):\n            for j in range(i + 1, len(clusters)):\n                # Probability of exchange based on cluster size and objective balance\n                exchange_prob = 0.3 + 0.4 * balance_factor\n                if np.random.random() < exchange_prob:\n                    # Select random nodes from each cluster\n                    node_i = np.random.choice(clusters[i])\n                    node_j = np.random.choice(clusters[j])\n\n                    # Find positions in solution\n                    pos_i = np.where(new_solution == node_i)[0][0]\n                    pos_j = np.where(new_solution == node_j)[0][0]\n\n                    # Swap nodes if they are not adjacent\n                    if abs(pos_i - pos_j) > 1:\n                        new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, perform a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9576955080307292,
               0.38503754138946533
          ]
     }
]