[
     {
          "algorithm": "{The new algorithm employs a multi-phase approach that combines probabilistic node selection, geometric transformation-based local search, and adaptive objective-weighted edge swapping to generate high-quality neighbors. It first identifies critical nodes based on their geometric properties and objective contributions, then applies a series of geometric transformations (scaling, rotation, and translation) to the solution's node coordinates in both objective spaces, followed by a targeted edge swapping phase that prioritizes edges with high potential for improving both objectives, with the swap probability dynamically adjusted based on the current solution's structure and the relative weights of the two objectives. The algorithm ensures feasibility by maintaining the permutation property and using a validation step to confirm the generated solution remains a valid TSP tour before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with probability based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n    probs = np.sum(diversity, axis=1)\n    probs = probs / np.sum(probs) if np.sum(probs) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Geometric transformation phase\n    coords1 = instance[base_solution, :2]  # First objective coordinates\n    coords2 = instance[base_solution, 2:]  # Second objective coordinates\n\n    # Calculate centroids\n    centroid1 = np.mean(coords1, axis=0)\n    centroid2 = np.mean(coords2, axis=0)\n\n    # Apply random geometric transformations\n    if np.random.random() < 0.5:\n        # Scale transformation\n        scale_factor = np.random.uniform(0.9, 1.1)\n        coords1 = centroid1 + (coords1 - centroid1) * scale_factor\n        coords2 = centroid2 + (coords2 - centroid2) * scale_factor\n    else:\n        # Rotation transformation\n        angle = np.random.uniform(-np.pi/6, np.pi/6)\n        rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)],\n                                   [np.sin(angle), np.cos(angle)]])\n        coords1 = centroid1 + (coords1 - centroid1) @ rotation_matrix\n        coords2 = centroid2 + (coords2 - centroid2) @ rotation_matrix\n\n    # Find nearest nodes in transformed spaces\n    transformed_instance1 = np.hstack([coords1, instance[:, 2:]])\n    transformed_instance2 = np.hstack([instance[:, :2], coords2])\n\n    # Create distance matrices for transformed spaces\n    def create_distance_matrix(coords):\n        n = len(coords)\n        dist_matrix = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                dist_matrix[i, j] = np.linalg.norm(coords[i] - coords[j])\n        return dist_matrix\n\n    transformed_dist1 = create_distance_matrix(transformed_instance1[base_solution, :2])\n    transformed_dist2 = create_distance_matrix(transformed_instance2[base_solution, 2:])\n\n    # Adaptive edge swapping phase\n    for _ in range(min(5, n // 2)):\n        # Calculate edge weights in both original and transformed spaces\n        edge_weights = []\n        for i in range(n):\n            j = (i + 1) % n\n            original_cost = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[j]]\n            transformed_cost = transformed_dist1[i, j] + transformed_dist2[i, j]\n            edge_weights.append(original_cost + transformed_cost)\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n\n        # Select edges to swap with probability based on weights\n        if np.random.random() < 0.7:  # 70% chance for weighted selection\n            i = np.random.choice(n, p=edge_weights)\n        else:\n            i = np.random.randint(0, n)\n        j = (i + 1) % n\n\n        # Find best swap candidate\n        best_cost = float('inf')\n        best_k = -1\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidate = np.roll(candidate, -i)\n            candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n            candidate = np.roll(candidate, i)\n\n            # Check validity\n            if len(set(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_k = k\n\n        if best_k != -1:\n            # Apply the best swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution = np.roll(new_solution, -i)\n            new_solution = np.concatenate([new_solution[:1], new_solution[2:best_k+1], new_solution[1:2], new_solution[best_k+1:]])\n            new_solution = np.roll(new_solution, i)\n\n    return new_solution\n\n",
          "score": [
               6.96520938589318,
               5.376564571653562
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach that combines hierarchical clustering of nodes based on their multi-objective distances with a guided segment inversion strategy, followed by a probabilistic edge reversal process that dynamically adjusts its intensity based on the current solution's objective trade-off characteristics, and concludes with a constrained node reinsertion phase that prioritizes positions with complementary improvement potential across both objectives, while maintaining feasibility through a permutation-aware validation mechanism.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n    base_solution = archive[np.argmin(scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hierarchical clustering of nodes\n    from scipy.cluster.hierarchy import linkage, fcluster\n\n    # Calculate multi-objective distances\n    multi_dist = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            multi_dist[i, j] = (distance_matrix_1[i, j] + distance_matrix_2[i, j]) / 2\n\n    # Perform hierarchical clustering\n    Z = linkage(multi_dist, 'ward')\n    clusters = fcluster(Z, t=2, criterion='maxclust')\n\n    # Guided segment inversion based on clusters\n    for _ in range(2):\n        # Select a random cluster\n        cluster_id = np.random.choice(np.unique(clusters))\n        cluster_indices = np.where(clusters == cluster_id)[0]\n\n        if len(cluster_indices) < 3:\n            continue\n\n        # Select a segment within the cluster\n        start = np.random.choice(cluster_indices[:-1])\n        end = np.random.choice(cluster_indices[cluster_indices > start])\n\n        # Calculate current cost\n        current_cost = 0\n        for i in range(start, end):\n            current_cost += distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n        current_cost += distance_matrix_1[new_solution[end], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[start]]\n\n        # Invert the segment\n        candidate = new_solution.copy()\n        candidate[start:end+1] = candidate[start:end+1][::-1]\n\n        # Calculate new cost\n        new_cost = 0\n        for i in range(start, end):\n            new_cost += distance_matrix_1[candidate[i], candidate[i+1]] + distance_matrix_2[candidate[i], candidate[i+1]]\n        new_cost += distance_matrix_1[candidate[end], candidate[start]] + distance_matrix_2[candidate[end], candidate[start]]\n\n        if new_cost < current_cost:\n            new_solution = candidate\n\n    # Probabilistic edge reversal with dynamic intensity\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate objective trade-off\n        obj1_ratio = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) / \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]])\n        obj2_ratio = (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]) / \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]])\n\n        # Dynamic reversal probability\n        reversal_prob = min(0.8, 0.2 + 0.6 * (1 - abs(obj1_ratio - obj2_ratio)))\n\n        if np.random.random() < reversal_prob:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Constrained node reinsertion with objective-aware position selection\n    for _ in range(2):\n        # Select a random node\n        idx = np.random.randint(1, n-1)\n        node = new_solution[idx]\n\n        # Remove the node\n        candidate = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n        # Find best insertion position\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n-1):\n            if pos == idx or pos == idx-1:\n                continue\n\n            # Insert node at position pos\n            temp = np.insert(candidate, pos, node)\n\n            # Calculate objective scores\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n            # Normalize scores\n            norm_cost1 = (cost1 - distance_matrix_1.min()) / (distance_matrix_1.max() - distance_matrix_1.min() + 1e-8)\n            norm_cost2 = (cost2 - distance_matrix_2.min()) / (distance_matrix_2.max() - distance_matrix_2.min() + 1e-8)\n\n            # Combined score with trade-off consideration\n            score = norm_cost1 + norm_cost2 + 0.3 * abs(norm_cost1 - norm_cost2)\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.915367991787147,
               5.848319274999013
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive k-means clustering with multi-objective aware node merging and splitting. It first partitions the solution into adaptive clusters using k-means based on the combined spatial proximity in both objective spaces, then selectively merges and splits nodes between clusters to balance the trade-off between the two objectives, followed by a guided node rotation process that prioritizes nodes with complementary improvement potential in both objectives, while dynamically adjusting the rotation angle based on the current solution's structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from sklearn.cluster import KMeans\n\n    k = min(3, max(2, n // 5))\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.hstack((coords1, coords2))\n\n    kmeans = KMeans(n_clusters=k, random_state=42).fit(combined_coords)\n    clusters = kmeans.labels_\n\n    for _ in range(min(3, k)):\n        if k < 2:\n            break\n\n        i, j = np.random.choice(k, size=2, replace=False)\n        cluster_i = np.where(clusters == i)[0]\n        cluster_j = np.where(clusters == j)[0]\n\n        if len(cluster_i) < 2 or len(cluster_j) < 2:\n            continue\n\n        node_i = np.random.choice(cluster_i)\n        node_j = np.random.choice(cluster_j)\n\n        candidate = new_solution.copy()\n        candidate[node_i], candidate[node_j] = candidate[node_j], candidate[node_i]\n\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if cost1 + cost2 < current_cost1 + current_cost2:\n            new_solution = candidate.copy()\n\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            rotation_angle = max(1, min(5, int(3 * improvement_ratio)))\n\n            for k in range(max(0, j-rotation_angle), min(len(temp), j+rotation_angle+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                 distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                 distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.949505505101238,
               5.827122755688995
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive tour partitioning with multi-objective aware node swapping and insertion, which first segments the solution into dynamic partitions based on the combined spatial proximity and edge strength in both objective spaces, then selectively swaps nodes between partitions while considering their potential to improve both objectives, followed by a guided node insertion phase that prioritizes nodes with complementary improvement potential in both objectives, while dynamically adjusting the insertion depth based on the current solution's structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive tour partitioning\n    from scipy.spatial.distance import pdist, squareform\n\n    # Calculate combined spatial proximity and edge strength\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    # Calculate edge strength in both objectives\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    # Find partitions based on combined metrics\n    partition_size = max(3, min(7, n // 4))\n    partitions = []\n    for i in range(0, n, partition_size):\n        partition = base_solution[i:i+partition_size]\n        if len(partition) < 2:\n            continue\n\n        # Calculate partition strength\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(partition)-1) for j in range(i+1, len(partition)))\n        partitions.append((i, i+partition_size, strength))\n\n    # Sort partitions by strength (descending)\n    partitions.sort(key=lambda x: -x[2])\n\n    # Node swapping between partitions\n    for _ in range(min(3, len(partitions))):\n        if len(partitions) < 2:\n            break\n\n        # Select two partitions with high strength\n        part1_idx, part1_end, _ = partitions[0]\n        part2_idx, part2_end, _ = partitions[1]\n\n        # Select nodes from each partition\n        node1_idx = np.random.randint(part1_idx, part1_end)\n        node2_idx = np.random.randint(part2_idx, part2_end)\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[new_solution[node1_idx-1], new_solution[node1_idx]] +\n                    distance_matrix_1[new_solution[node1_idx], new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], new_solution[node2_idx]] +\n                    distance_matrix_1[new_solution[node2_idx], new_solution[(node2_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node1_idx-1], new_solution[node1_idx]] +\n                    distance_matrix_2[new_solution[node1_idx], new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], new_solution[node2_idx]] +\n                    distance_matrix_2[new_solution[node2_idx], new_solution[(node2_idx+1)%n]])\n\n        # Try swapping the nodes\n        candidate = new_solution.copy()\n        candidate[node1_idx], candidate[node2_idx] = candidate[node2_idx], candidate[node1_idx]\n\n        new_cost = (distance_matrix_1[candidate[node1_idx-1], candidate[node1_idx]] +\n                   distance_matrix_1[candidate[node1_idx], candidate[(node1_idx+1)%n]] +\n                   distance_matrix_1[candidate[node2_idx-1], candidate[node2_idx]] +\n                   distance_matrix_1[candidate[node2_idx], candidate[(node2_idx+1)%n]] +\n                   distance_matrix_2[candidate[node1_idx-1], candidate[node1_idx]] +\n                   distance_matrix_2[candidate[node1_idx], candidate[(node1_idx+1)%n]] +\n                   distance_matrix_2[candidate[node2_idx-1], candidate[node2_idx]] +\n                   distance_matrix_2[candidate[node2_idx], candidate[(node2_idx+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    # Guided node insertion\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Remove the node\n        candidate = np.delete(new_solution, i)\n\n        # Find the best position to reinsert the node\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            # Dynamic insertion depth based on improvement potential\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            # Consider positions within the depth range\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                 distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                 distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.2797825324000405,
               5.688239290006862
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive objective-space clustering with multi-dimensional node relocation and insertion, which first groups nodes based on their simultaneous proximity in both objective spaces while considering the current solution's edge strengths, then performs a multi-dimensional relocation process that simultaneously considers both objective spaces to identify and move nodes to positions that promise improvement in both objectives, followed by a guided insertion phase that prioritizes nodes with complementary improvement potential in both objectives while dynamically adjusting the search depth based on the current solution's structure and the relative improvement potential in both objectives, ensuring feasibility by maintaining the permutation property of TSP tours throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    cluster_size = max(3, min(7, n // 3))\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = base_solution[i:i+cluster_size]\n        if len(cluster) < 2:\n            continue\n\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(cluster)-1) for j in range(i+1, len(cluster)))\n        clusters.append((i, i+cluster_size, strength))\n\n    clusters.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(clusters))):\n        if len(clusters) < 2:\n            break\n\n        cluster1_idx, cluster1_end, _ = clusters[0]\n        cluster2_idx, cluster2_end, _ = clusters[1]\n\n        node1_idx = np.random.randint(cluster1_idx, cluster1_end)\n        node2_idx = np.random.randint(cluster2_idx, cluster2_end)\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node2] +\n                    distance_matrix_1[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], node1] +\n                    distance_matrix_1[node1, new_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node2] +\n                    distance_matrix_2[node2, new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], node1] +\n                    distance_matrix_2[node1, new_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[node1_idx], new_solution[node2_idx] = new_solution[node2_idx], new_solution[node1_idx]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        current_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        candidate = np.delete(new_solution, i)\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                  distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                  distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.4018692757360744,
               5.598325826726927
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive spatial partitioning with multi-objective aware tour inversion, which first partitions the solution into dynamic regions based on the combined spatial proximity and edge strength in both objective spaces, then selectively inverts entire segments of the tour while considering their potential to improve both objectives, followed by a targeted node reinsertion phase that prioritizes nodes from different regions with complementary improvement potential in both objectives, while dynamically adjusting the inversion length and reinsertion positions based on the current solution's regional structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n\n    region_size = max(3, min(5, n // 3))\n    regions = []\n    for i in range(0, n, region_size):\n        region = base_solution[i:i+region_size]\n        if len(region) < 2:\n            continue\n\n        strength1 = sum(distance_matrix_1[region[j], region[j+1]] for j in range(len(region)-1))\n        strength2 = sum(distance_matrix_2[region[j], region[j+1]] for j in range(len(region)-1))\n        regions.append((i, i+region_size, strength1 + strength2))\n\n    regions.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(regions))):\n        if len(regions) < 1:\n            break\n\n        region_idx = np.random.randint(0, len(regions))\n        region_start, region_end, _ = regions[region_idx]\n\n        if region_end - region_start < 2:\n            continue\n\n        old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(region_start-1, region_end-1))\n        old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(region_start-1, region_end-1))\n\n        inverted = np.flip(new_solution[region_start:region_end])\n        candidate = new_solution.copy()\n        candidate[region_start:region_end] = inverted\n\n        new_cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(region_start-1, region_end-1))\n        new_cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(region_start-1, region_end-1))\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution = candidate.copy()\n\n    for _ in range(min(5, n//2)):\n        region_idx = np.random.randint(0, len(regions))\n        region_start, region_end, _ = regions[region_idx]\n        region_nodes = new_solution[region_start:region_end]\n\n        if len(region_nodes) < 2:\n            continue\n\n        node_idx = np.random.randint(region_start, region_end)\n        node = new_solution[node_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node_idx-1], node] +\n                    distance_matrix_1[node, new_solution[(node_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node_idx-1], node] +\n                    distance_matrix_2[node, new_solution[(node_idx+1)%n]])\n\n        candidate_positions = []\n        for i in range(n):\n            if i >= region_start and i < region_end:\n                continue\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[i%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[i%n]])\n\n            candidate_positions.append((i, new_cost1 + new_cost2))\n\n        if not candidate_positions:\n            continue\n\n        candidate_positions.sort(key=lambda x: x[1])\n        best_pos, best_cost = candidate_positions[0]\n\n        if best_cost < old_cost1 + old_cost2 or np.random.random() < min(0.5, 0.1 + (old_cost1 + old_cost2 - best_cost) / (old_cost1 + old_cost2)):\n            candidate = np.delete(new_solution, node_idx)\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.732722238437686,
               6.325396665491157
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive segment fusion with multi-objective aware node reallocation, which first partitions the solution into dynamic segments based on the combined spatial coherence and edge strength in both objective spaces, then selectively fuses adjacent segments while considering their potential to improve both objectives, followed by a targeted node reallocation phase that prioritizes nodes from different segments with complementary improvement potential in both objectives, while dynamically adjusting the fusion depth and reallocation positions based on the current solution's segment structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n\n    segment_length = max(3, min(5, n // 5))\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = base_solution[i:i+segment_length]\n        if len(segment) < 2:\n            continue\n\n        strength1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        strength2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        segments.append((i, i+segment_length, strength1 + strength2))\n\n    segments.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        segment1_idx, segment1_end, _ = segments[0]\n        segment2_idx, segment2_end, _ = segments[1]\n\n        if abs(segment1_end - segment2_idx) > 1:\n            continue\n\n        segment1_nodes = base_solution[segment1_idx:segment1_end]\n        segment2_nodes = base_solution[segment2_idx:segment2_end]\n\n        if len(segment1_nodes) < 1 or len(segment2_nodes) < 1:\n            continue\n\n        old_cost1 = (distance_matrix_1[new_solution[segment1_idx-1], segment1_nodes[0]] +\n                    distance_matrix_1[segment2_nodes[-1], new_solution[segment2_end%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[segment1_idx-1], segment1_nodes[0]] +\n                    distance_matrix_2[segment2_nodes[-1], new_solution[segment2_end%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[segment1_idx-1], segment2_nodes[-1]] +\n                    distance_matrix_1[segment1_nodes[0], new_solution[segment2_end%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[segment1_idx-1], segment2_nodes[-1]] +\n                    distance_matrix_2[segment1_nodes[0], new_solution[segment2_end%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[segment1_idx:segment2_end] = np.concatenate([segment2_nodes[::-1], segment1_nodes[::-1]])\n\n    for _ in range(min(5, n//2)):\n        segment_idx = np.random.randint(0, len(segments))\n        segment_start, segment_end, _ = segments[segment_idx]\n        segment_nodes = new_solution[segment_start:segment_end]\n\n        if len(segment_nodes) < 2:\n            continue\n\n        node_idx = np.random.randint(segment_start, segment_end)\n        node = new_solution[node_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node_idx-1], node] +\n                    distance_matrix_1[node, new_solution[(node_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node_idx-1], node] +\n                    distance_matrix_2[node, new_solution[(node_idx+1)%n]])\n\n        candidate_positions = []\n        for i in range(n):\n            if i >= segment_start and i < segment_end:\n                continue\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[i%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[i%n]])\n\n            candidate_positions.append((i, new_cost1 + new_cost2))\n\n        if not candidate_positions:\n            continue\n\n        candidate_positions.sort(key=lambda x: x[1])\n        best_pos, best_cost = candidate_positions[0]\n\n        if best_cost < old_cost1 + old_cost2 or np.random.random() < min(0.5, 0.1 + (old_cost1 + old_cost2 - best_cost) / (old_cost1 + old_cost2)):\n            candidate = np.delete(new_solution, node_idx)\n            new_solution = np.insert(candidate, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.936313186624378,
               5.8712515588155245
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive tour partitioning with multi-objective aware node swapping and insertion, which first segments the solution into dynamic partitions based on the combined spatial proximity and edge strength in both objective spaces, then selectively swaps nodes between partitions while considering their potential to improve both objectives, followed by a guided node insertion phase that prioritizes nodes with complementary improvement potential in both objectives, while dynamically adjusting the insertion depth based on the current solution's structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive tour partitioning\n    from scipy.spatial.distance import pdist, squareform\n\n    # Calculate combined spatial proximity and edge strength\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    # Calculate edge strength in both objectives\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    # Find partitions based on combined metrics\n    partition_size = max(3, min(7, n // 4))\n    partitions = []\n    for i in range(0, n, partition_size):\n        partition = base_solution[i:i+partition_size]\n        if len(partition) < 2:\n            continue\n\n        # Calculate partition strength\n        strength = sum(combined_dist[i,j] + edge_strength[i,j] for i in range(len(partition)-1) for j in range(i+1, len(partition)))\n        partitions.append((i, i+partition_size, strength))\n\n    # Sort partitions by strength (descending)\n    partitions.sort(key=lambda x: -x[2])\n\n    # Node swapping between partitions\n    for _ in range(min(3, len(partitions))):\n        if len(partitions) < 2:\n            break\n\n        # Select two partitions with high strength\n        part1_idx, part1_end, _ = partitions[0]\n        part2_idx, part2_end, _ = partitions[1]\n\n        # Select nodes from each partition\n        node1_idx = np.random.randint(part1_idx, part1_end)\n        node2_idx = np.random.randint(part2_idx, part2_end)\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[new_solution[node1_idx-1], new_solution[node1_idx]] +\n                    distance_matrix_1[new_solution[node1_idx], new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_1[new_solution[node2_idx-1], new_solution[node2_idx]] +\n                    distance_matrix_1[new_solution[node2_idx], new_solution[(node2_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node1_idx-1], new_solution[node1_idx]] +\n                    distance_matrix_2[new_solution[node1_idx], new_solution[(node1_idx+1)%n]] +\n                    distance_matrix_2[new_solution[node2_idx-1], new_solution[node2_idx]] +\n                    distance_matrix_2[new_solution[node2_idx], new_solution[(node2_idx+1)%n]])\n\n        # Try swapping the nodes\n        candidate = new_solution.copy()\n        candidate[node1_idx], candidate[node2_idx] = candidate[node2_idx], candidate[node1_idx]\n\n        new_cost = (distance_matrix_1[candidate[node1_idx-1], candidate[node1_idx]] +\n                   distance_matrix_1[candidate[node1_idx], candidate[(node1_idx+1)%n]] +\n                   distance_matrix_1[candidate[node2_idx-1], candidate[node2_idx]] +\n                   distance_matrix_1[candidate[node2_idx], candidate[(node2_idx+1)%n]] +\n                   distance_matrix_2[candidate[node1_idx-1], candidate[node1_idx]] +\n                   distance_matrix_2[candidate[node1_idx], candidate[(node1_idx+1)%n]] +\n                   distance_matrix_2[candidate[node2_idx-1], candidate[node2_idx]] +\n                   distance_matrix_2[candidate[node2_idx], candidate[(node2_idx+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    # Guided node insertion\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Remove the node\n        candidate = np.delete(new_solution, i)\n\n        # Find the best position to reinsert the node\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            # Dynamic insertion depth based on improvement potential\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            # Consider positions within the depth range\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                 distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                 distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.762487469458119,
               5.627394968801918
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining hierarchical clustering with multi-objective aware edge inversion and selective node reinsertion, which first organizes the solution into hierarchical clusters based on the combined spatial proximity and edge strength in both objective spaces, then selectively inverts entire clusters while considering their potential to improve both objectives, followed by a targeted node reinsertion phase that prioritizes nodes from different clusters with complementary improvement potential in both objectives, while dynamically adjusting the insertion position based on the current solution's hierarchical structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hierarchical clustering\n    from scipy.cluster.hierarchy import linkage, fcluster\n    from scipy.spatial.distance import pdist, squareform\n\n    # Calculate combined spatial proximity and edge strength\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    # Calculate edge strength in both objectives\n    edge_strength = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_strength[i,j] = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                    distance_matrix_2[base_solution[i], base_solution[j]])\n\n    # Create distance matrix for clustering\n    cluster_dist = combined_dist + edge_strength\n\n    # Perform hierarchical clustering\n    Z = linkage(cluster_dist, 'ward')\n    max_d = 0.7 * np.max(Z[:, 2])\n    clusters = fcluster(Z, max_d, criterion='distance')\n\n    # Get unique cluster IDs\n    unique_clusters = np.unique(clusters)\n    if len(unique_clusters) < 2:\n        return new_solution\n\n    # Cluster inversion\n    for _ in range(min(3, len(unique_clusters))):\n        # Select two different clusters\n        cluster_ids = np.random.choice(unique_clusters, size=2, replace=False)\n        cluster1 = np.where(clusters == cluster_ids[0])[0]\n        cluster2 = np.where(clusters == cluster_ids[1])[0]\n\n        if len(cluster1) < 1 or len(cluster2) < 1:\n            continue\n\n        # Calculate potential improvement\n        old_cost = 0\n        for i in range(len(base_solution)):\n            j = (i + 1) % n\n            if (i in cluster1 and j in cluster1) or (i in cluster2 and j in cluster2):\n                continue\n            old_cost += distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[j]]\n\n        # Invert one of the clusters\n        candidate = new_solution.copy()\n        if np.random.random() < 0.5:\n            candidate[cluster1] = candidate[cluster1][::-1]\n        else:\n            candidate[cluster2] = candidate[cluster2][::-1]\n\n        new_cost = 0\n        for i in range(len(candidate)):\n            j = (i + 1) % n\n            new_cost += distance_matrix_1[candidate[i], candidate[j]] + distance_matrix_2[candidate[i], candidate[j]]\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    # Selective node reinsertion\n    for _ in range(min(5, n//3)):\n        # Select a node from one cluster\n        cluster_id = np.random.choice(unique_clusters)\n        cluster_nodes = np.where(clusters == cluster_id)[0]\n        if len(cluster_nodes) < 2:\n            continue\n\n        node_idx = np.random.choice(cluster_nodes)\n        node = new_solution[node_idx]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] +\n                        distance_matrix_1[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] +\n                        distance_matrix_2[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n\n        # Remove the node\n        candidate = np.delete(new_solution, node_idx)\n\n        # Find best position to reinsert from a different cluster\n        best_pos = None\n        best_cost = float('inf')\n\n        for cluster_id2 in unique_clusters:\n            if cluster_id2 == cluster_id:\n                continue\n\n            cluster_nodes2 = np.where(clusters == cluster_id2)[0]\n            if len(cluster_nodes2) < 1:\n                continue\n\n            # Consider positions near nodes from the other cluster\n            for pos in cluster_nodes2:\n                for offset in [-1, 0, 1]:\n                    actual_pos = (pos + offset) % len(candidate)\n                    temp = np.insert(candidate, actual_pos, node)\n                    temp_cost1 = (distance_matrix_1[temp[actual_pos-1], temp[actual_pos]] +\n                                distance_matrix_1[temp[actual_pos], temp[(actual_pos+1)%len(temp)]])\n                    temp_cost2 = (distance_matrix_2[temp[actual_pos-1], temp[actual_pos]] +\n                                distance_matrix_2[temp[actual_pos], temp[(actual_pos+1)%len(temp)]])\n\n                    if temp_cost1 + temp_cost2 < best_cost:\n                        best_cost = temp_cost1 + temp_cost2\n                        best_pos = actual_pos\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.782559088643776,
               6.4433598625867035
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive path decomposition with multi-objective aware node swapping, which first partitions the solution into hierarchical paths based on both spatial coherence and edge strength in the two objective spaces, then selectively swaps nodes between paths to optimize the trade-off between objectives, followed by a probability-weighted path inversion phase that prioritizes moves with complementary improvement potential in both objectives, while dynamically adjusting the swapping depth based on the current solution's structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    from scipy.spatial.distance import pdist, squareform\n\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n\n    path_length = max(3, min(7, n // 4))\n    paths = []\n    for i in range(0, n, path_length):\n        path = base_solution[i:i+path_length]\n        if len(path) < 2:\n            continue\n\n        strength1 = sum(distance_matrix_1[path[j], path[j+1]] for j in range(len(path)-1))\n        strength2 = sum(distance_matrix_2[path[j], path[j+1]] for j in range(len(path)-1))\n        paths.append((i, i+path_length, strength1 + strength2))\n\n    paths.sort(key=lambda x: -x[2])\n\n    for _ in range(min(3, len(paths))):\n        if len(paths) < 2:\n            break\n\n        path1_idx, path1_end, _ = paths[0]\n        path2_idx, path2_end, _ = paths[1]\n\n        path1_nodes = base_solution[path1_idx:path1_end]\n        path2_nodes = base_solution[path2_idx:path2_end]\n\n        if len(path1_nodes) < 2 or len(path2_nodes) < 2:\n            continue\n\n        node1_idx = np.random.randint(path1_idx, path1_end)\n        node2_idx = np.random.randint(path2_idx, path2_end)\n        node1 = new_solution[node1_idx]\n        node2 = new_solution[node2_idx]\n\n        old_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node1] +\n                     distance_matrix_1[node1, new_solution[(node1_idx+1)%n]] +\n                     distance_matrix_1[new_solution[node2_idx-1], node2] +\n                     distance_matrix_1[node2, new_solution[(node2_idx+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node1] +\n                     distance_matrix_2[node1, new_solution[(node1_idx+1)%n]] +\n                     distance_matrix_2[new_solution[node2_idx-1], node2] +\n                     distance_matrix_2[node2, new_solution[(node2_idx+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[node1_idx-1], node2] +\n                     distance_matrix_1[node2, new_solution[(node1_idx+1)%n]] +\n                     distance_matrix_1[new_solution[node2_idx-1], node1] +\n                     distance_matrix_1[node1, new_solution[(node2_idx+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[node1_idx-1], node2] +\n                     distance_matrix_2[node2, new_solution[(node1_idx+1)%n]] +\n                     distance_matrix_2[new_solution[node2_idx-1], node1] +\n                     distance_matrix_2[node1, new_solution[(node2_idx+1)%n]])\n\n        if new_cost1 + new_cost2 < old_cost1 + old_cost2:\n            new_solution[node1_idx], new_solution[node2_idx] = new_solution[node2_idx], new_solution[node1_idx]\n\n    for _ in range(min(5, n//3)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[j-1]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j-1]])\n\n        improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n        if improvement > 0 or np.random.random() < min(0.5, 0.1 + improvement / (old_cost1 + old_cost2)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               5.927690221836014,
               6.344430830785339
          ]
     }
]