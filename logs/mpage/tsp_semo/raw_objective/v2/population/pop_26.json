[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high ratio of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Swap two edges if it improves both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate new objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n           (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n            new_solution = candidate\n            break\n\n    # Segment reversal: Reverse a random segment if it improves the solution\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new objectives\n    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    # Accept if both objectives improve or one improves significantly\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n       (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n       (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               7.938052437621909,
               4.974250410098344
          ]
     },
     {
          "algorithm": "{The new algorithm employs a novel multi-objective path decomposition and reconstruction strategy that first dynamically partitions the solution into non-overlapping segments based on their contribution to both objectives, then intelligently reorders these segments using a hybrid similarity metric that combines both objective improvements and spatial proximity, followed by a constrained segment merging process that preserves high-quality sub-tours while introducing controlled randomness through a probabilistic segment inversion mechanism that adaptively adjusts its application probability based on the current trade-off between objectives, ensuring feasibility through a guided node reinsertion strategy that maintains proper tour connectivity and closure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.metrics import pairwise_distances\n    import random\n\n    # Select solution with best combined objective\n    objectives = np.array([obj for _, obj in archive])\n    combined_obj = objectives[:, 0] * 0.5 + objectives[:, 1] * 0.5\n    selected_idx = np.argmin(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic segment partitioning based on objective contribution\n    segment_sizes = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        current_node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Check if adding to current segment improves both objectives\n        if cost1 < distance_matrix_1[base_solution[i-1], base_solution[i]] and \\\n           cost2 < distance_matrix_2[base_solution[i-1], base_solution[i]]:\n            current_segment.append(current_node)\n        else:\n            segment_sizes.append(len(current_segment))\n            current_segment = [current_node]\n    segment_sizes.append(len(current_segment))\n\n    # Create segments based on calculated sizes\n    segments = []\n    start = 0\n    for size in segment_sizes:\n        segments.append(base_solution[start:start+size])\n        start += size\n\n    # Hybrid segment reordering\n    segment_coords = []\n    for seg in segments:\n        seg_coords = instance[seg, :2].mean(axis=0)\n        segment_coords.append(seg_coords)\n    segment_coords = np.array(segment_coords)\n\n    # Calculate similarity based on both objectives and spatial proximity\n    similarity_matrix = np.zeros((len(segments), len(segments)))\n    for i in range(len(segments)):\n        for j in range(len(segments)):\n            if i == j:\n                similarity_matrix[i,j] = 0\n            else:\n                # Objective similarity\n                seg1_cost1 = sum(distance_matrix_1[segments[i][k], segments[i][(k+1)%len(segments[i])]] for k in range(len(segments[i])))\n                seg1_cost2 = sum(distance_matrix_2[segments[i][k], segments[i][(k+1)%len(segments[i])]] for k in range(len(segments[i])))\n                seg2_cost1 = sum(distance_matrix_1[segments[j][k], segments[j][(k+1)%len(segments[j])]] for k in range(len(segments[j])))\n                seg2_cost2 = sum(distance_matrix_2[segments[j][k], segments[j][(k+1)%len(segments[j])]] for k in range(len(segments[j])))\n\n                obj_similarity = 1 / (1 + abs(seg1_cost1 - seg2_cost1) + abs(seg1_cost2 - seg2_cost2))\n\n                # Spatial similarity\n                spatial_similarity = 1 / (1 + np.linalg.norm(segment_coords[i] - segment_coords[j]))\n\n                similarity_matrix[i,j] = 0.7 * obj_similarity + 0.3 * spatial_similarity\n\n    # Greedy segment reordering\n    ordered_segments = []\n    remaining_indices = list(range(len(segments)))\n    current_index = random.choice(remaining_indices)\n    ordered_segments.append(segments[current_index])\n    remaining_indices.remove(current_index)\n\n    while remaining_indices:\n        best_index = max(remaining_indices, key=lambda x: similarity_matrix[current_index, x])\n        ordered_segments.append(segments[best_index])\n        current_index = best_index\n        remaining_indices.remove(best_index)\n\n    # Reconstruct solution\n    new_solution = np.concatenate(ordered_segments)\n\n    # Probabilistic segment inversion\n    for i in range(len(segments)):\n        if random.random() < 0.3:  # 30% chance to invert\n            new_solution[sum(segment_sizes[:i]):sum(segment_sizes[:i+1])] = \\\n                new_solution[sum(segment_sizes[:i]):sum(segment_sizes[:i+1])][::-1]\n\n    # Guided node reinsertion for feasibility\n    for _ in range(3):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in range(n-1):\n            candidate = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            score = 0.6 * cost1 + 0.4 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos is not None:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               4.3980138411430225,
               8.956155718227361
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of focusing on diverse solutions from the first provided algorithm with a novel local search operator that integrates both path inversion and node relocation, guided by a hybrid objective improvement criterion that considers both individual objective improvements and their combined trade-offs. It first partitions the archive into clusters based on both objective values and spatial diversity, then selects a representative solution from the least explored cluster. The local search operator dynamically selects multiple non-overlapping segments from the solution, applies inversion with probability based on local objective improvements, and then performs targeted node relocations to further optimize the tour, with the search guided by a hybrid acceptance criterion that balances individual objective improvements with their combined trade-offs to ensure feasible and high-quality solutions are generated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.cluster import KMeans\n    import random\n\n    # Cluster-based selection\n    objectives = np.array([obj for _, obj in archive])\n    coords = instance[archive[0][0], :2]\n    diversity = np.array([np.std(coords[:, 0]), np.std(coords[:, 1])])\n\n    cluster_data = np.hstack([objectives, diversity.reshape(1, -1).repeat(len(archive), axis=0)])\n    n_clusters = min(3, len(archive))\n    kmeans = KMeans(n_clusters=n_clusters)\n    labels = kmeans.fit_predict(cluster_data)\n\n    cluster_sizes = np.bincount(labels)\n    least_cluster = np.argmin(cluster_sizes)\n    candidates = [i for i, label in enumerate(labels) if label == least_cluster]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment inversion with node relocation\n    num_segments = min(3, n // 4)\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n    segments = [(segment_indices[i], segment_indices[i+1]) for i in range(0, len(segment_indices), 2)]\n    segments.sort(key=lambda x: x[1]-x[0], reverse=True)\n\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        if random.random() < 0.6:\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n\n            inverted_segment = segment[::-1]\n            temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= 1.1 * current_cost2) or \\\n               (new_cost1 <= 1.1 * current_cost1 and new_cost2 < current_cost2):\n                new_solution = temp_solution\n\n    # Node relocation with trade-off consideration\n    for _ in range(5):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        candidate_positions = list(range(n))\n        candidate_positions.remove(node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in candidate_positions:\n            temp_sol = np.delete(new_solution, node_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            combined_score = 0.7 * cost1 + 0.3 * cost2\n            if combined_score < best_score:\n                best_pos = pos\n                best_score = combined_score\n\n        if best_pos is not None:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.041981799207054,
               7.326106261285743
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto-based solution selection with a novel multi-objective tour fragmentation and reassembly strategy that intelligently splits the tour into contiguous segments, evaluates their objective contributions, and reassembles them in a way that maximizes improvements in both objectives while maintaining solution feasibility through a constrained segment merging mechanism. The reassembly process dynamically adjusts segment boundaries based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided segment rotation mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best Pareto trade-off\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective tour fragmentation and reassembly\n    for _ in range(5):\n        # Randomly select two cut points to split the tour into three segments\n        cut1, cut2 = sorted(random.sample(range(1, n), 2))\n        segment1 = base_solution[:cut1]\n        segment2 = base_solution[cut1:cut2]\n        segment3 = base_solution[cut2:]\n\n        # Try different reassembly orders\n        candidates = [\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment3, segment2, segment1]),\n            np.concatenate([segment1, segment2[::-1], segment3]),\n            np.concatenate([segment2[::-1], segment1, segment3])\n        ]\n\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_candidate = candidate\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    # Guided segment rotation\n    for _ in range(5):\n        # Select a segment to rotate\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Try different rotation amounts\n        for rotation in range(1, segment_length):\n            candidate = new_solution.copy()\n            segment = candidate[start:end]\n            rotated_segment = np.roll(segment, rotation)\n            candidate[start:end] = rotated_segment\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.520469626016764,
               5.163588701139817
          ]
     },
     {
          "algorithm": "{The new algorithm employs a novel multi-objective tour reconstruction strategy that first identifies critical path segments based on their contribution to both objectives, then intelligently reorders these segments using a hybrid similarity metric that combines both objective improvements and spatial proximity, followed by a constrained segment merging process that preserves high-quality sub-tours while introducing controlled randomness through a probabilistic segment inversion mechanism that adaptively adjusts its application probability based on the current trade-off between objectives, ensuring feasibility through a guided node reinsertion strategy that maintains proper tour connectivity and closure, and finally applies a dynamic edge swap operator that selectively exchanges edges between segments to further optimize the tour while respecting the trade-off between objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    import random\n    import numpy as np\n    from collections import defaultdict\n\n    # Select solution with best combined objective\n    objectives = np.array([obj for _, obj in archive])\n    combined_obj = objectives[:, 0] * 0.5 + objectives[:, 1] * 0.5\n    selected_idx = np.argmin(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Identify critical path segments\n    segment_sizes = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        current_node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Check if adding to current segment improves both objectives\n        if cost1 < distance_matrix_1[base_solution[i-1], base_solution[i]] and \\\n           cost2 < distance_matrix_2[base_solution[i-1], base_solution[i]]:\n            current_segment.append(current_node)\n        else:\n            segment_sizes.append(len(current_segment))\n            current_segment = [current_node]\n    segment_sizes.append(len(current_segment))\n\n    # Create segments based on calculated sizes\n    segments = []\n    start = 0\n    for size in segment_sizes:\n        segments.append(base_solution[start:start+size])\n        start += size\n\n    # Calculate segment similarity\n    segment_coords = []\n    for seg in segments:\n        seg_coords = instance[seg, :2].mean(axis=0)\n        segment_coords.append(seg_coords)\n    segment_coords = np.array(segment_coords)\n\n    similarity_matrix = np.zeros((len(segments), len(segments)))\n    for i in range(len(segments)):\n        for j in range(len(segments)):\n            if i == j:\n                similarity_matrix[i,j] = 0\n            else:\n                # Objective similarity\n                seg1_cost1 = sum(distance_matrix_1[segments[i][k], segments[i][(k+1)%len(segments[i])]] for k in range(len(segments[i])))\n                seg1_cost2 = sum(distance_matrix_2[segments[i][k], segments[i][(k+1)%len(segments[i])]] for k in range(len(segments[i])))\n                seg2_cost1 = sum(distance_matrix_1[segments[j][k], segments[j][(k+1)%len(segments[j])]] for k in range(len(segments[j])))\n                seg2_cost2 = sum(distance_matrix_2[segments[j][k], segments[j][(k+1)%len(segments[j])]] for k in range(len(segments[j])))\n\n                obj_similarity = 1 / (1 + abs(seg1_cost1 - seg2_cost1) + abs(seg1_cost2 - seg2_cost2))\n\n                # Spatial similarity\n                spatial_similarity = 1 / (1 + np.linalg.norm(segment_coords[i] - segment_coords[j]))\n\n                similarity_matrix[i,j] = 0.6 * obj_similarity + 0.4 * spatial_similarity\n\n    # Greedy segment reordering\n    ordered_segments = []\n    remaining_indices = list(range(len(segments)))\n    current_index = random.choice(remaining_indices)\n    ordered_segments.append(segments[current_index])\n    remaining_indices.remove(current_index)\n\n    while remaining_indices:\n        best_index = max(remaining_indices, key=lambda x: similarity_matrix[current_index, x])\n        ordered_segments.append(segments[best_index])\n        current_index = best_index\n        remaining_indices.remove(best_index)\n\n    # Reconstruct solution\n    new_solution = np.concatenate(ordered_segments)\n\n    # Probabilistic segment inversion\n    for i in range(len(segments)):\n        if random.random() < 0.4:  # 40% chance to invert\n            new_solution[sum(segment_sizes[:i]):sum(segment_sizes[:i+1])] = \\\n                new_solution[sum(segment_sizes[:i]):sum(segment_sizes[:i+1])][::-1]\n\n    # Dynamic edge swap operator\n    for _ in range(5):\n        # Select two random segments\n        seg1_idx, seg2_idx = random.sample(range(len(segments)), 2)\n        seg1 = new_solution[sum(segment_sizes[:seg1_idx]):sum(segment_sizes[:seg1_idx+1])]\n        seg2 = new_solution[sum(segment_sizes[:seg2_idx]):sum(segment_sizes[:seg2_idx+1])]\n\n        # Select edges from each segment\n        if len(seg1) > 1 and len(seg2) > 1:\n            edge1_pos = random.randint(0, len(seg1)-2)\n            edge2_pos = random.randint(0, len(seg2)-2)\n\n            # Create temporary solution\n            temp_solution = new_solution.copy()\n            temp_solution[sum(segment_sizes[:seg1_idx])+edge1_pos] = seg2[edge2_pos]\n            temp_solution[sum(segment_sizes[:seg1_idx])+edge1_pos+1] = seg2[edge2_pos+1]\n            temp_solution[sum(segment_sizes[:seg2_idx])+edge2_pos] = seg1[edge1_pos]\n            temp_solution[sum(segment_sizes[:seg2_idx])+edge2_pos+1] = seg1[edge1_pos+1]\n\n            # Check feasibility\n            if len(np.unique(temp_solution)) == n:\n                # Calculate cost\n                cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                # Calculate original cost\n                orig_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                orig_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                # Accept if both objectives improve\n                if cost1 < orig_cost1 and cost2 < orig_cost2:\n                    new_solution = temp_solution\n\n    # Guided node reinsertion for feasibility\n    for _ in range(3):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in range(n-1):\n            candidate = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos is not None:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               4.580038901455546,
               8.72839626634635
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating each solution's potential for improvement using a combination of objective values and diversity measures. It then applies a novel hybrid local search operator that combines a modified version of the Lin-Kernighan heuristic with a variable-length segment relocation strategy. The operator randomly selects a segment of nodes in the tour and relocates it to a new position while considering both objective spaces, ensuring feasibility by maintaining the TSP constraints. The selection of the segment length and insertion point is guided by a probabilistic approach that balances exploration and exploitation, favoring segments that show high potential for reducing both objectives. The function returns the new neighbor solution after validating its feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([(cost1 + cost2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2)) for _, (cost1, cost2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length (1 to n//2)\n    segment_length = random.randint(1, n // 2)\n\n    # Randomly select a starting position for the segment\n    start_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Find the best insertion position considering both objectives\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for insert_pos in range(len(new_solution)):\n        # Insert the segment at the current position\n        candidate = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Combine the costs with a weighted sum\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = insert_pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
          "score": [
               6.11088345881558,
               5.468006696741405
          ]
     },
     {
          "algorithm": "{This new algorithm employs a multi-objective tour decomposition and reconstruction strategy that first dynamically partitions the solution into non-overlapping segments based on their objective-specific characteristics, then applies a novel segment reordering mechanism that combines both objective improvements and spatial proximity through a hybrid similarity metric, followed by a constrained segment merging process that preserves high-quality sub-tours while introducing controlled randomness through a probabilistic segment inversion mechanism that adaptively adjusts its application probability based on the current trade-off between objectives, ensuring feasibility through a guided node reinsertion strategy that maintains proper tour connectivity and closure, and finally refines the solution through an adaptive perturbation scheme that selectively alters node sequences based on local objective gradients within a dynamic neighborhood framework that balances exploration and exploitation through adaptive parameter tuning.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    import random\n    import numpy as np\n    from scipy.spatial import distance\n\n    # Phase 1: Solution selection based on objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    tradeoff_scores = normalized_obj[:, 0] * 0.7 + normalized_obj[:, 1] * 0.3\n    selected_idx = np.argmin(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Phase 2: Dynamic segment partitioning based on objective characteristics\n    segment_sizes = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        current_node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Check if adding to current segment improves both objectives\n        if cost1 < distance_matrix_1[base_solution[i-1], base_solution[i]] and \\\n           cost2 < distance_matrix_2[base_solution[i-1], base_solution[i]]:\n            current_segment.append(current_node)\n        else:\n            segment_sizes.append(len(current_segment))\n            current_segment = [current_node]\n    segment_sizes.append(len(current_segment))\n\n    # Create segments based on calculated sizes\n    segments = []\n    start = 0\n    for size in segment_sizes:\n        segments.append(base_solution[start:start+size])\n        start += size\n\n    # Phase 3: Hybrid segment reordering with adaptive similarity metric\n    segment_features = []\n    for seg in segments:\n        seg_coords1 = instance[seg, :2].mean(axis=0)\n        seg_coords2 = instance[seg, 2:].mean(axis=0)\n        seg_cost1 = sum(distance_matrix_1[seg[k], seg[(k+1)%len(seg)]] for k in range(len(seg)))\n        seg_cost2 = sum(distance_matrix_2[seg[k], seg[(k+1)%len(seg)]] for k in range(len(seg)))\n        segment_features.append(np.concatenate([seg_coords1, seg_coords2, [seg_cost1, seg_cost2]]))\n    segment_features = np.array(segment_features)\n\n    # Calculate similarity matrix\n    similarity_matrix = np.zeros((len(segments), len(segments)))\n    for i in range(len(segments)):\n        for j in range(len(segments)):\n            if i == j:\n                similarity_matrix[i,j] = 0\n            else:\n                # Spatial similarity\n                spatial_sim1 = 1 / (1 + np.linalg.norm(segment_features[i, :2] - segment_features[j, :2]))\n                spatial_sim2 = 1 / (1 + np.linalg.norm(segment_features[i, 2:4] - segment_features[j, 2:4]))\n\n                # Objective similarity\n                obj_sim1 = 1 / (1 + abs(segment_features[i, 4] - segment_features[j, 4]))\n                obj_sim2 = 1 / (1 + abs(segment_features[i, 5] - segment_features[j, 5]))\n\n                similarity_matrix[i,j] = 0.4 * spatial_sim1 + 0.3 * spatial_sim2 + 0.2 * obj_sim1 + 0.1 * obj_sim2\n\n    # Greedy segment reordering\n    ordered_segments = []\n    remaining_indices = list(range(len(segments)))\n    current_index = random.choice(remaining_indices)\n    ordered_segments.append(segments[current_index])\n    remaining_indices.remove(current_index)\n\n    while remaining_indices:\n        best_index = max(remaining_indices, key=lambda x: similarity_matrix[current_index, x])\n        ordered_segments.append(segments[best_index])\n        current_index = best_index\n        remaining_indices.remove(best_index)\n\n    # Reconstruct solution\n    new_solution = np.concatenate(ordered_segments)\n\n    # Phase 4: Probabilistic segment inversion with adaptive probability\n    inversion_prob = 0.2 + 0.3 * (objectives[selected_idx, 1] - objectives[selected_idx, 0]) / (objectives[selected_idx, 0] + objectives[selected_idx, 1] + 1e-8)\n    for i in range(len(segments)):\n        if random.random() < inversion_prob:\n            new_solution[sum(segment_sizes[:i]):sum(segment_sizes[:i+1])] = \\\n                new_solution[sum(segment_sizes[:i]):sum(segment_sizes[:i+1])][::-1]\n\n    # Phase 5: Guided node reinsertion for feasibility\n    for _ in range(2):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in range(n-1):\n            candidate = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            score = 0.7 * cost1 + 0.3 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos is not None:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Phase 6: Adaptive perturbation based on local gradients\n    perturbation_rate = 0.2\n    for i in range(n):\n        if random.random() < perturbation_rate:\n            neighbors = [j for j in range(n) if j != i]\n\n            best_neighbor = None\n            best_improvement = 0\n\n            for j in neighbors:\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n                cost1 = (sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n)) -\n                        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)))\n                cost2 = (sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n)) -\n                        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)))\n\n                improvement = 0.7 * cost1 + 0.3 * cost2\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_neighbor = j\n\n            if best_neighbor is not None:\n                new_solution[i], new_solution[best_neighbor] = new_solution[best_neighbor], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               5.195290369361313,
               6.661773631819725
          ]
     },
     {
          "algorithm": "{The new algorithm combines an adaptive multi-objective clustering approach with a novel hierarchical segment reassembly strategy that dynamically identifies and preserves high-quality sub-tours from the Pareto front solutions, while intelligently breaking and reconnecting them through a constrained node permutation mechanism that prioritizes non-dominated segments based on their contribution to both objectives, using a weighted multi-criteria evaluation to guide the reassembly process while maintaining solution feasibility by ensuring proper node connectivity and tour closure through a guided segment inversion and merging mechanism that adaptively adjusts the segment size and merge position based on the current trade-off between objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Adaptive multi-objective clustering with weighted selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    cluster_centers = np.array([[0.25, 0.75], [0.5, 0.5], [0.75, 0.25]])\n    distances = np.linalg.norm(normalized_obj[:, None] - cluster_centers, axis=2)\n    cluster_assignments = np.argmin(distances, axis=1)\n\n    # Select from the most promising cluster (middle cluster)\n    cluster_indices = np.where(cluster_assignments == 1)[0]\n    if len(cluster_indices) > 0:\n        selected_idx = np.random.choice(cluster_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hierarchical segment reassembly with dynamic segment size\n    for _ in range(4):\n        segment_size = np.random.randint(2, min(5, n // 4))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        segment = base_solution[start:end]\n\n        # Evaluate segment contribution using weighted criteria\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        total_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        total_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        # Weighted importance based on current trade-off\n        weight1 = segment_cost1 / (total_cost1 + 1e-6)\n        weight2 = segment_cost2 / (total_cost2 + 1e-6)\n        weights = [weight1, weight2] if weight1 > weight2 else [weight2, weight1]\n\n        # Remove segment and find best merge position\n        temp_solution = np.concatenate([base_solution[:start], base_solution[end:]])\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(temp_solution)):\n            # Try inserting segment at position i and its reverse\n            candidates = [\n                np.insert(temp_solution, i, segment),\n                np.insert(temp_solution, i, segment[::-1])\n            ]\n\n            for candidate in candidates:\n                candidate_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                candidate_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                score = weights[0] * candidate_cost1 + weights[1] * candidate_cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n                    best_candidate = candidate\n\n        if best_pos != -1:\n            new_solution = best_candidate\n\n    # Guided segment inversion with adaptive acceptance\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], inverted_segment, new_solution[j+1:]])\n\n        # Check feasibility\n        if len(np.unique(candidate)) == n:\n            # Calculate weighted score\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Adaptive weights based on current trade-off\n            weight1 = new_cost1 / (current_cost1 + 1e-6)\n            weight2 = new_cost2 / (current_cost2 + 1e-6)\n            weights = [weight1, weight2] if weight1 > weight2 else [weight2, weight1]\n\n            current_score = weights[0] * current_cost1 + weights[1] * current_cost2\n            new_score = weights[0] * new_cost1 + weights[1] * new_cost2\n\n            if new_score < current_score:\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.382759568727223,
               6.525019920193785
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto-based solution selection with a novel multi-objective tour fragmentation and reassembly strategy that intelligently splits the tour into contiguous segments, evaluates their objective contributions, and reassembles them in a way that maximizes improvements in both objectives while maintaining solution feasibility through a constrained segment merging mechanism. The reassembly process dynamically adjusts segment boundaries based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided segment rotation mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best Pareto trade-off\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective tour fragmentation and reassembly\n    for _ in range(5):\n        # Randomly select two cut points to split the tour into three segments\n        cut1, cut2 = sorted(random.sample(range(1, n), 2))\n        segment1 = base_solution[:cut1]\n        segment2 = base_solution[cut1:cut2]\n        segment3 = base_solution[cut2:]\n\n        # Try different reassembly orders\n        candidates = [\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment3, segment2, segment1]),\n            np.concatenate([segment1, segment2[::-1], segment3]),\n            np.concatenate([segment2[::-1], segment1, segment3])\n        ]\n\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_candidate = candidate\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    # Guided segment rotation\n    for _ in range(5):\n        # Select a segment to rotate\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Try different rotation amounts\n        for rotation in range(1, segment_length):\n            candidate = new_solution.copy()\n            segment = candidate[start:end]\n            rotated_segment = np.roll(segment, rotation)\n            candidate[start:end] = rotated_segment\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n                new_solution = candidate\n\n    # Novel hybrid operator: Segment insertion with objective-aware placement\n    for _ in range(3):\n        # Select a random segment to move\n        segment_length = np.random.randint(2, min(5, n // 3))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from the tour\n        candidate = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Find insertion points that balance both objectives\n        best_insertion = None\n        best_improvement = 0\n\n        for i in range(len(candidate)):\n            # Try inserting the segment at position i\n            temp = np.insert(candidate, i, segment)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[temp[k], temp[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp[k], temp[(k+1)%n]] for k in range(n))\n\n            # Calculate improvement in both objectives\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            improvement1 = (current_cost1 - cost1) / current_cost1 if current_cost1 > 0 else 0\n            improvement2 = (current_cost2 - cost2) / current_cost2 if current_cost2 > 0 else 0\n\n            # Balance improvement between objectives\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_insertion = temp\n\n        if best_insertion is not None:\n            new_solution = best_insertion\n\n    return new_solution\n\n",
          "score": [
               5.930399048602649,
               5.815631553437875
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto front analysis with a novel multi-objective segment relocation strategy that dynamically selects and repositions segments of the tour based on their contribution to both objectives, using a hybrid acceptance criterion that balances improvement in both objectives while maintaining solution feasibility through a constrained segment relocation mechanism. The segment relocation dynamically adjusts the segment length and position based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided edge reversal mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best trade-off using Pareto front analysis\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective segment relocation\n    for _ in range(5):\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(n - segment_length)\n        end = start + segment_length\n\n        # Extract the segment\n        segment = base_solution[start:end]\n\n        # Remove the segment\n        temp_solution = np.concatenate([base_solution[:start], base_solution[end:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(len(temp_solution)):\n            # Insert segment at position i\n            candidate = np.insert(temp_solution, i, segment)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Multi-objective comparison\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_pos = i\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        # Insert segment at best position\n        new_solution = np.insert(temp_solution, best_pos, segment)\n\n    # Guided edge reversal\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n        # Calculate costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if at least one objective improves or both improve with controlled trade-off\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.733596318190619,
               5.825750634336084
          ]
     }
]