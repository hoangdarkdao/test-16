[
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment rotation, probabilistic node swapping with objective-aware distance evaluation, and dynamic path reversal to intelligently explore the solution space while maintaining feasibility and improving both objectives through coordinated multi-objective operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_size = max(2, min(4, n // 4))\n    pos = random.randint(0, n - segment_size)\n    rotation = random.randint(1, segment_size - 1)\n    segment = new_solution[pos:pos+segment_size]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[pos:pos+segment_size] = rotated_segment\n\n    # Step 2: Probabilistic node swapping with objective-aware evaluation\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.5 if random.random() < 0.6 else 0.3\n        if (obj1_weight * swapped_cost1 + (1-obj1_weight) * swapped_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Dynamic path reversal with multi-objective consideration\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n\n        reversed_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k-1)%n]] for k in range(j, i, -1))\n        reversed_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k-1)%n]] for k in range(j, i, -1))\n\n        obj1_weight = 0.7 if random.random() < 0.5 else 0.3\n        if (obj1_weight * reversed_cost1 + (1-obj1_weight) * reversed_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9602842910874554,
            0.2636159658432007
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping, probabilistic node reinsertion, and objective-balanced path inversion to dynamically explore the solution space while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment swapping\n    segment_size = max(2, min(3, n // 5))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    new_solution[pos1:pos1+segment_size], new_solution[pos2:pos2+segment_size] = new_solution[pos2:pos2+segment_size], new_solution[pos1:pos1+segment_size]\n\n    # Step 2: Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced path inversion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.6 if random.random() < 0.7 else 0.4\n        if (obj1_weight * inverted_cost1 + (1-obj1_weight) * inverted_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7745000102125286,
            0.06662243604660034
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping, probabilistic node reinsertion, and objective-balanced path inversion to dynamically explore the solution space while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment swapping\n    segment_size = max(2, min(3, n // 5))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    new_solution[pos1:pos1+segment_size], new_solution[pos2:pos2+segment_size] = new_solution[pos2:pos2+segment_size], new_solution[pos1:pos1+segment_size]\n\n    # Step 2: Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced path inversion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.6 if random.random() < 0.7 else 0.4\n        if (obj1_weight * inverted_cost1 + (1-obj1_weight) * inverted_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7745000102125286,
            0.06662243604660034
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment rotation, probabilistic node swapping with objective-aware distance evaluation, and dynamic path reversal to intelligently explore the solution space while maintaining feasibility and improving both objectives through coordinated multi-objective operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_size = max(2, min(4, n // 4))\n    pos = random.randint(0, n - segment_size)\n    rotation = random.randint(1, segment_size - 1)\n    segment = new_solution[pos:pos+segment_size]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[pos:pos+segment_size] = rotated_segment\n\n    # Step 2: Probabilistic node swapping with objective-aware evaluation\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.5 if random.random() < 0.6 else 0.3\n        if (obj1_weight * swapped_cost1 + (1-obj1_weight) * swapped_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Dynamic path reversal with multi-objective consideration\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n\n        reversed_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k-1)%n]] for k in range(j, i, -1))\n        reversed_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k-1)%n]] for k in range(j, i, -1))\n\n        obj1_weight = 0.7 if random.random() < 0.5 else 0.3\n        if (obj1_weight * reversed_cost1 + (1-obj1_weight) * reversed_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9602842910874554,
            0.2636159658432007
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment merging, probabilistic node relocation, and objective-balanced segment rotation to dynamically explore the solution space while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment merging\n    segment_size = max(3, min(4, n // 4))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Step 2: Probabilistic node relocation\n    if random.random() < 0.6:\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced segment rotation\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        rotated_cost1 = distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[j]]\n        rotated_cost2 = distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[j]]\n\n        obj1_weight = 0.7 if random.random() < 0.6 else 0.3\n        if (obj1_weight * rotated_cost1 + (1-obj1_weight) * rotated_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i+1:j+1] = np.roll(new_solution[i+1:j+1], random.randint(1, j-i))\n\n    return new_solution\n\n",
        "score": [
            -0.8535255924087962,
            0.10285478830337524
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping, probabilistic node reinsertion, and objective-balanced path inversion to dynamically explore the solution space while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment swapping\n    segment_size = max(2, min(3, n // 5))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    new_solution[pos1:pos1+segment_size], new_solution[pos2:pos2+segment_size] = new_solution[pos2:pos2+segment_size], new_solution[pos1:pos1+segment_size]\n\n    # Step 2: Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced path inversion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.6 if random.random() < 0.7 else 0.4\n        if (obj1_weight * inverted_cost1 + (1-obj1_weight) * inverted_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7745000102125286,
            0.06662243604660034
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment relocation, probabilistic node insertion, and objective-weighted edge reversal to intelligently explore the solution space while balancing improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    segment_size = max(2, min(4, n // 6))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Probabilistic node insertion\n    if random.random() < 0.6:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge reversal\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        weight = random.random()\n        if (weight * reversed_cost1 + (1-weight) * reversed_cost2) < (weight * current_cost1 + (1-weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9511987747734297,
            0.2520816922187805
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment reconfiguration, probabilistic node insertion, and objective-weighted edge reversal to explore high-quality diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.1]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic segment reconfiguration\n    segment_size = max(4, min(6, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[start:end] = new_segment\n\n    # Phase 2: Probabilistic node insertion\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Phase 3: Objective-weighted edge reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        current_cost = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        reversed_cost = distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        if reversed_cost < current_cost * 0.8:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8965615837102534,
            0.15779626369476318
        ]
    },
    {
        "algorithm": "{An adaptive multi-phase local search algorithm that combines dynamic node reordering, probabilistic segment swapping, and hybrid edge reversal with adaptive objective weighting to explore the solution space while balancing improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic node reordering\n    segment_size = max(3, min(5, n // 5))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Probabilistic segment swapping\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1])\n\n    # Step 3: Hybrid edge reversal with adaptive objective weighting\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        weight = 0.5 * (current_cost1 / (current_cost1 + current_cost2)) + 0.5 * (current_cost2 / (current_cost1 + current_cost2))\n        if (weight * reversed_cost1 + (1-weight) * reversed_cost2) < (weight * current_cost1 + (1-weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9364345016172395,
            0.2411363124847412
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment relocation, probabilistic node insertion, and objective-weighted edge reversal to intelligently explore the solution space while balancing improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    segment_size = max(2, min(4, n // 6))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Probabilistic node insertion\n    if random.random() < 0.6:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge reversal\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        weight = random.random()\n        if (weight * reversed_cost1 + (1-weight) * reversed_cost2) < (weight * current_cost1 + (1-weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9511987747734297,
            0.2520816922187805
        ]
    }
]