[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7434419995183119,
            0.23801034688949585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7434419995183119,
            0.23801034688949585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7434419995183119,
            0.23801034688949585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8267726137096276,
            0.1920059323310852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8267726137096276,
            0.1920059323310852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8267726137096276,
            0.1920059323310852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9455102295811514,
            0.24830931425094604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9455102295811514,
            0.24830931425094604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines a multi-objective selection criterion with a randomized edge-swapping strategy, prioritizing solutions with high potential for improvement while ensuring feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, max(1, len(archive) // 5))\n    selected_solution = random.choice(sorted_archive[:candidate_indices])[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + n // 4, n - 1))\n\n    # Extract the segment and reverse it (with probability 0.7)\n    if random.random() < 0.7:\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n    # Randomly swap two edges with probability 0.5\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply a randomized 3-opt move with probability 0.3\n    if random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8865208442472817,
            0.2694881558418274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, max(1, len(archive) // 5))\n    selected_solution = random.choice(sorted_archive[:candidate_indices])[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + n // 4, n - 1))\n\n    # Extract the segment and reverse it (with probability 0.7)\n    if random.random() < 0.7:\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n    # Randomly swap two edges with probability 0.5\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply a randomized 3-opt move with probability 0.3\n    if random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This heuristic selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and a novel \"objective-aware\" swap operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / (max_obj + 1e-10)  # Avoid division by zero\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion with objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations\n        # Edge insertion step\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n        # Objective-aware swap step\n        for _ in range(3):  # Try multiple swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            temp = new_solution.copy()\n            temp[a], temp[b] = temp[b], temp[a]\n\n            # Calculate new objective values\n            def calc_cost(sol, dist_mat):\n                cost = 0\n                for k in range(n):\n                    cost += dist_mat[sol[k-1], sol[k]]\n                return cost\n\n            new_cost1 = calc_cost(temp, distance_matrix_1)\n            new_cost2 = calc_cost(temp, distance_matrix_2)\n            old_cost1 = calc_cost(new_solution, distance_matrix_1)\n            old_cost2 = calc_cost(new_solution, distance_matrix_2)\n\n            # Accept if at least one objective improves\n            if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n                new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9193350311677404,
            1.6174613237380981
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / (max_obj + 1e-10)  # Avoid division by zero\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion with objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations\n        # Edge insertion step\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n        # Objective-aware swap step\n        for _ in range(3):  # Try multiple swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            temp = new_solution.copy()\n            temp[a], temp[b] = temp[b], temp[a]\n\n            # Calculate new objective values\n            def calc_cost(sol, dist_mat):\n                cost = 0\n                for k in range(n):\n                    cost += dist_mat[sol[k-1], sol[k]]\n                return cost\n\n            new_cost1 = calc_cost(temp, distance_matrix_1)\n            new_cost2 = calc_cost(temp, distance_matrix_2)\n            old_cost1 = calc_cost(new_solution, distance_matrix_1)\n            old_cost2 = calc_cost(new_solution, distance_matrix_2)\n\n            # Accept if at least one objective improves\n            if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n                new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9385255765108426,
            0.15871524810791016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9385255765108426,
            0.15871524810791016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Reverse a random segment\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random edge elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Step 3: Novel segment swapping mechanism\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.882851551125476,
            0.2649860382080078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Reverse a random segment\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random edge elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Step 3: Novel segment swapping mechanism\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment shifting\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:], segment])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.875841186748316,
            0.21241194009780884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment shifting\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:], segment])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects the best solution from the archive based on combined objective values, then generates a neighbor by performing a segment reversal and edge swap within a randomly chosen segment, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8513804776516646,
            0.25770288705825806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)  # Simple diversity-aware selection\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search combining segment reversal and distance-aware node insertion\n    n = len(new_solution)\n\n    # Segment reversal with distance-based selection\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the gain in both objectives for the reversal\n    gain1 = (distance_matrix_1[new_solution[start-1], reversed_segment[0]] +\n             distance_matrix_1[reversed_segment[-1], new_solution[(end+1)%n]] -\n             distance_matrix_1[new_solution[start-1], segment[0]] -\n             distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n\n    gain2 = (distance_matrix_2[new_solution[start-1], reversed_segment[0]] +\n             distance_matrix_2[reversed_segment[-1], new_solution[(end+1)%n]] -\n             distance_matrix_2[new_solution[start-1], segment[0]] -\n             distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n    if gain1 + gain2 < 0:  # Only accept if it improves at least one objective\n        new_solution[start:end+1] = reversed_segment\n\n    # Distance-aware node insertion\n    i = random.randint(0, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    best_pos = i\n    best_gain = 0\n\n    for j in range(n-1):\n        if j == i or j == (i-1)%(n-1):\n            continue\n        gain1 = (distance_matrix_1[new_solution[j-1], node] +\n                 distance_matrix_1[node, new_solution[j]] -\n                 distance_matrix_1[new_solution[j-1], new_solution[j]])\n\n        gain2 = (distance_matrix_2[new_solution[j-1], node] +\n                 distance_matrix_2[node, new_solution[j]] -\n                 distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        if gain1 + gain2 < best_gain:\n            best_gain = gain1 + gain2\n            best_pos = j\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5881118259877218,
            2.347015142440796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)  # Simple diversity-aware selection\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search combining segment reversal and distance-aware node insertion\n    n = len(new_solution)\n\n    # Segment reversal with distance-based selection\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the gain in both objectives for the reversal\n    gain1 = (distance_matrix_1[new_solution[start-1], reversed_segment[0]] +\n             distance_matrix_1[reversed_segment[-1], new_solution[(end+1)%n]] -\n             distance_matrix_1[new_solution[start-1], segment[0]] -\n             distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n\n    gain2 = (distance_matrix_2[new_solution[start-1], reversed_segment[0]] +\n             distance_matrix_2[reversed_segment[-1], new_solution[(end+1)%n]] -\n             distance_matrix_2[new_solution[start-1], segment[0]] -\n             distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n    if gain1 + gain2 < 0:  # Only accept if it improves at least one objective\n        new_solution[start:end+1] = reversed_segment\n\n    # Distance-aware node insertion\n    i = random.randint(0, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    best_pos = i\n    best_gain = 0\n\n    for j in range(n-1):\n        if j == i or j == (i-1)%(n-1):\n            continue\n        gain1 = (distance_matrix_1[new_solution[j-1], node] +\n                 distance_matrix_1[node, new_solution[j]] -\n                 distance_matrix_1[new_solution[j-1], new_solution[j]])\n\n        gain2 = (distance_matrix_2[new_solution[j-1], node] +\n                 distance_matrix_2[node, new_solution[j]] -\n                 distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        if gain1 + gain2 < best_gain:\n            best_gain = gain1 + gain2\n            best_pos = j\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a base solution from the archive, applies a dynamic segment reversal with probabilistic edge swaps, and ensures feasibility by validating uniqueness of nodes in the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n        weights = np.array(weights) / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection with probability based on segment quality\n    segment_length = min(5, n // 2)\n    i = np.random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Probabilistic segment reversal with edge swap\n    if np.random.random() < 0.7:\n        new_solution[i:j] = new_solution[i:j][::-1]\n        if j - i > 2 and np.random.random() < 0.5:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.713235740077062,
            0.3791669011116028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n        weights = np.array(weights) / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection with probability based on segment quality\n    segment_length = min(5, n // 2)\n    i = np.random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Probabilistic segment reversal with edge swap\n    if np.random.random() < 0.7:\n        new_solution[i:j] = new_solution[i:j][::-1]\n        if j - i > 2 and np.random.random() < 0.5:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9776489543137526,
            0.2548694610595703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9776489543137526,
            0.2548694610595703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply a novel local search operator: edge insertion with path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert a randomly selected node at a different position\n    if j - i > 1:\n        k = np.random.randint(0, n)\n        new_node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, new_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.816755930218726,
            0.3615557551383972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply a novel local search operator: edge insertion with path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert a randomly selected node at a different position\n    if j - i > 1:\n        k = np.random.randint(0, n)\n        new_node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, new_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = min(4, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Rotate segment left by a random amount\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.roll(new_solution[start:end], -rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Adaptive edge flipping based on distance matrices\n    flip_prob = 0.3\n    for i in range(n):\n        if np.random.random() < flip_prob:\n            # Flip edge based on which objective space has higher distance\n            if distance_matrix_1[new_solution[i-1], new_solution[i]] > distance_matrix_2[new_solution[i-1], new_solution[i]]:\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8033682796714857,
            0.32925546169281006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = min(4, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Rotate segment left by a random amount\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.roll(new_solution[start:end], -rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Adaptive edge flipping based on distance matrices\n    flip_prob = 0.3\n    for i in range(n):\n        if np.random.random() < flip_prob:\n            # Flip edge based on which objective space has higher distance\n            if distance_matrix_1[new_solution[i-1], new_solution[i]] > distance_matrix_2[new_solution[i-1], new_solution[i]]:\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)\n    avg_objectives = np.mean(normalized_obj, axis=1)\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine node swap with path inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly swap two nodes to disrupt local optima\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment to explore alternative paths\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[l:k-1 if k > 0 else None:-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8045379330831355,
            0.2620276212692261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)\n    avg_objectives = np.mean(normalized_obj, axis=1)\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine node swap with path inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly swap two nodes to disrupt local optima\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment to explore alternative paths\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[l:k-1 if k > 0 else None:-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply a novel edge swap strategy\n    if j - i > 1:\n        # Reverse a segment and swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Swap two non-adjacent edges\n        if j - i > 2:\n            k = np.random.randint(i+1, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Path relinking: combine segments from multiple archive solutions\n    n = len(new_solution)\n    if len(archive) > 1:\n        # Select a random solution from the archive\n        other_solution = random.choice([x[0] for x in archive if not np.array_equal(x[0], base_solution)])\n\n        # Find common segments between the two solutions\n        i, j = 0, 0\n        while i < n and j < n:\n            if base_solution[i] == other_solution[j]:\n                # When a common node is found, try to align segments\n                k = i\n                while k < n and j + (k - i) < n and base_solution[k] == other_solution[j + (k - i)]:\n                    k += 1\n                if k - i > 1:  # If segment length > 1, perform relinking\n                    # Insert the segment from the other solution into the base solution\n                    segment = other_solution[j:j + (k - i)]\n                    new_solution = np.concatenate([base_solution[:i], segment, base_solution[k:]])\n                    break\n                i += 1\n                j += 1\n            else:\n                i += 1\n                j += 1\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8526964464237745,
            6.538549780845642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Path relinking: combine segments from multiple archive solutions\n    n = len(new_solution)\n    if len(archive) > 1:\n        # Select a random solution from the archive\n        other_solution = random.choice([x[0] for x in archive if not np.array_equal(x[0], base_solution)])\n\n        # Find common segments between the two solutions\n        i, j = 0, 0\n        while i < n and j < n:\n            if base_solution[i] == other_solution[j]:\n                # When a common node is found, try to align segments\n                k = i\n                while k < n and j + (k - i) < n and base_solution[k] == other_solution[j + (k - i)]:\n                    k += 1\n                if k - i > 1:  # If segment length > 1, perform relinking\n                    # Insert the segment from the other solution into the base solution\n                    segment = other_solution[j:j + (k - i)]\n                    new_solution = np.concatenate([base_solution[:i], segment, base_solution[k:]])\n                    break\n                i += 1\n                j += 1\n            else:\n                i += 1\n                j += 1\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm uses a hybrid approach combining edge insertion with a novel segment rotation operator to generate diverse neighbors while maintaining feasibility, prioritizing solutions with high potential for improvement based on their normalized objective values.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)\n    selection_probs = np.mean(normalized_obj, axis=1)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion with segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment rotation (novel operator)\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[k:l+1]\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    new_solution[k:l+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8520588590364719,
            0.32097333669662476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)\n    selection_probs = np.mean(normalized_obj, axis=1)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion with segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment rotation (novel operator)\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[k:l+1]\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    new_solution[k:l+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The new algorithm combines a biased selection strategy based on objective normalization with a hybrid local search that alternates between random edge swaps and segment rotations, while incorporating distance-aware perturbations to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with lower combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge swaps and segment rotations\n    for _ in range(2):  # Perform two operations\n        if random.random() < 0.5:\n            # Edge swap: randomly select two non-adjacent edges and swap them\n            a, b = sorted(random.sample(range(n), 2))\n            while b - a <= 1:  # Ensure edges are not adjacent\n                a, b = sorted(random.sample(range(n), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Segment rotation: rotate a random segment by a random amount\n            k, l = sorted(random.sample(range(n), 2))\n            segment = new_solution[k:l+1]\n            rotation = random.randint(1, len(segment)-1)\n            rotated = np.roll(segment, rotation)\n            new_solution[k:l+1] = rotated\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8619102095348554,
            0.24485445022583008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with lower combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge swaps and segment rotations\n    for _ in range(2):  # Perform two operations\n        if random.random() < 0.5:\n            # Edge swap: randomly select two non-adjacent edges and swap them\n            a, b = sorted(random.sample(range(n), 2))\n            while b - a <= 1:  # Ensure edges are not adjacent\n                a, b = sorted(random.sample(range(n), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Segment rotation: rotate a random segment by a random amount\n            k, l = sorted(random.sample(range(n), 2))\n            segment = new_solution[k:l+1]\n            rotation = random.randint(1, len(segment)-1)\n            rotated = np.roll(segment, rotation)\n            new_solution[k:l+1] = rotated\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This algorithm selects a solution from the archive, performs a hybrid local search by combining segment reversal and edge swapping, and ensures feasibility while prioritizing solutions with better objective values.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Swap two edges\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and abs(k - l) > 1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9333986544600332,
            0.24730229377746582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Swap two edges\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and abs(k - l) > 1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The new algorithm combines segment rotation with a hybrid of edge swapping and node insertion, guided by objective-specific distance metrics to prioritize improvements in both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation + edge swap + node insertion\n    if n > 3:\n        # Segment rotation\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n        # Edge swap with distance metric consideration\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            # Evaluate swap in both objective spaces\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if improves at least one objective\n            if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Node insertion guided by distance metrics\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n\n        # Evaluate insertion in both spaces\n        prev_node = new_solution[insert_pos-1] if insert_pos > 0 else new_solution[-1]\n        next_node = new_solution[insert_pos] if insert_pos < len(new_solution) else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, next_node]\n        new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Accept if improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6718626699959369,
            3.884937286376953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation + edge swap + node insertion\n    if n > 3:\n        # Segment rotation\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n        # Edge swap with distance metric consideration\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            # Evaluate swap in both objective spaces\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if improves at least one objective\n            if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Node insertion guided by distance metrics\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n\n        # Evaluate insertion in both spaces\n        prev_node = new_solution[insert_pos-1] if insert_pos > 0 else new_solution[-1]\n        next_node = new_solution[insert_pos] if insert_pos < len(new_solution) else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, next_node]\n        new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Accept if improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Reverse a random segment\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a random edge elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Step 3: Novel segment swapping mechanism\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel local search strategy that combines segment reversal, edge insertion, and adaptive segment swapping, guided by objective-specific distance matrices to prioritize improvements in both spaces while maintaining tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current tour lengths\n    def calculate_tour_length(sol, dist_matrix):\n        return sum(dist_matrix[sol[i], sol[(i+1)%n]] for i in range(n))\n\n    current_length1 = calculate_tour_length(new_solution, distance_matrix_1)\n    current_length2 = calculate_tour_length(new_solution, distance_matrix_2)\n\n    # Hybrid local search strategy\n    # Step 1: Reverse a segment that improves at least one objective\n    for _ in range(10):\n        start, end = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[start:end+1] = temp_solution[start:end+1][::-1]\n        new_length1 = calculate_tour_length(temp_solution, distance_matrix_1)\n        new_length2 = calculate_tour_length(temp_solution, distance_matrix_2)\n        if (new_length1 <= current_length1 and new_length2 <= current_length2) and \\\n           (new_length1 < current_length1 or new_length2 < current_length2):\n            new_solution = temp_solution\n            current_length1, current_length2 = new_length1, new_length2\n            break\n\n    # Step 2: Insert a node between its two neighbors if it improves both objectives\n    for _ in range(10):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        neighbors = [new_solution[(node_pos-1)%n], new_solution[(node_pos+1)%n]]\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        temp_solution = np.insert(temp_solution, insert_pos, node)\n        new_length1 = calculate_tour_length(temp_solution, distance_matrix_1)\n        new_length2 = calculate_tour_length(temp_solution, distance_matrix_2)\n        if new_length1 < current_length1 and new_length2 < current_length2:\n            new_solution = temp_solution\n            current_length1, current_length2 = new_length1, new_length2\n            break\n\n    # Step 3: Swap two non-adjacent edges if it improves at least one objective\n    for _ in range(10):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            new_length1 = calculate_tour_length(temp_solution, distance_matrix_1)\n            new_length2 = calculate_tour_length(temp_solution, distance_matrix_2)\n            if (new_length1 <= current_length1 and new_length2 <= current_length2) and \\\n               (new_length1 < current_length1 or new_length2 < current_length2):\n                new_solution = temp_solution\n                current_length1, current_length2 = new_length1, new_length2\n                break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4746519650563714,
            4.055757522583008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current tour lengths\n    def calculate_tour_length(sol, dist_matrix):\n        return sum(dist_matrix[sol[i], sol[(i+1)%n]] for i in range(n))\n\n    current_length1 = calculate_tour_length(new_solution, distance_matrix_1)\n    current_length2 = calculate_tour_length(new_solution, distance_matrix_2)\n\n    # Hybrid local search strategy\n    # Step 1: Reverse a segment that improves at least one objective\n    for _ in range(10):\n        start, end = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[start:end+1] = temp_solution[start:end+1][::-1]\n        new_length1 = calculate_tour_length(temp_solution, distance_matrix_1)\n        new_length2 = calculate_tour_length(temp_solution, distance_matrix_2)\n        if (new_length1 <= current_length1 and new_length2 <= current_length2) and \\\n           (new_length1 < current_length1 or new_length2 < current_length2):\n            new_solution = temp_solution\n            current_length1, current_length2 = new_length1, new_length2\n            break\n\n    # Step 2: Insert a node between its two neighbors if it improves both objectives\n    for _ in range(10):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        neighbors = [new_solution[(node_pos-1)%n], new_solution[(node_pos+1)%n]]\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        temp_solution = np.insert(temp_solution, insert_pos, node)\n        new_length1 = calculate_tour_length(temp_solution, distance_matrix_1)\n        new_length2 = calculate_tour_length(temp_solution, distance_matrix_2)\n        if new_length1 < current_length1 and new_length2 < current_length2:\n            new_solution = temp_solution\n            current_length1, current_length2 = new_length1, new_length2\n            break\n\n    # Step 3: Swap two non-adjacent edges if it improves at least one objective\n    for _ in range(10):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            new_length1 = calculate_tour_length(temp_solution, distance_matrix_1)\n            new_length2 = calculate_tour_length(temp_solution, distance_matrix_2)\n            if (new_length1 <= current_length1 and new_length2 <= current_length2) and \\\n               (new_length1 < current_length1 or new_length2 < current_length2):\n                new_solution = temp_solution\n                current_length1, current_length2 = new_length1, new_length2\n                break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9636224453291041,
            0.24373972415924072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Swap two edges with high cross-objective distance\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and abs(distance_matrix_1[k, l] - distance_matrix_2[k, l]) > 1.0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8938350329290163,
            0.3175851106643677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Swap two edges with high cross-objective distance\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and abs(distance_matrix_1[k, l] - distance_matrix_2[k, l]) > 1.0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The new algorithm selects a promising solution from the archive based on a hybrid objective score, then applies a novel local search combining adaptive edge swapping with a probabilistic segment inversion to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.7] if random.random() > 0.5 else [0.7, 0.3]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge swapping with probabilistic segment inversion\n    if random.random() > 0.5:\n        # Adaptive edge swapping\n        i, j, k = random.sample(range(n), 3)\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        new_segment = np.concatenate([segment[:k-i], segment[k-i:]])\n        new_solution = np.concatenate([new_solution[:i], new_segment, new_solution[j+1:]])\n    else:\n        # Probabilistic segment inversion\n        start = random.randint(0, n-1)\n        length = min(random.randint(2, n//2), n - start)\n        new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8737491190489579,
            0.7073659300804138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.7] if random.random() > 0.5 else [0.7, 0.3]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge swapping with probabilistic segment inversion\n    if random.random() > 0.5:\n        # Adaptive edge swapping\n        i, j, k = random.sample(range(n), 3)\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        new_segment = np.concatenate([segment[:k-i], segment[k-i:]])\n        new_solution = np.concatenate([new_solution[:i], new_segment, new_solution[j+1:]])\n    else:\n        # Probabilistic segment inversion\n        start = random.randint(0, n-1)\n        length = min(random.randint(2, n//2), n - start)\n        new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated += 1\n        scores.append(dominated)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment reversal followed by insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start = random.randint(0, n-1)\n    length = random.randint(2, min(5, n//2))\n    end = min(start + length, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:], [node]])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7361213965304476,
            0.2651606798171997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated += 1\n        scores.append(dominated)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment reversal followed by insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start = random.randint(0, n-1)\n    length = random.randint(2, min(5, n//2))\n    end = min(start + length, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:], [node]])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9346381425365083,
            0.22937440872192383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a biased selection strategy based on objective normalization with a hybrid local search that alternates between random edge swaps and segment rotations, while incorporating distance-aware perturbations to explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with lower combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge swaps and segment rotations\n    for _ in range(2):  # Perform two operations\n        if random.random() < 0.5:\n            # Edge swap: randomly select two non-adjacent edges and swap them\n            a, b = sorted(random.sample(range(n), 2))\n            while b - a <= 1:  # Ensure edges are not adjacent\n                a, b = sorted(random.sample(range(n), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Segment rotation: rotate a random segment by a random amount\n            k, l = sorted(random.sample(range(n), 2))\n            segment = new_solution[k:l+1]\n            rotation = random.randint(1, len(segment)-1)\n            rotated = np.roll(segment, rotation)\n            new_solution[k:l+1] = rotated\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The new algorithm employs a diversity-aware selection strategy that combines objective normalization with a hybrid local search featuring alternating edge reversals and segment inversions, while incorporating adaptive perturbation strengths to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: select based on normalized objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.array([np.std(normalized[i]) for i in range(len(archive))])\n    combined_scores = np.sum(normalized, axis=1) * (1 + diversity_scores)\n    selection_probs = np.exp(-combined_scores / np.sum(combined_scores))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge reversals and segment inversions\n    for _ in range(2):\n        if random.random() < 0.5:\n            # Edge reversal: reverse a segment between two random nodes\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Segment inversion: invert a random segment\n            k, l = sorted(random.sample(range(n), 2))\n            segment = new_solution[k:l+1]\n            inversion = segment[::-1]\n            new_solution[k:l+1] = inversion\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9211922795089343,
            0.5589802265167236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: select based on normalized objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.array([np.std(normalized[i]) for i in range(len(archive))])\n    combined_scores = np.sum(normalized, axis=1) * (1 + diversity_scores)\n    selection_probs = np.exp(-combined_scores / np.sum(combined_scores))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge reversals and segment inversions\n    for _ in range(2):\n        if random.random() < 0.5:\n            # Edge reversal: reverse a segment between two random nodes\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Segment inversion: invert a random segment\n            k, l = sorted(random.sample(range(n), 2))\n            segment = new_solution[k:l+1]\n            inversion = segment[::-1]\n            new_solution[k:l+1] = inversion\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective selection strategy with a dynamic edge relocation and segment inversion operator to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective selection with dynamic weighting\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weighted_scores = np.dot(normalized_obj, weights)\n    selection_probs = np.exp(weighted_scores - np.max(weighted_scores))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge relocation\n    if n > 3:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(remaining) - segment_length + 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment inversion with adaptive length\n    if n > 4:\n        inv_length = random.randint(2, min(4, n//3))\n        start_pos = random.randint(0, n - inv_length)\n        new_solution[start_pos:start_pos+inv_length] = new_solution[start_pos:start_pos+inv_length][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8555211120944426,
            0.26011931896209717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective selection with dynamic weighting\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weighted_scores = np.dot(normalized_obj, weights)\n    selection_probs = np.exp(weighted_scores - np.max(weighted_scores))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge relocation\n    if n > 3:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(remaining) - segment_length + 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment inversion with adaptive length\n    if n > 4:\n        inv_length = random.randint(2, min(4, n//3))\n        start_pos = random.randint(0, n - inv_length)\n        new_solution[start_pos:start_pos+inv_length] = new_solution[start_pos:start_pos+inv_length][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, obj2 in archive:\n            if (obj2[0] <= obj[0] and obj2[1] <= obj[1]) and (obj2[0] < obj[0] or obj2[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Select a solution from the Pareto front with probability proportional to its normalized objective values\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * (obj[0] / (obj[0] + obj[1])) + weights[1] * (obj[1] / (obj[0] + obj[1])) for _, obj in pareto_front]\n    selected_idx = random.choices(range(len(pareto_front)), weights=scores)[0]\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Apply a hybrid local search strategy combining segment reversal and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8700144031244983,
            0.2837737202644348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, obj2 in archive:\n            if (obj2[0] <= obj[0] and obj2[1] <= obj[1]) and (obj2[0] < obj[0] or obj2[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Select a solution from the Pareto front with probability proportional to its normalized objective values\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * (obj[0] / (obj[0] + obj[1])) + weights[1] * (obj[1] / (obj[0] + obj[1])) for _, obj in pareto_front]\n    selected_idx = random.choices(range(len(pareto_front)), weights=scores)[0]\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Apply a hybrid local search strategy combining segment reversal and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment shifting\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:], segment])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The new algorithm combines adaptive segment reversal with cross-oversectional edge exchange, prioritizing non-dominated solutions and using distance matrices to guide segment selection and insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [s for s in archive if not any((s[1][0] > o[0] and s[1][1] >= o[1]) or (s[1][0] >= o[0] and s[1][1] > o[1]) for _, o in archive)]\n    if not non_dominated:\n        non_dominated = archive\n    selected_idx = np.random.choice(len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal based on distance matrices\n    i = np.random.randint(0, n)\n    segment_length = min(4, n // 2)\n    j = min(n, i + segment_length)\n\n    # Reverse the segment if it improves both objectives\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n    new_solution[i:j] = reversed_segment\n\n    # Cross-oversectional edge exchange\n    k = np.random.randint(0, n)\n    l = (k + n // 3) % n\n\n    # Calculate potential improvement using distance matrices\n    original_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    original_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7167162184020901,
            1.5202265977859497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [s for s in archive if not any((s[1][0] > o[0] and s[1][1] >= o[1]) or (s[1][0] >= o[0] and s[1][1] > o[1]) for _, o in archive)]\n    if not non_dominated:\n        non_dominated = archive\n    selected_idx = np.random.choice(len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal based on distance matrices\n    i = np.random.randint(0, n)\n    segment_length = min(4, n // 2)\n    j = min(n, i + segment_length)\n\n    # Reverse the segment if it improves both objectives\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n    new_solution[i:j] = reversed_segment\n\n    # Cross-oversectional edge exchange\n    k = np.random.randint(0, n)\n    l = (k + n // 3) % n\n\n    # Calculate potential improvement using distance matrices\n    original_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    original_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment shifting\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:], segment])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal followed by insertion\n    if n > 3:\n        # Select two random segments\n        i, j = sorted(random.sample(range(n-1), 2))\n        k, l = sorted(random.sample(range(n-1), 2))\n\n        # Reverse segment between i and j\n        segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = segment\n\n        # Insert segment between k and k+1\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:l+1], new_solution[l+1:]])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8127070281032251,
            3.58954256772995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal followed by insertion\n    if n > 3:\n        # Select two random segments\n        i, j = sorted(random.sample(range(n-1), 2))\n        k, l = sorted(random.sample(range(n-1), 2))\n\n        # Reverse segment between i and j\n        segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = segment\n\n        # Insert segment between k and k+1\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:l+1], new_solution[l+1:]])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a solution from the archive based on the combined objective values, then applies a hybrid local search combining edge swaps with a novel segment reversal and insertion strategy to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / (objectives.max(axis=0) - objectives.min(axis=0))\n        weights = 1 / (1 + normalized.sum(axis=1))\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swap with segment reversal and insertion\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Swap edges if it improves at least one objective\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Calculate current and new costs\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(n):\n            cost += distance_matrix[solution[k], solution[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) and not (new_cost1 == current_cost1 and new_cost2 == current_cost2):\n        new_solution = temp_solution.copy()\n\n    # Segment reversal and insertion\n    if j - i > 2:\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n        # Insert a randomly selected node from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.908170954581698,
            0.27518266439437866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / (objectives.max(axis=0) - objectives.min(axis=0))\n        weights = 1 / (1 + normalized.sum(axis=1))\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swap with segment reversal and insertion\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Swap edges if it improves at least one objective\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Calculate current and new costs\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(n):\n            cost += distance_matrix[solution[k], solution[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) and not (new_cost1 == current_cost1 and new_cost2 == current_cost2):\n        new_solution = temp_solution.copy()\n\n    # Segment reversal and insertion\n    if j - i > 2:\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n        # Insert a randomly selected node from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, where the second objective is given higher weight, and applies a novel local search strategy combining segment rotation, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two non-adjacent nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9091257443573845,
            0.2560575604438782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two non-adjacent nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a biased selection strategy based on objective normalization with a hybrid local search that alternates between random edge swaps and segment rotations, while incorporating distance-aware perturbations to explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with lower combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge swaps and segment rotations\n    for _ in range(2):  # Perform two operations\n        if random.random() < 0.5:\n            # Edge swap: randomly select two non-adjacent edges and swap them\n            a, b = sorted(random.sample(range(n), 2))\n            while b - a <= 1:  # Ensure edges are not adjacent\n                a, b = sorted(random.sample(range(n), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Segment rotation: rotate a random segment by a random amount\n            k, l = sorted(random.sample(range(n), 2))\n            segment = new_solution[k:l+1]\n            rotation = random.randint(1, len(segment)-1)\n            rotated = np.roll(segment, rotation)\n            new_solution[k:l+1] = rotated\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9519109771993026,
            0.24251556396484375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm selects a solution from the archive based on the Pareto dominance status of solutions, then applies a hybrid local search combining node swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for idx, (sol, obj) in enumerate(archive):\n        dominated = False\n        for _, obj2 in archive:\n            if (obj2[0] <= obj[0] and obj2[1] <= obj[1]) and (obj2[0] < obj[0] or obj2[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((idx, obj))\n\n    if pareto_front:\n        selected_idx = random.choice([idx for idx, _ in pareto_front])\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swapping and segment relocation\n    if n > 3:\n        # Node swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 4, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9172396124681959,
            0.3001088500022888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for idx, (sol, obj) in enumerate(archive):\n        dominated = False\n        for _, obj2 in archive:\n            if (obj2[0] <= obj[0] and obj2[1] <= obj[1]) and (obj2[0] < obj[0] or obj2[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((idx, obj))\n\n    if pareto_front:\n        selected_idx = random.choice([idx for idx, _ in pareto_front])\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swapping and segment relocation\n    if n > 3:\n        # Node swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 4, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node insertion, segment reversal, and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.sum(normalized, axis=1) + 1e-10)\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion, segment reversal, and edge inversion\n    if n > 3:\n        # Step 1: Node insertion (move a random node to a new position)\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Step 3: Edge inversion (invert two adjacent edges)\n        pos = random.randint(0, n-3)\n        new_solution[pos], new_solution[pos+2] = new_solution[pos+2], new_solution[pos]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9400943291074496,
            0.24993586540222168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.sum(normalized, axis=1) + 1e-10)\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion, segment reversal, and edge inversion\n    if n > 3:\n        # Step 1: Node insertion (move a random node to a new position)\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Step 3: Edge inversion (invert two adjacent edges)\n        pos = random.randint(0, n-3)\n        new_solution[pos], new_solution[pos+2] = new_solution[pos+2], new_solution[pos]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining segment reversal and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9389810683205255,
            0.2903497815132141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining segment reversal and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining node swapping and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and \\\n               (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and \\\n                 (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated_counts[i] += 1\n\n    current_front = [i for i in range(len(archive)) if dominated_counts[i] == 0]\n    fronts.append(current_front)\n\n    while current_front:\n        next_front = []\n        for i in current_front:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        if next_front:\n            fronts.append(next_front)\n        current_front = next_front\n\n    # Select from the first non-dominated front\n    selected_idx = random.choice(fronts[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swapping and segment rotation\n    n = len(new_solution)\n    if n > 2:\n        # Node swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment rotation\n        k = random.randint(2, min(5, n-1))\n        segment = new_solution[:k]\n        rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n        new_solution[:k] = rotated_segment\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8190683180480567,
            0.3551805019378662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and \\\n               (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and \\\n                 (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated_counts[i] += 1\n\n    current_front = [i for i in range(len(archive)) if dominated_counts[i] == 0]\n    fronts.append(current_front)\n\n    while current_front:\n        next_front = []\n        for i in current_front:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        if next_front:\n            fronts.append(next_front)\n        current_front = next_front\n\n    # Select from the first non-dominated front\n    selected_idx = random.choice(fronts[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swapping and segment rotation\n    n = len(new_solution)\n    if n > 2:\n        # Node swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment rotation\n        k = random.randint(2, min(5, n-1))\n        segment = new_solution[:k]\n        rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n        new_solution[:k] = rotated_segment\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a biased selection strategy based on objective normalization with a hybrid local search that alternates between random edge swaps and segment rotations, while incorporating distance-aware perturbations to explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with lower combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge swaps and segment rotations\n    for _ in range(2):  # Perform two operations\n        if random.random() < 0.5:\n            # Edge swap: randomly select two non-adjacent edges and swap them\n            a, b = sorted(random.sample(range(n), 2))\n            while b - a <= 1:  # Ensure edges are not adjacent\n                a, b = sorted(random.sample(range(n), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Segment rotation: rotate a random segment by a random amount\n            k, l = sorted(random.sample(range(n), 2))\n            segment = new_solution[k:l+1]\n            rotation = random.randint(1, len(segment)-1)\n            rotated = np.roll(segment, rotation)\n            new_solution[k:l+1] = rotated\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This new algorithm combines a dominance-based selection strategy with a hybrid local search that alternates between distance-aware edge insertions and segment reversals, while incorporating adaptive perturbation based on the solution's objective values to explore the Pareto frontier more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions with lower combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated[i] = True\n                break\n    non_dominated = np.where(~dominated)[0]\n\n    if len(non_dominated) > 0:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        combined = np.sum(objectives, axis=1)\n        selected_idx = np.argmin(combined)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge insertions and segment reversals\n    for _ in range(3):  # Perform three operations\n        if random.random() < 0.5:\n            # Distance-aware edge insertion: select a node and insert it after its closest neighbor\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            neighbors = [new_solution[(node_pos + i) % n] for i in [-1, 1]]\n            distances = [\n                distance_matrix_1[node, neighbors[0]] + distance_matrix_2[node, neighbors[0]],\n                distance_matrix_1[node, neighbors[1]] + distance_matrix_2[node, neighbors[1]]\n            ]\n            best_neighbor_pos = (node_pos - 1) % n if distances[0] < distances[1] else (node_pos + 1) % n\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = (best_neighbor_pos + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            # Segment reversal: reverse a random segment\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8724664937685833,
            0.6763530969619751
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions with lower combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated[i] = True\n                break\n    non_dominated = np.where(~dominated)[0]\n\n    if len(non_dominated) > 0:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        combined = np.sum(objectives, axis=1)\n        selected_idx = np.argmin(combined)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge insertions and segment reversals\n    for _ in range(3):  # Perform three operations\n        if random.random() < 0.5:\n            # Distance-aware edge insertion: select a node and insert it after its closest neighbor\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            neighbors = [new_solution[(node_pos + i) % n] for i in [-1, 1]]\n            distances = [\n                distance_matrix_1[node, neighbors[0]] + distance_matrix_2[node, neighbors[0]],\n                distance_matrix_1[node, neighbors[1]] + distance_matrix_2[node, neighbors[1]]\n            ]\n            best_neighbor_pos = (node_pos - 1) % n if distances[0] < distances[1] else (node_pos + 1) % n\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = (best_neighbor_pos + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            # Segment reversal: reverse a random segment\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective ratio, then applies a hybrid local search combining segment reversal and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    weights = mean_obj / (np.sum(mean_obj) + 1e-6)\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge swapping with distance consideration\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8245134170157862,
            0.23224025964736938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    weights = mean_obj / (np.sum(mean_obj) + 1e-6)\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge swapping with distance consideration\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    var1, var2 = np.var(obj1), np.var(obj2)\n    weights = [var2 / (var1 + var2), var1 / (var1 + var2)] if (var1 + var2) > 0 else [0.5, 0.5]\n\n    # Select solution based on weighted sum of objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment reversal with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge exchange\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8338418269952956,
            0.24342882633209229
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    var1, var2 = np.var(obj1), np.var(obj2)\n    weights = [var2 / (var1 + var2), var1 / (var1 + var2)] if (var1 + var2) > 0 else [0.5, 0.5]\n\n    # Select solution based on weighted sum of objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment reversal with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge exchange\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a selection probability distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    selection_probs = np.mean(normalized_obj, axis=1)  # Average normalized objectives\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment to improve local structure)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{The new algorithm combines adaptive segment rotation with multi-objective-aware edge swapping to generate high-quality neighbors by intelligently selecting and modifying segments based on both objectives' improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)\n    improvement_potential = 1 - np.mean(normalized_obj, axis=1)\n    selection_probs = improvement_potential / np.sum(improvement_potential)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment rotation\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Rotate segment based on which objective shows more potential for improvement\n    obj1_improvement = np.sum(distance_matrix_1[segment, segment]) - np.sum(distance_matrix_1[segment[:-1], segment[1:]])\n    obj2_improvement = np.sum(distance_matrix_2[segment, segment]) - np.sum(distance_matrix_2[segment[:-1], segment[1:]])\n\n    if obj1_improvement > obj2_improvement:\n        rotated_segment = np.roll(segment, 1)\n    else:\n        rotated_segment = np.roll(segment, -1)\n\n    new_solution[i:j] = rotated_segment\n\n    # Multi-objective edge swapping\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l:\n        # Calculate potential improvement for both objectives\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]])\n        swapped_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]])\n\n        if swapped_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8825413399769909,
            0.4006253480911255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.sum(objectives, axis=0) + 1e-10)\n    improvement_potential = 1 - np.mean(normalized_obj, axis=1)\n    selection_probs = improvement_potential / np.sum(improvement_potential)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment rotation\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Rotate segment based on which objective shows more potential for improvement\n    obj1_improvement = np.sum(distance_matrix_1[segment, segment]) - np.sum(distance_matrix_1[segment[:-1], segment[1:]])\n    obj2_improvement = np.sum(distance_matrix_2[segment, segment]) - np.sum(distance_matrix_2[segment[:-1], segment[1:]])\n\n    if obj1_improvement > obj2_improvement:\n        rotated_segment = np.roll(segment, 1)\n    else:\n        rotated_segment = np.roll(segment, -1)\n\n    new_solution[i:j] = rotated_segment\n\n    # Multi-objective edge swapping\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l:\n        # Calculate potential improvement for both objectives\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]])\n        swapped_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]])\n\n        if swapped_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a novel local search operator combining node insertion with guided path optimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 1: Select a random node to relocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Step 2: Remove the node from the tour\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Step 3: Find the best insertion position considering both distance matrices\n        min_cost = float('inf')\n        best_pos = 0\n\n        for i in range(n-1):\n            # Calculate cost for inserting after position i\n            cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[(i+1)%(n-1)]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]]\n            cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[(i+1)%(n-1)]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i + 1\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.5130232208283233,
            2.541121542453766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 1: Select a random node to relocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Step 2: Remove the node from the tour\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Step 3: Find the best insertion position considering both distance matrices\n        min_cost = float('inf')\n        best_pos = 0\n\n        for i in range(n-1):\n            # Calculate cost for inserting after position i\n            cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[(i+1)%(n-1)]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]]\n            cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[(i+1)%(n-1)]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i + 1\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Identify critical nodes (high contribution to both objectives)\n    critical_nodes = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        if cost1 > np.percentile(distance_matrix_1, 75) or cost2 > np.percentile(distance_matrix_2, 75):\n            critical_nodes.append(i)\n\n    # Phase 2: Multi-phase local search\n    if critical_nodes:\n        # Randomly select a critical node and perform targeted operations\n        target = np.random.choice(critical_nodes)\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Operation 1: Swap critical node with another node\n        new_solution[target], new_solution[a] = new_solution[a], new_solution[target]\n\n        # Operation 2: Reverse a segment around the critical node\n        segment_size = min(5, n//2)\n        start = max(0, target - segment_size//2)\n        end = min(n, target + segment_size//2 + 1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Operation 3: Insert a random edge from another part of the tour\n        if n > 3:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            edge = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9069316909139904,
            2.678797125816345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Identify critical nodes (high contribution to both objectives)\n    critical_nodes = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        if cost1 > np.percentile(distance_matrix_1, 75) or cost2 > np.percentile(distance_matrix_2, 75):\n            critical_nodes.append(i)\n\n    # Phase 2: Multi-phase local search\n    if critical_nodes:\n        # Randomly select a critical node and perform targeted operations\n        target = np.random.choice(critical_nodes)\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Operation 1: Swap critical node with another node\n        new_solution[target], new_solution[a] = new_solution[a], new_solution[target]\n\n        # Operation 2: Reverse a segment around the critical node\n        segment_size = min(5, n//2)\n        start = max(0, target - segment_size//2)\n        end = min(n, target + segment_size//2 + 1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Operation 3: Insert a random edge from another part of the tour\n        if n > 3:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            edge = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9101046267631073,
            0.20161479711532593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding.append(float('inf'))\n        else:\n            cd1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            cd2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding.append(cd1 + cd2)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with distance-based selection\n    i = random.randint(0, n-1)\n    j = (i + random.randint(1, n//2)) % n\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:], [node]])\n\n    # Segment rotation with objective-aware selection\n    segment_length = max(2, min(n//3, random.randint(2, n//2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length-1)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7834781796130217,
            0.22696608304977417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding.append(float('inf'))\n        else:\n            cd1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            cd2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding.append(cd1 + cd2)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with distance-based selection\n    i = random.randint(0, n-1)\n    j = (i + random.randint(1, n//2)) % n\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:], [node]])\n\n    # Segment rotation with objective-aware selection\n    segment_length = max(2, min(n//3, random.randint(2, n//2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length-1)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment shifting\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:], segment])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The new algorithm combines adaptive segment inversion with dynamic edge reinsertion, guided by both objective spaces to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j+1:]])\n\n    # Dynamic edge reinsertion based on objective improvement\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        if k == 0:\n            continue\n\n        current_cost = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n        new_pos = np.random.randint(0, n)\n        if new_pos == k or new_pos == k-1:\n            continue\n\n        new_cost = distance_matrix_1[new_solution[new_pos], new_solution[k]] + distance_matrix_2[new_solution[new_pos], new_solution[k]]\n        if new_cost < current_cost:\n            edge = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [edge], new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8410454374290809,
            0.275646448135376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j+1:]])\n\n    # Dynamic edge reinsertion based on objective improvement\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        if k == 0:\n            continue\n\n        current_cost = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n        new_pos = np.random.randint(0, n)\n        if new_pos == k or new_pos == k-1:\n            continue\n\n        new_cost = distance_matrix_1[new_solution[new_pos], new_solution[k]] + distance_matrix_2[new_solution[new_pos], new_solution[k]]\n        if new_cost < current_cost:\n            edge = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [edge], new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{A novel hybrid local search strategy that intelligently combines segment reversal with adaptive edge swaps to explore the solution space while maintaining feasibility, guided by objective-aware selection of base solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3] if len(archive) > 10 else [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Segment reversal with adaptive length\n        seg_length = min(n//2, max(2, int(np.random.normal(n/4, n/8))))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        # Adaptive edge swaps\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Check potential improvement\n                old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n                if new_cost < old_cost:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7781504597519391,
            0.6626502871513367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3] if len(archive) > 10 else [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Segment reversal with adaptive length\n        seg_length = min(n//2, max(2, int(np.random.normal(n/4, n/8))))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        # Adaptive edge swaps\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Check potential improvement\n                old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n                if new_cost < old_cost:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj_values = np.array([obj for _, obj in archive])\n    normalized_obj = (obj_values - obj_values.min(axis=0)) / (obj_values.max(axis=0) - obj_values.min(axis=0) + 1e-10)\n    scores = normalized_obj[:, 0] * 0.7 + normalized_obj[:, 1] * 0.3  # Weighted sum with emphasis on first objective\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest score (best trade-off)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (with probability 0.6)\n    if random.random() < 0.6:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere (with probability 0.4)\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        edge = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7596022550227004,
            0.2918704152107239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj_values = np.array([obj for _, obj in archive])\n    normalized_obj = (obj_values - obj_values.min(axis=0)) / (obj_values.max(axis=0) - obj_values.min(axis=0) + 1e-10)\n    scores = normalized_obj[:, 0] * 0.7 + normalized_obj[:, 1] * 0.3  # Weighted sum with emphasis on first objective\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest score (best trade-off)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (with probability 0.6)\n    if random.random() < 0.6:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere (with probability 0.4)\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        edge = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment shifting\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:], segment])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware criterion that balances objective values and solution structure, then applies a novel hybrid local search combining edge reversal and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    diversity_scores = np.array(diversity_scores)\n    combined_scores = (objectives[:, 0] + objectives[:, 1]) / (diversity_scores + 1e-10)\n    selection_probs = 1 / (combined_scores + 1e-10)\n    selection_probs = selection_probs / np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge reversal with segment inversion\n        a, b = sorted(random.sample(range(n-1), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Segment inversion\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        inverted_segment = np.array([-x for x in segment])\n        new_solution[c:d+1] = inverted_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9202323047027247,
            0.6455438137054443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    diversity_scores = np.array(diversity_scores)\n    combined_scores = (objectives[:, 0] + objectives[:, 1]) / (diversity_scores + 1e-10)\n    selection_probs = 1 / (combined_scores + 1e-10)\n    selection_probs = selection_probs / np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge reversal with segment inversion\n        a, b = sorted(random.sample(range(n-1), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Segment inversion\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        inverted_segment = np.array([-x for x in segment])\n        new_solution[c:d+1] = inverted_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This new algorithm selects a solution from the archive using a rank-based selection that prioritizes solutions with better combined objective values, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank-based selection\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_probs = np.linspace(1, 0.1, len(sorted_archive))\n    selection_probs = selection_probs / np.sum(selection_probs)\n    selected_idx = np.random.choice(len(sorted_archive), p=selection_probs)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt and node insertion\n    if n > 4:\n        # Step 1: 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Step 2: Node insertion\n        node = random.choice(new_solution)\n        mask = new_solution != node\n        remaining = new_solution[mask]\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, insert_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9215766736797713,
            0.3096820116043091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank-based selection\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_probs = np.linspace(1, 0.1, len(sorted_archive))\n    selection_probs = selection_probs / np.sum(selection_probs)\n    selected_idx = np.random.choice(len(sorted_archive), p=selection_probs)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt and node insertion\n    if n > 4:\n        # Step 1: 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Step 2: Node insertion\n        node = random.choice(new_solution)\n        mask = new_solution != node\n        remaining = new_solution[mask]\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, insert_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This new algorithm selects a solution from the archive based on potential improvement in both objectives, applies a hybrid local search combining segment reversal and edge exchange, and ensures feasibility by validating the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse a segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Exchange edges between segments\n    if c < a < b < d:\n        temp = new_solution[c]\n        new_solution[c] = new_solution[a]\n        new_solution[a] = temp\n        temp = new_solution[b]\n        new_solution[b] = new_solution[d]\n        new_solution[d] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7784186422637047,
            0.263996958732605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse a segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Exchange edges between segments\n    if c < a < b < d:\n        temp = new_solution[c]\n        new_solution[c] = new_solution[a]\n        new_solution[a] = temp\n        temp = new_solution[b]\n        new_solution[b] = new_solution[d]\n        new_solution[d] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    obj1_std = np.std(obj1_values)\n    obj2_std = np.std(obj2_values)\n    weight1 = obj2_std / (obj1_std + obj2_std) if (obj1_std + obj2_std) > 0 else 0.5\n    weight2 = 1 - weight1\n\n    # Select solution with best weighted score\n    scores = [weight1 * obj[0] + weight2 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion with probability\n    if random.random() < 0.5:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Edge swapping with probability\n    if random.random() < 0.4 and n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8951753408002521,
            0.3458397388458252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    obj1_std = np.std(obj1_values)\n    obj2_std = np.std(obj2_values)\n    weight1 = obj2_std / (obj1_std + obj2_std) if (obj1_std + obj2_std) > 0 else 0.5\n    weight2 = 1 - weight1\n\n    # Select solution with best weighted score\n    scores = [weight1 * obj[0] + weight2 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion with probability\n    if random.random() < 0.5:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Edge swapping with probability\n    if random.random() < 0.4 and n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity measures, then applies a hybrid local search combining node swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    diversity = [np.sum(np.abs(obj - mean_obj)) for obj in objectives]\n    scores = [0.7 * (obj[0] + obj[1]) + 0.3 * div for obj, div in zip(objectives, diversity)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swapping and segment relocation\n    n = len(new_solution)\n    if n > 3:\n        # Node swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + n//3, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:], segment])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7953861313485935,
            0.2788965702056885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    diversity = [np.sum(np.abs(obj - mean_obj)) for obj in objectives]\n    scores = [0.7 * (obj[0] + obj[1]) + 0.3 * div for obj, div in zip(objectives, diversity)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swapping and segment relocation\n    n = len(new_solution)\n    if n > 3:\n        # Node swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + n//3, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:], segment])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node insertion, segment reversal, and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.sum(normalized, axis=1) + 1e-10)\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion, segment reversal, and edge inversion\n    if n > 3:\n        # Step 1: Node insertion (move a random node to a new position)\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Step 3: Edge inversion (invert two adjacent edges)\n        pos = random.randint(0, n-3)\n        new_solution[pos], new_solution[pos+2] = new_solution[pos+2], new_solution[pos]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node relocation, path inversion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.sum(normalized, axis=1) + 1e-10)\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node relocation, path inversion, and edge swapping\n    if n > 3:\n        # Step 1: Node relocation (move a random node to a new position)\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n        # Step 2: Path inversion (invert a random segment)\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Step 3: Edge swapping (swap two non-adjacent edges)\n        pos1, pos2 = sorted(random.sample(range(n-2), 2))\n        new_solution[pos1+1], new_solution[pos2+1] = new_solution[pos2+1], new_solution[pos1+1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9367107911295134,
            0.2761206030845642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.sum(normalized, axis=1) + 1e-10)\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node relocation, path inversion, and edge swapping\n    if n > 3:\n        # Step 1: Node relocation (move a random node to a new position)\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n        # Step 2: Path inversion (invert a random segment)\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Step 3: Edge swapping (swap two non-adjacent edges)\n        pos1, pos2 = sorted(random.sample(range(n-2), 2))\n        new_solution[pos1+1], new_solution[pos2+1] = new_solution[pos2+1], new_solution[pos1+1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining node relocation and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n    # Insert the node at a random position\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n-1), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8055629648263481,
            0.22728043794631958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining node relocation and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n    # Insert the node at a random position\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n-1), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment with probability based on segment length\n        if np.random.rand() < 0.7:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Swap edges with probability based on distance improvement\n        if np.random.rand() < 0.5:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k != l and abs(k - l) > 1:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9187546278924479,
            0.4913522005081177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment with probability based on segment length\n        if np.random.rand() < 0.7:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Swap edges with probability based on distance improvement\n        if np.random.rand() < 0.5:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k != l and abs(k - l) > 1:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This algorithm selects a solution from the archive based on a hypervolume indicator to identify non-dominated solutions, then applies a novel local search combining node swapping with path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node swapping with path relinking\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path relinking step\n        if random.random() < 0.3:\n            k = random.randint(1, n-2)\n            new_solution = np.concatenate([new_solution[:k], new_solution[k:][::-1]])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7362494455756027,
            0.2974797487258911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node swapping with path relinking\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path relinking step\n        if random.random() < 0.3:\n            k = random.randint(1, n-2)\n            new_solution = np.concatenate([new_solution[:k], new_solution[k:][::-1]])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and node centrality, then applies a hybrid local search combining node swapping, segment rotation, and edge reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    # Calculate node centrality in both spaces\n    centrality_scores = []\n    for sol, _ in archive:\n        centrality_1 = np.mean([distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n        centrality_2 = np.mean([distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n        centrality_scores.append(centrality_1 + centrality_2)\n\n    combined_scores = [weights[0] * obj[0] + weights[1] * obj[1] + 0.3 * centrality_scores[i] for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    # 1. Node swapping with objective-aware selection\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment rotation\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # 3. Edge reinsertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8502831939827963,
            0.6242537498474121
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    # Calculate node centrality in both spaces\n    centrality_scores = []\n    for sol, _ in archive:\n        centrality_1 = np.mean([distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n        centrality_2 = np.mean([distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n        centrality_scores.append(centrality_1 + centrality_2)\n\n    combined_scores = [weights[0] * obj[0] + weights[1] * obj[1] + 0.3 * centrality_scores[i] for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    # 1. Node swapping with objective-aware selection\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment rotation\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # 3. Edge reinsertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -1.0052541241311164,
            2.73446923494339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -1.0052541241311164,
            2.73446923494339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on the Pareto dominance relationship, then applies a novel local search strategy combining segment inversion and edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search strategy\n    if n > 3:\n        # Step 1: Select a random segment and invert it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Step 2: Select a random edge and insert it elsewhere\n        i = random.randint(0, n-2)\n        edge = new_solution[i:i+2]\n        remaining = np.concatenate([new_solution[:i], new_solution[i+2:]])\n        insert_pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8472603649385274,
            0.261843204498291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search strategy\n    if n > 3:\n        # Step 1: Select a random segment and invert it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Step 2: Select a random edge and insert it elsewhere\n        i = random.randint(0, n-2)\n        edge = new_solution[i:i+2]\n        remaining = np.concatenate([new_solution[:i], new_solution[i+2:]])\n        insert_pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining segment inversion and multi-node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and invert it\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Randomly select multiple nodes and relocate them to new positions\n    num_nodes = random.randint(2, min(4, n))\n    selected_nodes = random.sample(range(n), num_nodes)\n    remaining = np.array([node for i, node in enumerate(new_solution) if i not in selected_nodes])\n    insert_positions = sorted(random.sample(range(len(remaining) + 1), num_nodes))\n\n    for i, pos in enumerate(insert_positions):\n        remaining = np.insert(remaining, pos, new_solution[selected_nodes[i]])\n\n    new_solution = remaining\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9101275455143998,
            0.24046754837036133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and invert it\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Randomly select multiple nodes and relocate them to new positions\n    num_nodes = random.randint(2, min(4, n))\n    selected_nodes = random.sample(range(n), num_nodes)\n    remaining = np.array([node for i, node in enumerate(new_solution) if i not in selected_nodes])\n    insert_positions = sorted(random.sample(range(len(remaining) + 1), num_nodes))\n\n    for i, pos in enumerate(insert_positions):\n        remaining = np.insert(remaining, pos, new_solution[selected_nodes[i]])\n\n    new_solution = remaining\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search combining node insertion and segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Remove the node and find a new position\n    new_solution = np.delete(new_solution, node_idx)\n    new_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n-1), 2))\n    segment = new_solution[start:end+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n    new_solution[start:end+1] = rotated_segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7854462435991618,
            0.226895272731781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search combining node insertion and segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Remove the node and find a new position\n    new_solution = np.delete(new_solution, node_idx)\n    new_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n-1), 2))\n    segment = new_solution[start:end+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n    new_solution[start:end+1] = rotated_segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm selects the best solution from the archive based on the combined objective values, then applies a novel hybrid local search combining adaptive 3-opt and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objectives\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    best_idx = np.argmin(combined)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive 3-opt: select three non-consecutive edges and reconnect them\n        i, j, k = sorted(random.sample(range(n-1), 3))\n        while j == i + 1 or k == j + 1:  # Ensure non-consecutive edges\n            i, j, k = sorted(random.sample(range(n-1), 3))\n\n        # Create three possible reconnections and choose the best one\n        reconnections = [\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1], new_solution[i+1:j+1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k+1:], new_solution[j+1:k+1], new_solution[i+1:j+1]]),\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1], new_solution[k+1:], new_solution[i+1:j+1]])\n        ]\n\n        # Evaluate reconnections using both distance matrices\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        best_reconnection = min(reconnections, key=evaluate)\n        new_solution = best_reconnection.copy()\n\n        # Segment inversion: invert a random segment with adaptive size\n        seg_size = min(random.randint(2, n//2), n-2)\n        start = random.randint(0, n-seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8588640521466291,
            0.2844594120979309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objectives\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    best_idx = np.argmin(combined)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive 3-opt: select three non-consecutive edges and reconnect them\n        i, j, k = sorted(random.sample(range(n-1), 3))\n        while j == i + 1 or k == j + 1:  # Ensure non-consecutive edges\n            i, j, k = sorted(random.sample(range(n-1), 3))\n\n        # Create three possible reconnections and choose the best one\n        reconnections = [\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1], new_solution[i+1:j+1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k+1:], new_solution[j+1:k+1], new_solution[i+1:j+1]]),\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1], new_solution[k+1:], new_solution[i+1:j+1]])\n        ]\n\n        # Evaluate reconnections using both distance matrices\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        best_reconnection = min(reconnections, key=evaluate)\n        new_solution = best_reconnection.copy()\n\n        # Segment inversion: invert a random segment with adaptive size\n        seg_size = min(random.randint(2, n//2), n-2)\n        start = random.randint(0, n-seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a hybrid local search strategy combining segment reversal, node reinsertion, and edge swapping with a probability-based approach to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.4:  # Segment reversal with 40% probability\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    elif random.random() < 0.7:  # Node reinsertion with 30% probability\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:  # Edge swapping with 30% probability\n        if n > 2:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8646093561706667,
            0.22079551219940186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.4:  # Segment reversal with 40% probability\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    elif random.random() < 0.7:  # Node reinsertion with 30% probability\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:  # Edge swapping with 30% probability\n        if n > 2:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9683305167864898,
            0.2957075238227844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9532524904849459,
            3.145656406879425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining node swap and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    remaining = list(range(len(archive)))\n    while remaining:\n        front = []\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                front.append(i)\n        fronts.append(front)\n        remaining = [i for i in remaining if i not in front]\n\n    # Select from the first front if possible, otherwise from subsequent fronts\n    selected_idx = fronts[0][0] if fronts else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swap and segment rotation\n    if n >= 4:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment rotation\n        segment_length = random.randint(2, min(n // 2, 4))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, random.randint(1, segment_length - 1))\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8521630837071222,
            0.25327324867248535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    remaining = list(range(len(archive)))\n    while remaining:\n        front = []\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                front.append(i)\n        fronts.append(front)\n        remaining = [i for i in remaining if i not in front]\n\n    # Select from the first front if possible, otherwise from subsequent fronts\n    selected_idx = fronts[0][0] if fronts else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swap and segment rotation\n    if n >= 4:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment rotation\n        segment_length = random.randint(2, min(n // 2, 4))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, random.randint(1, segment_length - 1))\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining segment inversion and multi-node relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and invert it\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Randomly select multiple nodes and relocate them to new positions\n    num_nodes = random.randint(2, min(4, n))\n    selected_nodes = random.sample(range(n), num_nodes)\n    remaining = np.array([node for i, node in enumerate(new_solution) if i not in selected_nodes])\n    insert_positions = sorted(random.sample(range(len(remaining) + 1), num_nodes))\n\n    for i, pos in enumerate(insert_positions):\n        remaining = np.insert(remaining, pos, new_solution[selected_nodes[i]])\n\n    new_solution = remaining\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining node swapping with distance-aware segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (1 + np.sum(np.abs(sol - archive[0][0]))) for sol, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform node swapping based on distance improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate change in both objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n              distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n             (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n              distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n             (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Insert a segment at a position that improves both objectives\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n - segment_size + 1):\n        if pos >= start and pos < start + segment_size:\n            continue\n\n        # Calculate change in both objectives for this insertion\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        current_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Calculate original cost\n        original_prev = new_solution[start-1] if start > 0 else new_solution[-1]\n        original_next = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        original_cost1 = distance_matrix_1[original_prev, segment[0]] + distance_matrix_1[segment[-1], original_next]\n        original_cost2 = distance_matrix_2[original_prev, segment[0]] + distance_matrix_2[segment[-1], original_next]\n\n        delta1 = (current_cost1 - original_cost1)\n        delta2 = (current_cost2 - original_cost2)\n\n        if delta1 < 0 and delta2 < 0:\n            if -delta1 - delta2 > best_improvement:\n                best_improvement = -delta1 - delta2\n                best_pos = pos\n\n    if best_pos != -1:\n        # Remove segment from original position\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7376625734493506,
            0.3615277409553528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (1 + np.sum(np.abs(sol - archive[0][0]))) for sol, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform node swapping based on distance improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate change in both objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n              distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n             (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n              distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n             (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Insert a segment at a position that improves both objectives\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n - segment_size + 1):\n        if pos >= start and pos < start + segment_size:\n            continue\n\n        # Calculate change in both objectives for this insertion\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        current_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Calculate original cost\n        original_prev = new_solution[start-1] if start > 0 else new_solution[-1]\n        original_next = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        original_cost1 = distance_matrix_1[original_prev, segment[0]] + distance_matrix_1[segment[-1], original_next]\n        original_cost2 = distance_matrix_2[original_prev, segment[0]] + distance_matrix_2[segment[-1], original_next]\n\n        delta1 = (current_cost1 - original_cost1)\n        delta2 = (current_cost2 - original_cost2)\n\n        if delta1 < 0 and delta2 < 0:\n            if -delta1 - delta2 > best_improvement:\n                best_improvement = -delta1 - delta2\n                best_pos = pos\n\n    if best_pos != -1:\n        # Remove segment from original position\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a solution from the archive, identifies a promising segment using a hybrid of edge-based and segment-based analysis, and applies a novel combination of segment reversal and edge relinking to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment reversal and edge relinking\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relink edges at the segment boundaries\n        if i > 0 and j < n - 1:\n            # Swap the edges connecting the reversed segment\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9583685612758623,
            0.28082275390625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment reversal and edge relinking\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relink edges at the segment boundaries\n        if i > 0 and j < n - 1:\n            # Swap the edges connecting the reversed segment\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.7]  # Higher weight for the second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to relocate\n    i = random.randint(0, n-1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8471151120073008,
            0.22699373960494995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.7]  # Higher weight for the second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to relocate\n    i = random.randint(0, n-1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm uses a weighted sum of objectives with adaptive weights based on solution diversity, followed by a hybrid local search combining segment reversal and edge insertion, with a fallback mechanism to ensure feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    std1 = np.std(obj1_values)\n    std2 = np.std(obj2_values)\n    total_std = std1 + std2\n    if total_std == 0:\n        weights = [0.5, 0.5]\n    else:\n        weights = [std1/total_std, std2/total_std]\n\n    # Select solution with highest weighted score (lower is better)\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the segment that improves one objective without significantly worsening the other\n    best_improvement = 0\n    best_segment = None\n    for i in range(n):\n        for j in range(i+1, min(i+10, n)):\n            reversed_segment = new_solution[i:j+1][::-1]\n            temp_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n            temp_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            temp_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            improvement = (obj1_cost - temp_obj1) * weights[0] + (obj2_cost - temp_obj2) * weights[1]\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_segment = (i, j, reversed_segment)\n\n    if best_segment is not None:\n        i, j, reversed_segment = best_segment\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n    # Edge insertion with objective-aware selection\n    best_insertion = 0\n    best_edge = None\n    for i in range(n):\n        for j in range(i+1, min(i+10, n)):\n            edge = new_solution[i:j+1]\n            temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n            temp_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            temp_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            improvement = (obj1_cost - temp_obj1) * weights[0] + (obj2_cost - temp_obj2) * weights[1]\n            if improvement > best_insertion:\n                best_insertion = improvement\n                best_edge = (i, j, edge)\n\n    if best_edge is not None:\n        i, j, edge = best_edge\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6952803058944559,
            11.708508968353271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    std1 = np.std(obj1_values)\n    std2 = np.std(obj2_values)\n    total_std = std1 + std2\n    if total_std == 0:\n        weights = [0.5, 0.5]\n    else:\n        weights = [std1/total_std, std2/total_std]\n\n    # Select solution with highest weighted score (lower is better)\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the segment that improves one objective without significantly worsening the other\n    best_improvement = 0\n    best_segment = None\n    for i in range(n):\n        for j in range(i+1, min(i+10, n)):\n            reversed_segment = new_solution[i:j+1][::-1]\n            temp_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n            temp_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            temp_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            improvement = (obj1_cost - temp_obj1) * weights[0] + (obj2_cost - temp_obj2) * weights[1]\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_segment = (i, j, reversed_segment)\n\n    if best_segment is not None:\n        i, j, reversed_segment = best_segment\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n    # Edge insertion with objective-aware selection\n    best_insertion = 0\n    best_edge = None\n    for i in range(n):\n        for j in range(i+1, min(i+10, n)):\n            edge = new_solution[i:j+1]\n            temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n            temp_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            temp_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            improvement = (obj1_cost - temp_obj1) * weights[0] + (obj2_cost - temp_obj2) * weights[1]\n            if improvement > best_insertion:\n                best_insertion = improvement\n                best_edge = (i, j, edge)\n\n    if best_edge is not None:\n        i, j, edge = best_edge\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal with a probability of 0.7\n    if np.random.rand() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply edge insertion with a probability of 0.5\n    if np.random.rand() < 0.5 and n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = (i + j) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9458729232517209,
            0.26291805505752563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal with a probability of 0.7\n    if np.random.rand() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply edge insertion with a probability of 0.5\n    if np.random.rand() < 0.5 and n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = (i + j) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This algorithm selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies an adaptive multi-segment reversal and edge swapping operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive multi-segment reversal with dynamic segment selection\n    num_segments = min(4, max(2, n // 4))\n    segment_lengths = sorted(random.sample(range(2, n // 3), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Enhanced edge swapping based on combined distance improvement\n    for _ in range(min(4, n // 3)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost * 0.9:  # More aggressive improvement threshold\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9830382652969765,
            3.089888274669647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive multi-segment reversal with dynamic segment selection\n    num_segments = min(4, max(2, n // 4))\n    segment_lengths = sorted(random.sample(range(2, n // 3), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Enhanced edge swapping based on combined distance improvement\n    for _ in range(min(4, n // 3)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost * 0.9:  # More aggressive improvement threshold\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new algorithm selects a solution from the archive based on a novel combination of objective normalization and diversity-aware selection, then applies a hybrid local search combining adaptive segment rotation and distance-aware edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    combined_scores = np.sum(normalized_obj, axis=1) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Calculate segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Decide rotation direction based on which objective is worse\n    if segment_cost1 > segment_cost2:\n        rotation = -1  # Reverse direction\n    else:\n        rotation = 1   # Forward direction\n\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Distance-aware edge swapping\n    for _ in range(2):  # Perform 2 swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j and abs(i - j) > 1:\n            # Calculate change in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            delta1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            delta2 = new_cost2 - old_cost2\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < delta2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8698521595827094,
            0.3387186527252197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    combined_scores = np.sum(normalized_obj, axis=1) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Calculate segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Decide rotation direction based on which objective is worse\n    if segment_cost1 > segment_cost2:\n        rotation = -1  # Reverse direction\n    else:\n        rotation = 1   # Forward direction\n\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Distance-aware edge swapping\n    for _ in range(2):  # Perform 2 swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j and abs(i - j) > 1:\n            # Calculate change in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            delta1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            delta2 = new_cost2 - old_cost2\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < delta2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply edge insertion\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9589313973026362,
            0.27009356021881104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment reversal\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply edge insertion\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9857870261830081,
            1.3527095913887024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.883227977162659,
            0.1505279541015625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.883227977162659,
            0.1505279541015625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm selects a solution from the archive using an objective-based selection with a temperature parameter to balance exploration and exploitation, then applies a hybrid local search combining adaptive segment relocation and edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: temperature-based objective selection\n    objectives = np.array([obj for _, obj in archive])\n    temp = 0.7  # Temperature parameter for selection\n    selection_probs = np.exp(-np.sum(objectives, axis=1) / temp)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation and edge swapping\n    if n > 3:\n        # Step 1: Adaptive segment relocation\n        seg_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n        insert_pos = random.randint(0, len(new_solution) - seg_length + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Step 2: Edge swapping\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.876431498485983,
            0.2747662663459778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: temperature-based objective selection\n    objectives = np.array([obj for _, obj in archive])\n    temp = 0.7  # Temperature parameter for selection\n    selection_probs = np.exp(-np.sum(objectives, axis=1) / temp)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation and edge swapping\n    if n > 3:\n        # Step 1: Adaptive segment relocation\n        seg_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n        insert_pos = random.randint(0, len(new_solution) - seg_length + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Step 2: Edge swapping\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted probability that considers both objectives, then applies a hybrid local search combining edge swapping and segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)  # Inverse of combined objectives\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment relocation\n    if n > 3:\n        # Step 1: Edge swapping (swap two randomly selected edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment relocation (move a random segment to a new position)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and node centrality, then applies a hybrid local search combining edge reversal and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate node centrality based on distance matrices\n    centrality_scores = np.sum(distance_matrix_1, axis=1) + np.sum(distance_matrix_2, axis=1)\n\n    # Weighted selection based on objective values and centrality\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + centrality_scores[archive[0][0][0]])\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal and node reinsertion\n    if n > 4:\n        # Step 1: Edge reversal (reverse a segment between two central nodes)\n        central_nodes = np.argsort(centrality_scores[base_solution])[-2:]\n        start, end = sorted(random.sample(list(central_nodes), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Step 2: Node reinsertion (remove a random node and reinsert it)\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9016348896424777,
            0.3213345408439636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate node centrality based on distance matrices\n    centrality_scores = np.sum(distance_matrix_1, axis=1) + np.sum(distance_matrix_2, axis=1)\n\n    # Weighted selection based on objective values and centrality\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + centrality_scores[archive[0][0][0]])\n    selection_probs = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal and node reinsertion\n    if n > 4:\n        # Step 1: Edge reversal (reverse a segment between two central nodes)\n        central_nodes = np.argsort(centrality_scores[base_solution])[-2:]\n        start, end = sorted(random.sample(list(central_nodes), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Step 2: Node reinsertion (remove a random node and reinsert it)\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal importance for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{A novel heuristic function that selects solutions based on Pareto dominance and diversity, then applies a hybrid local search combining segment reversal with edge insertion while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol, obj))\n\n    if len(pareto_front) > 0:\n        # Select a solution from the Pareto front with highest diversity\n        diversity_scores = []\n        for sol, _ in pareto_front:\n            total_diversity = 0\n            for i in range(len(sol)):\n                total_diversity += distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]]\n            diversity_scores.append(total_diversity)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = pareto_front[selected_idx][0].copy()\n    else:\n        # If no Pareto front, select based on crowding distance\n        crowding_distances = []\n        for _, obj in archive:\n            distances = []\n            for _, other_obj in archive:\n                distances.append(np.linalg.norm(np.array(obj) - np.array(other_obj)))\n            crowding_distances.append(np.mean(distances))\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining segment reversal and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    segment_length = min(3, n // 2)\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Edge insertion with validation\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    candidate = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate the new solution\n    if np.array_equal(np.sort(candidate), np.sort(new_solution)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7900317603168399,
            0.5611442923545837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol, obj))\n\n    if len(pareto_front) > 0:\n        # Select a solution from the Pareto front with highest diversity\n        diversity_scores = []\n        for sol, _ in pareto_front:\n            total_diversity = 0\n            for i in range(len(sol)):\n                total_diversity += distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]]\n            diversity_scores.append(total_diversity)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = pareto_front[selected_idx][0].copy()\n    else:\n        # If no Pareto front, select based on crowding distance\n        crowding_distances = []\n        for _, obj in archive:\n            distances = []\n            for _, other_obj in archive:\n                distances.append(np.linalg.norm(np.array(obj) - np.array(other_obj)))\n            crowding_distances.append(np.mean(distances))\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search strategy combining segment reversal and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    segment_length = min(3, n // 2)\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Edge insertion with validation\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    candidate = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate the new solution\n    if np.array_equal(np.sort(candidate), np.sort(new_solution)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive, identifies a promising segment using a hybrid of edge-based and segment-based analysis, and applies a novel combination of segment reversal and edge relinking to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment reversal and edge relinking\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relink edges at the segment boundaries\n        if i > 0 and j < n - 1:\n            # Swap the edges connecting the reversed segment\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and spatial proximity, then applies a novel local search operator that combines node insertion with adaptive edge rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive node insertion with edge rotation\n    for _ in range(min(3, n // 2)):\n        # Select a node to move\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Find the best insertion position considering spatial proximity\n        best_pos = i\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == i or pos == (i - 1) % n:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1]\n            next_node = new_solution[pos]\n\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Perform insertion\n        if best_pos > i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:i], new_solution[i+1:]])\n\n        # Adaptive edge rotation\n        if np.random.random() < 0.5:\n            k = np.random.randint(1, min(3, n // 2))\n            rotate_pos = np.random.randint(0, n - k)\n            new_solution[rotate_pos:rotate_pos+k] = np.roll(new_solution[rotate_pos:rotate_pos+k], 1)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6861994557001323,
            0.8599067330360413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive node insertion with edge rotation\n    for _ in range(min(3, n // 2)):\n        # Select a node to move\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Find the best insertion position considering spatial proximity\n        best_pos = i\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == i or pos == (i - 1) % n:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1]\n            next_node = new_solution[pos]\n\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Perform insertion\n        if best_pos > i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:i], new_solution[i+1:]])\n\n        # Adaptive edge rotation\n        if np.random.random() < 0.5:\n            k = np.random.randint(1, min(3, n // 2))\n            rotate_pos = np.random.randint(0, n - k)\n            new_solution[rotate_pos:rotate_pos+k] = np.roll(new_solution[rotate_pos:rotate_pos+k], 1)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and node diversity, then applies a hybrid local search combining segment rotation and edge reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    diversity_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with objective-aware selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end+1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n    # Decide rotation direction based on which objective is worse\n    if segment_cost1 > segment_cost1 * 1.1 or segment_cost2 > segment_cost2 * 1.1:\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Edge reordering with distance-based selection\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_segment = new_solution[i:j+1]\n            new_segment = np.flip(new_segment)\n            new_solution[i:j+1] = new_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8919084681650287,
            0.3025089502334595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    diversity_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with objective-aware selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end+1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n    # Decide rotation direction based on which objective is worse\n    if segment_cost1 > segment_cost1 * 1.1 or segment_cost2 > segment_cost2 * 1.1:\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Edge reordering with distance-based selection\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_segment = new_solution[i:j+1]\n            new_segment = np.flip(new_segment)\n            new_solution[i:j+1] = new_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{The new algorithm combines segment rotation with adaptive edge swaps, guided by a weighted objective score to prioritize promising regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive length\n    segment_length = min(5, max(2, random.randint(1, n//2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = rotated_segment\n\n    # Adaptive edge swaps based on distance improvement\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]])\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7937017347941472,
            0.2752745747566223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive length\n    segment_length = min(5, max(2, random.randint(1, n//2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = rotated_segment\n\n    # Adaptive edge swaps based on distance improvement\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]])\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a hybrid local search combining adaptive segment rotation and constrained edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy combining objective values and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    # Weighted selection combining objectives and diversity\n    combined = np.sum(objectives, axis=1) * (1 + 0.1 * diversity)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment rotation\n    num_rotations = min(4, max(1, n // 6))\n    for _ in range(num_rotations):\n        segment_length = random.randint(2, min(8, n // 3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation = random.randint(1, segment_length - 1)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:end] = rotated_segment\n\n    # Constrained edge flipping\n    for _ in range(min(5, n // 2)):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1 and abs(i - j) < n // 2:\n            # Calculate potential improvement\n            prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n            next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            original_cost = (distance_matrix_1[prev_nodes[0], new_solution[i]] + distance_matrix_1[new_solution[i], next_nodes[0]] +\n                            distance_matrix_1[prev_nodes[1], new_solution[j]] + distance_matrix_1[new_solution[j], next_nodes[1]] +\n                            distance_matrix_2[prev_nodes[0], new_solution[i]] + distance_matrix_2[new_solution[i], next_nodes[0]] +\n                            distance_matrix_2[prev_nodes[1], new_solution[j]] + distance_matrix_2[new_solution[j], next_nodes[1]])\n\n            flipped_cost = (distance_matrix_1[prev_nodes[0], new_solution[j]] + distance_matrix_1[new_solution[j], next_nodes[0]] +\n                           distance_matrix_1[prev_nodes[1], new_solution[i]] + distance_matrix_1[new_solution[i], next_nodes[1]] +\n                           distance_matrix_2[prev_nodes[0], new_solution[j]] + distance_matrix_2[new_solution[j], next_nodes[0]] +\n                           distance_matrix_2[prev_nodes[1], new_solution[i]] + distance_matrix_2[new_solution[i], next_nodes[1]])\n\n            if flipped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8907499579976824,
            2.81614750623703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy combining objective values and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    # Weighted selection combining objectives and diversity\n    combined = np.sum(objectives, axis=1) * (1 + 0.1 * diversity)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment rotation\n    num_rotations = min(4, max(1, n // 6))\n    for _ in range(num_rotations):\n        segment_length = random.randint(2, min(8, n // 3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation = random.randint(1, segment_length - 1)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:end] = rotated_segment\n\n    # Constrained edge flipping\n    for _ in range(min(5, n // 2)):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1 and abs(i - j) < n // 2:\n            # Calculate potential improvement\n            prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n            next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            original_cost = (distance_matrix_1[prev_nodes[0], new_solution[i]] + distance_matrix_1[new_solution[i], next_nodes[0]] +\n                            distance_matrix_1[prev_nodes[1], new_solution[j]] + distance_matrix_1[new_solution[j], next_nodes[1]] +\n                            distance_matrix_2[prev_nodes[0], new_solution[i]] + distance_matrix_2[new_solution[i], next_nodes[0]] +\n                            distance_matrix_2[prev_nodes[1], new_solution[j]] + distance_matrix_2[new_solution[j], next_nodes[1]])\n\n            flipped_cost = (distance_matrix_1[prev_nodes[0], new_solution[j]] + distance_matrix_1[new_solution[j], next_nodes[0]] +\n                           distance_matrix_1[prev_nodes[1], new_solution[i]] + distance_matrix_1[new_solution[i], next_nodes[1]] +\n                           distance_matrix_2[prev_nodes[0], new_solution[j]] + distance_matrix_2[new_solution[j], next_nodes[0]] +\n                           distance_matrix_2[prev_nodes[1], new_solution[i]] + distance_matrix_2[new_solution[i], next_nodes[1]])\n\n            if flipped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.797041406335062,
            0.1393047571182251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.797041406335062,
            0.1393047571182251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel heuristic function that selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current diversity of solutions, followed by a hybrid local search combining segment rotation, node insertion, and edge swapping with adaptive intensity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    diversity1 = np.std(obj1_values)\n    diversity2 = np.std(obj2_values)\n    total_diversity = diversity1 + diversity2\n    if total_diversity == 0:\n        weights = [0.5, 0.5]\n    else:\n        weights = [diversity2/total_diversity, diversity1/total_diversity]\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search intensity\n    intensity = min(0.5, 1.0 / (1.0 + np.exp(-(len(archive) - 5))))\n\n    # Segment rotation with adaptive size\n    segment_size = max(2, int(n * intensity))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    rotation = np.random.randint(1, segment_size)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_size] = rotated_segment\n\n    # Node insertion with adaptive probability\n    if np.random.random() < intensity:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Edge swapping with adaptive probability\n    if np.random.random() < intensity and n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8248862836390383,
            0.2994260787963867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    diversity1 = np.std(obj1_values)\n    diversity2 = np.std(obj2_values)\n    total_diversity = diversity1 + diversity2\n    if total_diversity == 0:\n        weights = [0.5, 0.5]\n    else:\n        weights = [diversity2/total_diversity, diversity1/total_diversity]\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search intensity\n    intensity = min(0.5, 1.0 / (1.0 + np.exp(-(len(archive) - 5))))\n\n    # Segment rotation with adaptive size\n    segment_size = max(2, int(n * intensity))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    rotation = np.random.randint(1, segment_size)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_size] = rotated_segment\n\n    # Node insertion with adaptive probability\n    if np.random.random() < intensity:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Edge swapping with adaptive probability\n    if np.random.random() < intensity and n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in less crowded regions of the objective space, then applies a hybrid local search combining adaptive node swapping and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions of the objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        # Calculate crowding distance for each solution\n        distances = np.linalg.norm(objectives - objectives[i], axis=1)\n        crowding_distances[i] = np.mean(np.partition(distances, 2)[:2])  # Average of two nearest neighbors\n\n    selection_probs = crowding_distances / np.sum(crowding_distances)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment rotation\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their position difference)\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:  # Ensure significant position difference\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Step 2: Segment rotation (rotate a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8425502023947122,
            0.5015119910240173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions of the objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        # Calculate crowding distance for each solution\n        distances = np.linalg.norm(objectives - objectives[i], axis=1)\n        crowding_distances[i] = np.mean(np.partition(distances, 2)[:2])  # Average of two nearest neighbors\n\n    selection_probs = crowding_distances / np.sum(crowding_distances)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment rotation\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their position difference)\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:  # Ensure significant position difference\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Step 2: Segment rotation (rotate a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection criterion that balances objective values and structural uniqueness, then applies a hybrid local search combining adaptive path reordering with multi-objective edge flipping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on hypervolume contribution and solution uniqueness\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Normalize objectives\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Calculate solution uniqueness\n    uniqueness = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for pos in range(n):\n            uniqueness[i] += 1 / (np.sum(solutions[:, pos] == sol[pos]) + 1)\n\n    # Combined score\n    scores = np.sum(norm_obj, axis=1) * uniqueness\n    selection_probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive path reordering\n    k = min(5, n // 3)\n    for _ in range(k):\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 10, n - 1))\n\n        segment = new_solution[start:end]\n        if random.random() < 0.7:\n            segment = segment[::-1]\n        else:\n            segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n        new_solution[start:end] = segment\n\n    # Multi-objective edge flipping\n    for _ in range(min(5, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate both objectives' changes\n        prev_i, next_i = new_solution[(i-1)%n], new_solution[(i+1)%n]\n        prev_j, next_j = new_solution[(j-1)%n], new_solution[(j+1)%n]\n\n        cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                    distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                    distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        # Accept if both objectives improve\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (random.random() < 0.3 and (new_cost1 < cost1 or new_cost2 < cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9272269669826516,
            1.6222548484802246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on hypervolume contribution and solution uniqueness\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Normalize objectives\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Calculate solution uniqueness\n    uniqueness = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for pos in range(n):\n            uniqueness[i] += 1 / (np.sum(solutions[:, pos] == sol[pos]) + 1)\n\n    # Combined score\n    scores = np.sum(norm_obj, axis=1) * uniqueness\n    selection_probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive path reordering\n    k = min(5, n // 3)\n    for _ in range(k):\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 10, n - 1))\n\n        segment = new_solution[start:end]\n        if random.random() < 0.7:\n            segment = segment[::-1]\n        else:\n            segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n        new_solution[start:end] = segment\n\n    # Multi-objective edge flipping\n    for _ in range(min(5, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate both objectives' changes\n        prev_i, next_i = new_solution[(i-1)%n], new_solution[(i+1)%n]\n        prev_j, next_j = new_solution[(j-1)%n], new_solution[(j+1)%n]\n\n        cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                    distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                    distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        # Accept if both objectives improve\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (random.random() < 0.3 and (new_cost1 < cost1 or new_cost2 < cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based approach to prioritize solutions in less crowded regions, then applies a hybrid local search combining 3-opt with a variable-length segment relocation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) < 2:\n        selected_idx = 0\n    else:\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n\n        crowding_dist = np.zeros(len(objectives))\n        crowding_dist[0] = crowding_dist[-1] = float('inf')\n\n        for i in range(1, len(objectives)-1):\n            crowding_dist[sorted_indices[i]] = (\n                (objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]) +\n                (objectives_sorted[i+1, 1] - objectives_sorted[i-1, 1])\n            )\n\n        selected_idx = np.argmax(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: variable-length segment relocation\n    segment_length = random.randint(2, min(5, n // 3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    insertion_point = random.randint(0, n - segment_length)\n    while insertion_point >= start and insertion_point < start + segment_length:\n        insertion_point = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:insertion_point],\n        segment,\n        new_solution[insertion_point:]\n    ])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7580354906035917,
            0.5096577405929565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) < 2:\n        selected_idx = 0\n    else:\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n\n        crowding_dist = np.zeros(len(objectives))\n        crowding_dist[0] = crowding_dist[-1] = float('inf')\n\n        for i in range(1, len(objectives)-1):\n            crowding_dist[sorted_indices[i]] = (\n                (objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]) +\n                (objectives_sorted[i+1, 1] - objectives_sorted[i-1, 1])\n            )\n\n        selected_idx = np.argmax(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: variable-length segment relocation\n    segment_length = random.randint(2, min(5, n // 3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    insertion_point = random.randint(0, n - segment_length)\n    while insertion_point >= start and insertion_point < start + segment_length:\n        insertion_point = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:insertion_point],\n        segment,\n        new_solution[insertion_point:]\n    ])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search that combines adaptive segment insertion with dynamic edge flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective values with solution quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    selection_probs = np.exp(-combined_scores / np.sum(combined_scores))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with dynamic edge flipping\n    segment_length = max(2, min(5, n // 4))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Dynamic edge flipping\n    for i in range(len(segment)-1):\n        if random.random() < 0.3:\n            segment[i], segment[i+1] = segment[i+1], segment[i]\n\n    # Insert segment at a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Edge refinement with objective-aware flipping\n    for _ in range(min(3, n // 3)):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            flipped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if flipped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.918781145575949,
            0.2786213159561157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective values with solution quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    selection_probs = np.exp(-combined_scores / np.sum(combined_scores))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with dynamic edge flipping\n    segment_length = max(2, min(5, n // 4))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Dynamic edge flipping\n    for i in range(len(segment)-1):\n        if random.random() < 0.3:\n            segment[i], segment[i+1] = segment[i+1], segment[i]\n\n    # Insert segment at a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Edge refinement with objective-aware flipping\n    for _ in range(min(3, n // 3)):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            flipped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if flipped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion with adaptive segment length and distance-based edge selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * (obj[0] - mean_obj[0]) + weights[1] * (obj[1] - mean_obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Distance-based edge insertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.84990625813905,
            0.27704304456710815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * (obj[0] - mean_obj[0]) + weights[1] * (obj[1] - mean_obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Distance-based edge insertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and solution structure diversity, then applies a novel hybrid local search combining segment rotation, adaptive node swapping, and objective-aware edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 1: Segment rotation (rotate a random segment by a random amount)\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        rotation = random.randint(1, segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Adaptive node swapping (swap nodes based on their distance in both objectives)\n        if random.random() < 0.6:\n            i, j = random.sample(range(n), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            dist1 = distance_matrix_1[node_i, node_j]\n            dist2 = distance_matrix_2[node_i, node_j]\n            if (dist1 + dist2) / 2 > (distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                                      distance_matrix_1[node_j, new_solution[(j+1)%n]] +\n                                      distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                                      distance_matrix_2[node_j, new_solution[(j+1)%n]]) / 4:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Objective-aware edge insertion (insert a node between two nodes with similar distances in both objectives)\n        if random.random() < 0.5:\n            node_to_move = random.choice(new_solution)\n            current_pos = np.where(new_solution == node_to_move)[0][0]\n            candidates = []\n            for i in range(n):\n                if i != current_pos and i != (current_pos + 1) % n:\n                    prev_node = new_solution[(current_pos - 1) % n]\n                    next_node = new_solution[(current_pos + 1) % n]\n                    candidate_node = new_solution[i]\n                    dist1_prev = distance_matrix_1[prev_node, candidate_node]\n                    dist1_next = distance_matrix_1[candidate_node, next_node]\n                    dist2_prev = distance_matrix_2[prev_node, candidate_node]\n                    dist2_next = distance_matrix_2[candidate_node, next_node]\n                    if abs(dist1_prev - dist1_next) + abs(dist2_prev - dist2_next) < 10:  # Threshold for similarity\n                        candidates.append(i)\n            if candidates:\n                new_pos = random.choice(candidates)\n                new_solution = np.delete(new_solution, current_pos)\n                new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9601822280618184,
            0.3145136833190918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 1: Segment rotation (rotate a random segment by a random amount)\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        rotation = random.randint(1, segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Adaptive node swapping (swap nodes based on their distance in both objectives)\n        if random.random() < 0.6:\n            i, j = random.sample(range(n), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            dist1 = distance_matrix_1[node_i, node_j]\n            dist2 = distance_matrix_2[node_i, node_j]\n            if (dist1 + dist2) / 2 > (distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                                      distance_matrix_1[node_j, new_solution[(j+1)%n]] +\n                                      distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                                      distance_matrix_2[node_j, new_solution[(j+1)%n]]) / 4:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Objective-aware edge insertion (insert a node between two nodes with similar distances in both objectives)\n        if random.random() < 0.5:\n            node_to_move = random.choice(new_solution)\n            current_pos = np.where(new_solution == node_to_move)[0][0]\n            candidates = []\n            for i in range(n):\n                if i != current_pos and i != (current_pos + 1) % n:\n                    prev_node = new_solution[(current_pos - 1) % n]\n                    next_node = new_solution[(current_pos + 1) % n]\n                    candidate_node = new_solution[i]\n                    dist1_prev = distance_matrix_1[prev_node, candidate_node]\n                    dist1_next = distance_matrix_1[candidate_node, next_node]\n                    dist2_prev = distance_matrix_2[prev_node, candidate_node]\n                    dist2_next = distance_matrix_2[candidate_node, next_node]\n                    if abs(dist1_prev - dist1_next) + abs(dist2_prev - dist2_next) < 10:  # Threshold for similarity\n                        candidates.append(i)\n            if candidates:\n                new_pos = random.choice(candidates)\n                new_solution = np.delete(new_solution, current_pos)\n                new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{A novel algorithm that combines multi-objective selection with a hybrid local search strategy featuring adaptive segment reversal and intelligent edge swapping based on combined objective distances, ensuring diverse exploration of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    balance_scores = np.abs(normalized_obj[:, 0] - normalized_obj[:, 1])\n    selected_idx = np.argmin(balance_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and edge swapping\n    if n > 4:\n        # Step 1: Reverse a random segment based on combined objective distances\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        if (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]) < \\\n           (distance_matrix_1[segment[0], segment[1]] + distance_matrix_2[segment[0], segment[1]]):\n            new_solution[i:j+1] = segment[::-1]\n\n        # Step 2: Swap edges based on combined distance improvement\n        a, b = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b]]) > \\\n           (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.904129029669043,
            0.26496779918670654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    balance_scores = np.abs(normalized_obj[:, 0] - normalized_obj[:, 1])\n    selected_idx = np.argmin(balance_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and edge swapping\n    if n > 4:\n        # Step 1: Reverse a random segment based on combined objective distances\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        if (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]) < \\\n           (distance_matrix_1[segment[0], segment[1]] + distance_matrix_2[segment[0], segment[1]]):\n            new_solution[i:j+1] = segment[::-1]\n\n        # Step 2: Swap edges based on combined distance improvement\n        a, b = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b]]) > \\\n           (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective difference metric, then applies a hybrid local search combining segment reversal and edge insertion with adaptive segment lengths and distance-aware edge selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_diff = [(obj[0] - min_obj[0]) / (max_obj[0] - min_obj[0] + 1e-6) +\n                      (obj[1] - min_obj[1]) / (max_obj[1] - min_obj[1] + 1e-6)\n                      for obj in objectives]\n    selected_idx = np.argmin(normalized_diff)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = max(2, min(n // 3, random.randint(2, n // 3)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Distance-aware edge insertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.769535568153708,
            0.2592417597770691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_diff = [(obj[0] - min_obj[0]) / (max_obj[0] - min_obj[0] + 1e-6) +\n                      (obj[1] - min_obj[1]) / (max_obj[1] - min_obj[1] + 1e-6)\n                      for obj in objectives]\n    selected_idx = np.argmin(normalized_diff)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = max(2, min(n // 3, random.randint(2, n // 3)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Distance-aware edge insertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This algorithm selects a solution from the archive using a Pareto-frontier aware selection criterion, then applies a novel path-splitting and reordering operator that combines segments from multiple solutions to create a new neighbor while ensuring feasibility through a constrained merging strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-frontier aware selection\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Identify Pareto-front solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    pareto_indices = np.where(~is_dominated)[0]\n    if len(pareto_indices) > 0:\n        selected_idx = np.random.choice(pareto_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Path-splitting and reordering operator\n    num_splits = random.randint(2, min(4, n // 3))\n    split_points = sorted(random.sample(range(1, n), num_splits - 1))\n    segments = []\n    prev = 0\n\n    for point in split_points:\n        segments.append(base_solution[prev:point])\n        prev = point\n    segments.append(base_solution[prev:])\n\n    # Reorder segments with distance-based constraints\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility through constrained merging\n    visited = set()\n    temp_solution = []\n    for node in new_solution:\n        if node not in visited:\n            temp_solution.append(node)\n            visited.add(node)\n\n    # Complete the tour with missing nodes\n    missing_nodes = set(range(n)) - visited\n    if missing_nodes:\n        temp_solution.extend(list(missing_nodes))\n\n    new_solution = np.array(temp_solution)\n\n    # Validate solution\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8532954928981424,
            4.94864159822464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-frontier aware selection\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Identify Pareto-front solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    pareto_indices = np.where(~is_dominated)[0]\n    if len(pareto_indices) > 0:\n        selected_idx = np.random.choice(pareto_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Path-splitting and reordering operator\n    num_splits = random.randint(2, min(4, n // 3))\n    split_points = sorted(random.sample(range(1, n), num_splits - 1))\n    segments = []\n    prev = 0\n\n    for point in split_points:\n        segments.append(base_solution[prev:point])\n        prev = point\n    segments.append(base_solution[prev:])\n\n    # Reorder segments with distance-based constraints\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility through constrained merging\n    visited = set()\n    temp_solution = []\n    for node in new_solution:\n        if node not in visited:\n            temp_solution.append(node)\n            visited.add(node)\n\n    # Complete the tour with missing nodes\n    missing_nodes = set(range(n)) - visited\n    if missing_nodes:\n        temp_solution.extend(list(missing_nodes))\n\n    new_solution = np.array(temp_solution)\n\n    # Validate solution\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a novel local search operator that combines a multi-segment reversal with adaptive edge insertion and rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8010461894086018,
            8.736731469631195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node relinking and partial crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = 0\n        for i in range(len(sol)):\n            diversity += abs(sol[i] - sol[(i+1)%len(sol)])\n        diversity_scores.append(diversity)\n\n    combined_scores = [weights[0] * obj[0] + weights[1] * obj[1] - 0.5 * div\n                      for (obj, div) in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node relinking with objective-aware selection\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        def calculate_improvement(a, b, c):\n            original = distance_matrix_1[a, b] + distance_matrix_1[b, c] + distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            new = distance_matrix_1[a, c] + distance_matrix_1[c, b] + distance_matrix_2[a, c] + distance_matrix_2[c, b]\n            return original - new\n\n        if calculate_improvement(new_solution[(i-1)%n], new_solution[i], new_solution[(i+1)%n]) > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Partial crossover with edge preservation\n    if n > 4:\n        crossover_point = random.randint(1, n-2)\n        new_solution[crossover_point:] = new_solution[crossover_point:][::-1]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7125351165798416,
            0.6425604820251465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = 0\n        for i in range(len(sol)):\n            diversity += abs(sol[i] - sol[(i+1)%len(sol)])\n        diversity_scores.append(diversity)\n\n    combined_scores = [weights[0] * obj[0] + weights[1] * obj[1] - 0.5 * div\n                      for (obj, div) in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node relinking with objective-aware selection\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        def calculate_improvement(a, b, c):\n            original = distance_matrix_1[a, b] + distance_matrix_1[b, c] + distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            new = distance_matrix_1[a, c] + distance_matrix_1[c, b] + distance_matrix_2[a, c] + distance_matrix_2[c, b]\n            return original - new\n\n        if calculate_improvement(new_solution[(i-1)%n], new_solution[i], new_solution[(i+1)%n]) > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Partial crossover with edge preservation\n    if n > 4:\n        crossover_point = random.randint(1, n-2)\n        new_solution[crossover_point:] = new_solution[crossover_point:][::-1]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective-structural selection that combines Pareto dominance with structural diversity, then applies a novel local search combining adaptive path reversal and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine Pareto dominance with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated_indices = set()\n    for i in range(len(objectives)):\n        is_dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated_indices.add(i)\n\n    if non_dominated_indices:\n        selected_idx = random.choice(list(non_dominated_indices))\n    else:\n        # If no non-dominated, select based on crowding distance\n        crowding = []\n        for i in range(len(objectives)):\n            distances = []\n            for j in range(len(objectives)):\n                if i != j:\n                    distances.append(np.sqrt((objectives[j][0] - objectives[i][0])**2 + (objectives[j][1] - objectives[i][1])**2))\n            distances.sort()\n            crowding.append(distances[1] if len(distances) > 1 else float('inf'))\n        selected_idx = np.argmax(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive path reversal and segment relocation\n    if n > 3:\n        # Step 1: Adaptive path reversal (reverse a segment based on distance improvement)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost change\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(b+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]])\n\n        if new_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Segment relocation (move a segment to a new position)\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.delete(new_solution, range(c, d+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8819331303023223,
            1.56631600856781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine Pareto dominance with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated_indices = set()\n    for i in range(len(objectives)):\n        is_dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated_indices.add(i)\n\n    if non_dominated_indices:\n        selected_idx = random.choice(list(non_dominated_indices))\n    else:\n        # If no non-dominated, select based on crowding distance\n        crowding = []\n        for i in range(len(objectives)):\n            distances = []\n            for j in range(len(objectives)):\n                if i != j:\n                    distances.append(np.sqrt((objectives[j][0] - objectives[i][0])**2 + (objectives[j][1] - objectives[i][1])**2))\n            distances.sort()\n            crowding.append(distances[1] if len(distances) > 1 else float('inf'))\n        selected_idx = np.argmax(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive path reversal and segment relocation\n    if n > 3:\n        # Step 1: Adaptive path reversal (reverse a segment based on distance improvement)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost change\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(b+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]])\n\n        if new_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Segment relocation (move a segment to a new position)\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.delete(new_solution, range(c, d+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This new algorithm selects a solution from the archive using a crowding-distance-aware selection to balance exploration and exploitation, then applies a hybrid local search combining adaptive 3-opt and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: crowding-distance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-6)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive 3-opt and segment reversal\n    if n > 4:\n        # Step 1: Adaptive 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]]) + \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]] +\n                    distance_matrix_1[new_solution[k], new_solution[i]]) + \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]] +\n                    distance_matrix_2[new_solution[k], new_solution[i]])\n        if new_cost < original_cost:\n            segment = new_solution[i:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[k+1:]])\n\n        # Step 2: Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6410164867999709,
            0.5321220755577087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: crowding-distance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-6)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive 3-opt and segment reversal\n    if n > 4:\n        # Step 1: Adaptive 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]]) + \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]] +\n                    distance_matrix_1[new_solution[k], new_solution[i]]) + \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]] +\n                    distance_matrix_2[new_solution[k], new_solution[i]])\n        if new_cost < original_cost:\n            segment = new_solution[i:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[k+1:]])\n\n        # Step 2: Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection that prioritizes solutions with high structural diversity and applies a novel local search strategy combining adaptive edge reversal and path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high structural diversity\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        diversity = 0\n        for j, other_sol in enumerate(solutions):\n            if i != j:\n                diversity += np.sum(sol != other_sol)\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive edge reversal and path inversion\n    if n > 2:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its cost)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + \\\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        reversed_cost = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]] + \\\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path inversion (invert a path between two nodes)\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        path = new_solution[i:j+1]\n        inverted_path = path[::-1]\n        new_solution[i:j+1] = inverted_path\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7328694316842266,
            14.14761370420456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high structural diversity\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        diversity = 0\n        for j, other_sol in enumerate(solutions):\n            if i != j:\n                diversity += np.sum(sol != other_sol)\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive edge reversal and path inversion\n    if n > 2:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its cost)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + \\\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        reversed_cost = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]] + \\\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path inversion (invert a path between two nodes)\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        path = new_solution[i:j+1]\n        inverted_path = path[::-1]\n        new_solution[i:j+1] = inverted_path\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{\"This algorithm selects a solution from the archive based on a fitness measure combining both objectives, then applies a novel hybrid local search combining segment inversion and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.\"}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select the solution with the best combined objective value (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    combined_obj = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with adaptive edge swapping\n    if n > 3:\n        # Invert a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Adaptive edge swapping based on distance improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and (abs(k - l) > 1 or (k == 0 and l == n-1) or (l == 0 and k == n-1)):\n            # Calculate current and potential distances\n            current_d1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            current_d2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n            potential_d1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n            potential_d2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n            # Swap if both objectives improve\n            if (potential_d1 < current_d1 and potential_d2 < current_d2):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7617086467082139,
            0.31297212839126587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select the solution with the best combined objective value (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    combined_obj = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with adaptive edge swapping\n    if n > 3:\n        # Invert a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Adaptive edge swapping based on distance improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and (abs(k - l) > 1 or (k == 0 and l == n-1) or (l == 0 and k == n-1)):\n            # Calculate current and potential distances\n            current_d1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            current_d2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n            potential_d1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n            potential_d2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n            # Swap if both objectives improve\n            if (potential_d1 < current_d1 and potential_d2 < current_d2):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel hybrid local search combining segment rotation, edge reversal, and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive size\n    segment_size = max(2, n // 3)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    rotation = random.randint(1, segment_size - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = rotated_segment\n\n    # Edge reversal with probability\n    if random.random() < 0.7:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic edge swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7607790256981192,
            0.22140085697174072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive size\n    segment_size = max(2, n // 3)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    rotation = random.randint(1, segment_size - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = rotated_segment\n\n    # Edge reversal with probability\n    if random.random() < 0.7:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic edge swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective trade-off, then applies a hybrid local search combining adaptive segment shuffling and cross-space edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.mean(objectives, axis=0)) / (np.std(objectives, axis=0) + 1e-6)\n    distances = np.linalg.norm(normalized, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment shuffling\n    segment_size = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    shuffled_segment = np.random.permutation(segment)\n    new_solution[start:start+segment_size] = shuffled_segment\n\n    # Cross-space edge swapping\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n\n    # Calculate edge costs in both spaces\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b])\n\n    current_cost = edge_cost(new_solution[i], new_solution[j])\n    candidate_cost = edge_cost(new_solution[i], new_solution[j])\n\n    # Swap if beneficial in either space\n    if (current_cost[0] > candidate_cost[0]) or (current_cost[1] > candidate_cost[1]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9197277232804375,
            0.29289984703063965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.mean(objectives, axis=0)) / (np.std(objectives, axis=0) + 1e-6)\n    distances = np.linalg.norm(normalized, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment shuffling\n    segment_size = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    shuffled_segment = np.random.permutation(segment)\n    new_solution[start:start+segment_size] = shuffled_segment\n\n    # Cross-space edge swapping\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n\n    # Calculate edge costs in both spaces\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b])\n\n    current_cost = edge_cost(new_solution[i], new_solution[j])\n    candidate_cost = edge_cost(new_solution[i], new_solution[j])\n\n    # Swap if beneficial in either space\n    if (current_cost[0] > candidate_cost[0]) or (current_cost[1] > candidate_cost[1]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A novel hybrid local search algorithm that combines segment inversion with edge swapping and insertion, while prioritizing solutions with balanced objective values through weighted selection, to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    scores = 0.5 * norm_obj1 + 0.5 * norm_obj2\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply segment inversion\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply edge swap\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply insertion\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7400336268839897,
            0.26491600275039673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    scores = 0.5 * norm_obj1 + 0.5 * norm_obj2\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply segment inversion\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply edge swap\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply insertion\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a dynamic score combining objective values and solution diversity, then applies a hybrid local search combining edge exchange, segment inversion, and adaptive insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    n = len(instance)\n    if len(archive) == 0:\n        return np.random.permutation(n)\n\n    # Select solution based on dynamic score combining objectives and diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = np.sum(np.abs(sol - np.mean(archive[0][0])))\n        scores.append((obj1 + obj2) / (1 + diversity))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge exchange, segment inversion, and insertion\n    for _ in range(3):  # Multiple iterations for better exploration\n        operation = np.random.choice(['exchange', 'invert', 'insert'])\n\n        if operation == 'exchange':\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'invert':\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operation == 'insert':\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if j - i > 2:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8800918502563132,
            0.44214099645614624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    n = len(instance)\n    if len(archive) == 0:\n        return np.random.permutation(n)\n\n    # Select solution based on dynamic score combining objectives and diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = np.sum(np.abs(sol - np.mean(archive[0][0])))\n        scores.append((obj1 + obj2) / (1 + diversity))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge exchange, segment inversion, and insertion\n    for _ in range(3):  # Multiple iterations for better exploration\n        operation = np.random.choice(['exchange', 'invert', 'insert'])\n\n        if operation == 'exchange':\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'invert':\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operation == 'insert':\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if j - i > 2:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This algorithm selects a solution from the archive based on a quality-diversity trade-off metric, then applies a novel local search combining adaptive segment rotation and distance-aware edge flipping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: quality-diversity trade-off\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.sum(objectives, axis=1)\n    diversity_scores = [np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))]\n    combined_scores = scores - 0.5 * np.array(diversity_scores)\n    selected_idx = np.argmin(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation = random.randint(1, segment_length - 1)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n        # Distance-aware edge flipping\n        i = random.randint(0, n - 1)\n        j = (i + random.randint(1, min(5, n // 2))) % n\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.5572844675880141,
            0.8887776732444763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: quality-diversity trade-off\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.sum(objectives, axis=1)\n    diversity_scores = [np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))]\n    combined_scores = scores - 0.5 * np.array(diversity_scores)\n    selected_idx = np.argmin(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation = random.randint(1, segment_length - 1)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n        # Distance-aware edge flipping\n        i = random.randint(0, n - 1)\n        j = (i + random.randint(1, min(5, n // 2))) % n\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 4))\n    segment_lengths = sorted(random.sample(range(2, n // 3), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(4, n // 3)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9252674780060287,
            3.215651035308838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 4))\n    segment_lengths = sorted(random.sample(range(2, n // 3), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(4, n // 3)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, with higher weight for the first objective, and applies a novel local search strategy that rotates a random segment, inserts a node elsewhere, and optionally swaps two nodes to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select two nodes to swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a node to move to a different position\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8323196469329961,
            0.2734845280647278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select two nodes to swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a node to move to a different position\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9530846501981953,
            0.24166947603225708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding distance metric to identify solutions in less explored regions, then applies a hybrid local search combining node relinking with a constrained edge swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node relinking with constrained edge swap\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == (i+1)%n or j == (i-1)%n:\n        j = random.randint(0, n-1)\n\n    # Check distance constraints\n    if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] and\n        distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]):\n\n        # Perform constrained edge swap\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8990418117216679,
            0.6817956566810608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node relinking with constrained edge swap\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == (i+1)%n or j == (i-1)%n:\n        j = random.randint(0, n-1)\n\n    # Check distance constraints\n    if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] and\n        distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]):\n\n        # Perform constrained edge swap\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The new algorithm selects a solution from the archive by combining objective values with adaptive weights, then applies a hybrid local search combining segment rotation, edge reversal, and node displacement to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_vals = [obj[0] for _, obj in archive]\n    obj2_vals = [obj[1] for _, obj in archive]\n    obj1_std = np.std(obj1_vals)\n    obj2_std = np.std(obj2_vals)\n\n    if obj1_std > obj2_std:\n        weights = [0.8, 0.2]\n    else:\n        weights = [0.4, 0.6]\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive size\n    segment_size = max(2, n // 3)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    rotation = random.randint(1, segment_size - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = rotated_segment\n\n    # Edge reversal with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j and j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node displacement with distance consideration\n    if random.random() < 0.5:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8979298936572053,
            0.27864253520965576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_vals = [obj[0] for _, obj in archive]\n    obj2_vals = [obj[1] for _, obj in archive]\n    obj1_std = np.std(obj1_vals)\n    obj2_std = np.std(obj2_vals)\n\n    if obj1_std > obj2_std:\n        weights = [0.8, 0.2]\n    else:\n        weights = [0.4, 0.6]\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive size\n    segment_size = max(2, n // 3)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    rotation = random.randint(1, segment_size - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = rotated_segment\n\n    # Edge reversal with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j and j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node displacement with distance consideration\n    if random.random() < 0.5:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] + obj[1]) / 2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment reversal and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Reverse a segment and swap a random edge\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            new_solution[[k, (k + 1) % n]] = new_solution[[(k + 1) % n, k]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9657362350399945,
            0.3860129117965698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] + obj[1]) / 2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment reversal and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Reverse a segment and swap a random edge\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            new_solution[[k, (k + 1) % n]] = new_solution[[(k + 1) % n, k]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-aware selection to favor less crowded regions of the Pareto front, then applies a novel local search combining adaptive segment reversal and randomized node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: crowding-distance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and randomized node insertion\n    if n > 3:\n        # Step 1: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        if (distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b+1 if b+1 < n else 0]]) > \\\n           (distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b+1 if b+1 < n else 0]]):\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Randomized node insertion\n        node = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8069833546528693,
            0.30018895864486694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: crowding-distance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and randomized node insertion\n    if n > 3:\n        # Step 1: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        if (distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b+1 if b+1 < n else 0]]) > \\\n           (distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b+1 if b+1 < n else 0]]):\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Randomized node insertion\n        node = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9814765070827647,
            0.603223979473114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in less crowded regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n        crowding = np.zeros(len(objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(objectives)-1):\n            crowding[i] = (objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0])\n        selected_idx = sorted_indices[np.argmin(crowding)]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path reinsertion\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment if it improves both objectives)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path reinsertion (reinsert a path segment with adaptive position selection)\n        c, d = sorted(random.sample(range(n), 2))\n        path = new_solution[c:d+1]\n        new_solution = np.delete(new_solution, range(c, d+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, path)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7704702389613429,
            0.3514888882637024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n        crowding = np.zeros(len(objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(objectives)-1):\n            crowding[i] = (objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0])\n        selected_idx = sorted_indices[np.argmin(crowding)]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path reinsertion\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment if it improves both objectives)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path reinsertion (reinsert a path segment with adaptive position selection)\n        c, d = sorted(random.sample(range(n), 2))\n        path = new_solution[c:d+1]\n        new_solution = np.delete(new_solution, range(c, d+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, path)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel hybrid local search combining segment swapping, node relinking, and probabilistic edge insertion to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment swapping with adaptive size\n    if n > 3:\n        segment_size = max(2, min(5, n // 3))\n        start1 = random.randint(0, n - segment_size)\n        end1 = start1 + segment_size\n        start2 = random.randint(0, n - segment_size)\n        while abs(start1 - start2) < segment_size:\n            start2 = random.randint(0, n - segment_size)\n        end2 = start2 + segment_size\n        segment1 = new_solution[start1:end1]\n        segment2 = new_solution[start2:end2]\n        new_solution[start1:end1] = segment2\n        new_solution[start2:end2] = segment1\n\n    # Node relinking with distance-based probability\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Probabilistic edge insertion with distance consideration\n    if random.random() < 0.3 and n > 2:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n - 1)\n        if i > j:\n            i, j = j, i\n        edge = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8245434154526182,
            0.2124347686767578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment swapping with adaptive size\n    if n > 3:\n        segment_size = max(2, min(5, n // 3))\n        start1 = random.randint(0, n - segment_size)\n        end1 = start1 + segment_size\n        start2 = random.randint(0, n - segment_size)\n        while abs(start1 - start2) < segment_size:\n            start2 = random.randint(0, n - segment_size)\n        end2 = start2 + segment_size\n        segment1 = new_solution[start1:end1]\n        segment2 = new_solution[start2:end2]\n        new_solution[start1:end1] = segment2\n        new_solution[start2:end2] = segment1\n\n    # Node relinking with distance-based probability\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Probabilistic edge insertion with distance consideration\n    if random.random() < 0.3 and n > 2:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n - 1)\n        if i > j:\n            i, j = j, i\n        edge = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining node reinsertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    dominated_counts = [0] * len(objectives)\n    dominating_sets = [[] for _ in range(len(objectives))]\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1] and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominating_sets[i].append(j)\n            elif objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    # Select from the first front if available, otherwise from the entire archive\n    if fronts:\n        selected_idx = random.choice(fronts[0])\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node reinsertion with objective-aware selection\n    i = random.randint(0, n - 1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    j = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Segment rotation with distance-based selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8841488725190503,
            0.3005164861679077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    dominated_counts = [0] * len(objectives)\n    dominating_sets = [[] for _ in range(len(objectives))]\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1] and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominating_sets[i].append(j)\n            elif objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    # Select from the first front if available, otherwise from the entire archive\n    if fronts:\n        selected_idx = random.choice(fronts[0])\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node reinsertion with objective-aware selection\n    i = random.randint(0, n - 1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    j = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Segment rotation with distance-based selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This new algorithm selects a solution from the archive, applies a hybrid local search combining edge swaps and segment reversals, and ensures feasibility by verifying no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:  # Ensure segment has more than 2 nodes\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Swap two edges if it improves the solution\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n\n    # Calculate current and potential costs\n    current_cost = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    potential_cost = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    if potential_cost < current_cost:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8017995856842175,
            0.290113627910614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:  # Ensure segment has more than 2 nodes\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Swap two edges if it improves the solution\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n\n    # Calculate current and potential costs\n    current_cost = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    potential_cost = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    if potential_cost < current_cost:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive based on a trade-off between the two objectives, then applies a novel hybrid local search combining segment reversal, node swapping, and segment crossover with adaptive probabilities to generate a diverse set of high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (1 + abs(obj[0] - obj[1])) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probabilities based on solution quality\n    p_reverse = min(0.9, 0.3 + 0.6 * (1 - scores[selected_idx] / max(scores)))\n    p_swap = min(0.8, 0.2 + 0.6 * (1 - scores[selected_idx] / max(scores)))\n    p_crossover = min(0.7, 0.1 + 0.6 * (1 - scores[selected_idx] / max(scores)))\n\n    # Apply segment reversal with adaptive probability\n    if random.random() < p_reverse:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node swapping with adaptive probability\n    if random.random() < p_swap and n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply segment crossover with adaptive probability\n    if random.random() < p_crossover and n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        if a < b < c < d:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([\n                new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8504670039236499,
            0.26668572425842285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (1 + abs(obj[0] - obj[1])) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probabilities based on solution quality\n    p_reverse = min(0.9, 0.3 + 0.6 * (1 - scores[selected_idx] / max(scores)))\n    p_swap = min(0.8, 0.2 + 0.6 * (1 - scores[selected_idx] / max(scores)))\n    p_crossover = min(0.7, 0.1 + 0.6 * (1 - scores[selected_idx] / max(scores)))\n\n    # Apply segment reversal with adaptive probability\n    if random.random() < p_reverse:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node swapping with adaptive probability\n    if random.random() < p_swap and n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply segment crossover with adaptive probability\n    if random.random() < p_crossover and n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        if a < b < c < d:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([\n                new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection that considers both objective values and solution structure, then applies a hybrid local search combining adaptive edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))  # Exponential bias towards better solutions\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge insertion and segment reversal\n    if n > 3:\n        # Step 1: Adaptive edge insertion (insert a randomly selected node in a new position)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n        while abs(new_pos - current_pos) <= 1:  # Ensure significant position change\n            new_pos = random.randint(0, n-1)\n\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This algorithm selects a solution from the archive based on a quality-diversity trade-off, combining objective performance and structural diversity, then applies a hybrid local search combining adaptive segment rotation and distance-aware node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and distance-aware node insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation (rotate a segment by a random amount)\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = b - a + 1\n        rotation_amount = random.randint(1, segment_length - 1)\n        rotated_segment = np.roll(new_solution[a:b+1], rotation_amount)\n        new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Distance-aware node insertion (insert nodes based on combined distance)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        possible_positions = [i for i in range(n) if abs(i - current_pos) > 1]\n\n        if possible_positions:\n            # Calculate combined distance for each possible position\n            distances = []\n            for pos in possible_positions:\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n                dist = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] + \\\n                       distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                distances.append(dist)\n\n            # Insert at position with minimum combined distance\n            best_pos = possible_positions[np.argmin(distances)]\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9656752664616928,
            0.29661399126052856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good objectives and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    combined = np.sum(objectives, axis=1)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and distance-aware node insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation (rotate a segment by a random amount)\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = b - a + 1\n        rotation_amount = random.randint(1, segment_length - 1)\n        rotated_segment = np.roll(new_solution[a:b+1], rotation_amount)\n        new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Distance-aware node insertion (insert nodes based on combined distance)\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        possible_positions = [i for i in range(n) if abs(i - current_pos) > 1]\n\n        if possible_positions:\n            # Calculate combined distance for each possible position\n            distances = []\n            for pos in possible_positions:\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n                dist = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] + \\\n                       distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                distances.append(dist)\n\n            # Insert at position with minimum combined distance\n            best_pos = possible_positions[np.argmin(distances)]\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of crowding distance and objective dominance, then applies a novel edge swapping and path reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution based on crowding distance and objective dominance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: edge swapping and path reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Swap two edges\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8280581407649864,
            0.6674052476882935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution based on crowding distance and objective dominance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: edge swapping and path reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Swap two edges\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in less crowded regions of the Pareto front, then applies a hybrid local search combining adaptive segment reversal and node relocation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    if n == 1:\n        selected_idx = 0\n    else:\n        # Calculate crowding distances\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_dist = np.zeros(n)\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_dist[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-10)\n\n        sorted_indices = np.argsort(objectives[:, 1])\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_dist[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1] + 1e-10)\n\n        # Select from less crowded regions\n        selected_idx = np.argmin(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and node relocation\n    if n > 3:\n        # Step 1: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        if len(segment) > 1:\n            segment = np.flip(segment)\n            new_solution[a:b+1] = segment\n\n        # Step 2: Node relocation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7596653482849748,
            0.5012927651405334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    if n == 1:\n        selected_idx = 0\n    else:\n        # Calculate crowding distances\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_dist = np.zeros(n)\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_dist[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-10)\n\n        sorted_indices = np.argsort(objectives[:, 1])\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_dist[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1] + 1e-10)\n\n        # Select from less crowded regions\n        selected_idx = np.argmin(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and node relocation\n    if n > 3:\n        # Step 1: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        if len(segment) > 1:\n            segment = np.flip(segment)\n            new_solution[a:b+1] = segment\n\n        # Step 2: Node relocation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment inversion, adaptive edge flipping, and probabilistic node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        for i in range(len(segments)):\n            if random.random() < 0.5:\n                segments[i] = segments[i][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge flipping\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        if random.random() < 0.5:\n            new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic node insertion based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8236354460587918,
            0.31620198488235474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        for i in range(len(segments)):\n            if random.random() < 0.5:\n                segments[i] = segments[i][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge flipping\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        if random.random() < 0.5:\n            new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic node insertion based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection metric that combines Pareto dominance, structural diversity, and objective-space proximity, then applies a novel local search combining multi-segment inversion, adaptive edge flipping, and probabilistic segment reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance, diversity, and objective proximity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Select based on Pareto front and objective proximity to ideal point\n        ideal_point = np.min(objectives, axis=0)\n        selected_idx = min(pareto_front, key=lambda i: np.linalg.norm(objectives[i] - ideal_point))\n    else:\n        # Select based on diversity and objective proximity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment selection\n    if n > 4:\n        num_segments = random.randint(2, min(5, n//2))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        for i in range(len(segments)):\n            if random.random() < 0.7:\n                segments[i] = segments[i][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge flipping based on objective improvement\n    if n > 3:\n        k = random.randint(2, min(4, n//3))\n        for _ in range(k):\n            i = random.randint(0, n-1)\n            j = (i + 1) % n\n            current_cost = distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]] + \\\n                           distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]\n            flipped_cost = distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[i-1]][new_solution[j]] + \\\n                           distance_matrix_1[new_solution[j]][new_solution[i]] + distance_matrix_2[new_solution[j]][new_solution[i]]\n            if flipped_cost < current_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment reinsertion based on objective improvement\n    if n > 5:\n        for _ in range(random.randint(1, min(2, n//5))):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            current_cost = sum(distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]]\n                              for i in range(a, b+1)) + distance_matrix_1[new_solution[b]][new_solution[a]] + distance_matrix_2[new_solution[b]][new_solution[a]]\n            new_solution = np.delete(new_solution, range(a, b+1))\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment)\n            new_cost = sum(distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]]\n                          for i in range(insert_pos, insert_pos+len(segment))) + distance_matrix_1[new_solution[insert_pos+len(segment)-1]][new_solution[insert_pos]] + distance_matrix_2[new_solution[insert_pos+len(segment)-1]][new_solution[insert_pos]]\n            if new_cost >= current_cost and random.random() < 0.3:\n                # Revert if no improvement and random condition not met\n                new_solution = np.delete(new_solution, range(insert_pos, insert_pos+len(segment)))\n                new_solution = np.insert(new_solution, a, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8706014138821749,
            0.5394105911254883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance, diversity, and objective proximity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Select based on Pareto front and objective proximity to ideal point\n        ideal_point = np.min(objectives, axis=0)\n        selected_idx = min(pareto_front, key=lambda i: np.linalg.norm(objectives[i] - ideal_point))\n    else:\n        # Select based on diversity and objective proximity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment selection\n    if n > 4:\n        num_segments = random.randint(2, min(5, n//2))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        for i in range(len(segments)):\n            if random.random() < 0.7:\n                segments[i] = segments[i][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge flipping based on objective improvement\n    if n > 3:\n        k = random.randint(2, min(4, n//3))\n        for _ in range(k):\n            i = random.randint(0, n-1)\n            j = (i + 1) % n\n            current_cost = distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]] + \\\n                           distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]\n            flipped_cost = distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[i-1]][new_solution[j]] + \\\n                           distance_matrix_1[new_solution[j]][new_solution[i]] + distance_matrix_2[new_solution[j]][new_solution[i]]\n            if flipped_cost < current_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment reinsertion based on objective improvement\n    if n > 5:\n        for _ in range(random.randint(1, min(2, n//5))):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            current_cost = sum(distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]]\n                              for i in range(a, b+1)) + distance_matrix_1[new_solution[b]][new_solution[a]] + distance_matrix_2[new_solution[b]][new_solution[a]]\n            new_solution = np.delete(new_solution, range(a, b+1))\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment)\n            new_cost = sum(distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]]\n                          for i in range(insert_pos, insert_pos+len(segment))) + distance_matrix_1[new_solution[insert_pos+len(segment)-1]][new_solution[insert_pos]] + distance_matrix_2[new_solution[insert_pos+len(segment)-1]][new_solution[insert_pos]]\n            if new_cost >= current_cost and random.random() < 0.3:\n                # Revert if no improvement and random condition not met\n                new_solution = np.delete(new_solution, range(insert_pos, insert_pos+len(segment)))\n                new_solution = np.insert(new_solution, a, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective-distance metric that combines Pareto dominance with spatial proximity, then applies a novel local search combining segment inversion, probabilistic edge insertion, and adaptive path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and spatial proximity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on spatial proximity to centroid\n        centroid = np.mean(objectives, axis=0)\n        distances = [np.linalg.norm(obj - centroid) for obj in objectives]\n        selected_idx = np.argmin(distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive length\n    if n > 4:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Probabilistic edge insertion\n    if n > 3:\n        for _ in range(random.randint(1, min(2, n//3))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.7 * (1 - (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) /\n                            (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]] +\n                             distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    if i < j:\n                        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[i:i+1], new_solution[j+1:]])\n                    else:\n                        new_solution = np.concatenate([new_solution[:j+1], new_solution[i:i+1], new_solution[j+1:i], new_solution[j:j+1], new_solution[i+1:]])\n\n    # Adaptive path reversal\n    if n > 5:\n        k = random.randint(3, min(6, n//2))\n        start = random.randint(0, n - k)\n        path = new_solution[start:start+k]\n        reversed_path = path[::-1]\n        improvement = (distance_matrix_1[path[-1]][path[0]] + distance_matrix_2[path[-1]][path[0]]) - \\\n                      (distance_matrix_1[path[0]][path[1]] + distance_matrix_2[path[0]][path[1]] +\n                       distance_matrix_1[path[-2]][path[-1]] + distance_matrix_2[path[-2]][path[-1]])\n        if improvement > 0:\n            new_solution[start:start+k] = reversed_path\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9214416097498654,
            0.5590630173683167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and spatial proximity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on spatial proximity to centroid\n        centroid = np.mean(objectives, axis=0)\n        distances = [np.linalg.norm(obj - centroid) for obj in objectives]\n        selected_idx = np.argmin(distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive length\n    if n > 4:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Probabilistic edge insertion\n    if n > 3:\n        for _ in range(random.randint(1, min(2, n//3))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.7 * (1 - (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) /\n                            (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]] +\n                             distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    if i < j:\n                        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[i:i+1], new_solution[j+1:]])\n                    else:\n                        new_solution = np.concatenate([new_solution[:j+1], new_solution[i:i+1], new_solution[j+1:i], new_solution[j:j+1], new_solution[i+1:]])\n\n    # Adaptive path reversal\n    if n > 5:\n        k = random.randint(3, min(6, n//2))\n        start = random.randint(0, n - k)\n        path = new_solution[start:start+k]\n        reversed_path = path[::-1]\n        improvement = (distance_matrix_1[path[-1]][path[0]] + distance_matrix_2[path[-1]][path[0]]) - \\\n                      (distance_matrix_1[path[0]][path[1]] + distance_matrix_2[path[0]][path[1]] +\n                       distance_matrix_1[path[-2]][path[-1]] + distance_matrix_2[path[-2]][path[-1]])\n        if improvement > 0:\n            new_solution[start:start+k] = reversed_path\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This new algorithm selects a solution from the archive using a hybrid selection criterion that combines objective dominance and solution structure diversity, then applies a novel local search operator that combines multi-segment reversal with adaptive edge swapping and crossover-based perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy combining dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate dominance and diversity\n    dominance = np.zeros(len(archive))\n    diversity = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                dominated += 1\n        dominance[i] = dominated\n\n        for j in range(n):\n            pos = np.where(solutions[i] == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = (dominance + 1) / (diversity + 1)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(4, max(2, n // 4))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping with crossover perturbation\n    for _ in range(min(4, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Crossover-based perturbation\n    if len(archive) > 1 and random.random() < 0.3:\n        other_idx = (selected_idx + 1) % len(archive)\n        other_solution = archive[other_idx][0]\n\n        crossover_point = random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Fix duplicates\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n\n        for dup in duplicates:\n            missing = np.setdiff1d(np.arange(n), new_solution)\n            if len(missing) > 0:\n                replace_pos = np.where(new_solution == dup)[0][1:]\n                for pos in replace_pos:\n                    new_solution[pos] = random.choice(missing)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9130940065377842,
            3.9468199014663696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy combining dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate dominance and diversity\n    dominance = np.zeros(len(archive))\n    diversity = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                dominated += 1\n        dominance[i] = dominated\n\n        for j in range(n):\n            pos = np.where(solutions[i] == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = (dominance + 1) / (diversity + 1)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(4, max(2, n // 4))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping with crossover perturbation\n    for _ in range(min(4, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Crossover-based perturbation\n    if len(archive) > 1 and random.random() < 0.3:\n        other_idx = (selected_idx + 1) % len(archive)\n        other_solution = archive[other_idx][0]\n\n        crossover_point = random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Fix duplicates\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n\n        for dup in duplicates:\n            missing = np.setdiff1d(np.arange(n), new_solution)\n            if len(missing) > 0:\n                replace_pos = np.where(new_solution == dup)[0][1:]\n                for pos in replace_pos:\n                    new_solution[pos] = random.choice(missing)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This algorithm selects a solution from the archive and applies a hybrid local search that combines adaptive edge swapping with a novel node insertion mechanism to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge swapping with node insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Swap two edges with probability based on their cost difference\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n        if np.random.rand() < np.exp(-abs(cost1 - cost2)):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Insert a node from another segment with probability based on its potential improvement\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            potential_gain = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[i+1]] -\n                            distance_matrix_1[new_solution[i], new_solution[i+1]])\n            if np.random.rand() < np.exp(-abs(potential_gain)):\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = np.random.randint(0, len(new_solution)+1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8467117628709213,
            0.24433070421218872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge swapping with node insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Swap two edges with probability based on their cost difference\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n        if np.random.rand() < np.exp(-abs(cost1 - cost2)):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Insert a node from another segment with probability based on its potential improvement\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            potential_gain = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[i+1]] -\n                            distance_matrix_1[new_solution[i], new_solution[i+1]])\n            if np.random.rand() < np.exp(-abs(potential_gain)):\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = np.random.randint(0, len(new_solution)+1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection criterion to prioritize solutions in less crowded regions, then applies a hybrid local search combining node relocation and segment inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    crowding_distances = [0.0] * len(objectives)\n\n    # Sort by each objective and compute crowding distances\n    for i in range(2):\n        sorted_indices = np.argsort([obj[i] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for j in range(1, len(sorted_indices) - 1):\n            if objectives[sorted_indices[j+1]][i] == objectives[sorted_indices[j-1]][i]:\n                continue\n            crowding_distances[sorted_indices[j]] += (\n                objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]\n            )\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: node relocation and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random node relocation\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Random segment inversion\n    segment_size = max(2, n // 5)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6352866207075838,
            0.49363934993743896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    crowding_distances = [0.0] * len(objectives)\n\n    # Sort by each objective and compute crowding distances\n    for i in range(2):\n        sorted_indices = np.argsort([obj[i] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for j in range(1, len(sorted_indices) - 1):\n            if objectives[sorted_indices[j+1]][i] == objectives[sorted_indices[j-1]][i]:\n                continue\n            crowding_distances[sorted_indices[j]] += (\n                objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]\n            )\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: node relocation and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random node relocation\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Random segment inversion\n    segment_size = max(2, n // 5)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This new algorithm combines segment-based operations with adaptive edge perturbations, where segments are dynamically adjusted based on their contribution to both objectives, and edges are selectively altered to improve both tour lengths.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment based on its contribution to both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        # Dynamically adjust segment based on objective contributions\n        segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        if segment_cost1 > segment_cost2:\n            segment = segment[::-1]  # Reverse if first objective is worse\n        else:\n            segment = np.roll(segment, np.random.randint(1, len(segment)))  # Rotate otherwise\n\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Perturb edges based on their impact on both objectives\n    k = np.random.randint(0, n)\n    l = (k + np.random.randint(1, 3)) % n\n    edge_cost1 = distance_matrix_1[new_solution[k], new_solution[l]]\n    edge_cost2 = distance_matrix_2[new_solution[k], new_solution[l]]\n    if edge_cost1 > edge_cost2:\n        # Replace edge with a better one in the second objective\n        candidates = np.argsort(distance_matrix_2[new_solution[k], :])\n        for candidate in candidates:\n            if candidate not in new_solution:\n                new_solution[l] = candidate\n                break\n    else:\n        # Replace edge with a better one in the first objective\n        candidates = np.argsort(distance_matrix_1[new_solution[k], :])\n        for candidate in candidates:\n            if candidate not in new_solution:\n                new_solution[l] = candidate\n                break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6778274388491592,
            0.3009644150733948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment based on its contribution to both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        # Dynamically adjust segment based on objective contributions\n        segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        if segment_cost1 > segment_cost2:\n            segment = segment[::-1]  # Reverse if first objective is worse\n        else:\n            segment = np.roll(segment, np.random.randint(1, len(segment)))  # Rotate otherwise\n\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Perturb edges based on their impact on both objectives\n    k = np.random.randint(0, n)\n    l = (k + np.random.randint(1, 3)) % n\n    edge_cost1 = distance_matrix_1[new_solution[k], new_solution[l]]\n    edge_cost2 = distance_matrix_2[new_solution[k], new_solution[l]]\n    if edge_cost1 > edge_cost2:\n        # Replace edge with a better one in the second objective\n        candidates = np.argsort(distance_matrix_2[new_solution[k], :])\n        for candidate in candidates:\n            if candidate not in new_solution:\n                new_solution[l] = candidate\n                break\n    else:\n        # Replace edge with a better one in the first objective\n        candidates = np.argsort(distance_matrix_1[new_solution[k], :])\n        for candidate in candidates:\n            if candidate not in new_solution:\n                new_solution[l] = candidate\n                break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and a novel structural diversity metric, then applies a hybrid local search combining adaptive segment shuffling, parallel edge swapping, and strategic node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Compute structural diversity metric\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(i+1, len(archive)):\n            diff = np.sum(solutions[i] != solutions[j])\n            diversity[i] += diff\n            diversity[j] += diff\n\n    # Combine objective and diversity scores\n    combined_scores = (objectives[:, 0] + objectives[:, 1]) * (1 + diversity)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    if n > 3:\n        # Step 1: Adaptive segment shuffling\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_len] = segment\n\n        # Step 2: Parallel edge swapping\n        if random.random() < 0.6:\n            i, j = random.sample(range(n), 2)\n            k, l = random.sample(range(n), 2)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Step 3: Strategic node relocation\n        if random.random() < 0.5:\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9857778435653342,
            1.9177054166793823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Compute structural diversity metric\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(i+1, len(archive)):\n            diff = np.sum(solutions[i] != solutions[j])\n            diversity[i] += diff\n            diversity[j] += diff\n\n    # Combine objective and diversity scores\n    combined_scores = (objectives[:, 0] + objectives[:, 1]) * (1 + diversity)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    if n > 3:\n        # Step 1: Adaptive segment shuffling\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_len] = segment\n\n        # Step 2: Parallel edge swapping\n        if random.random() < 0.6:\n            i, j = random.sample(range(n), 2)\n            k, l = random.sample(range(n), 2)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Step 3: Strategic node relocation\n        if random.random() < 0.5:\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This algorithm selects a solution from the archive using a score function that balances objective values with adaptive weights based on solution diversity, then applies a hybrid local search combining segment reversal and edge insertion with adaptive segment sizes and position selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj_values = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in obj_values]\n    obj2_values = [obj[1] for obj in obj_values]\n    obj1_std = np.std(obj1_values) if len(obj1_values) > 1 else 1.0\n    obj2_std = np.std(obj2_values) if len(obj2_values) > 1 else 1.0\n    weights = [0.5 * (obj1_std / (obj1_std + obj2_std)), 0.5 * (obj2_std / (obj1_std + obj2_std))]\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment size based on solution length\n    segment_size = max(2, min(n // 3, n - 2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8492173163766757,
            0.2802072763442993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj_values = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in obj_values]\n    obj2_values = [obj[1] for obj in obj_values]\n    obj1_std = np.std(obj1_values) if len(obj1_values) > 1 else 1.0\n    obj2_std = np.std(obj2_values) if len(obj2_values) > 1 else 1.0\n    weights = [0.5 * (obj1_std / (obj1_std + obj2_std)), 0.5 * (obj2_std / (obj1_std + obj2_std))]\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment size based on solution length\n    segment_size = max(2, min(n // 3, n - 2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node swap, and edge insertion with adaptive probabilities to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = 1 / (1 + diversity)  # Prefer objectives with lower diversity\n    scores = np.sum(weights * objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probabilities based on solution quality\n    p_reverse = 0.7 if objectives[selected_idx][0] > np.median(objectives[:,0]) else 0.4\n    p_swap = 0.6 if objectives[selected_idx][1] > np.median(objectives[:,1]) else 0.3\n    p_insert = 0.5\n\n    # Apply segment reversal\n    if random.random() < p_reverse:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node swap\n    if random.random() < p_swap:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply edge insertion\n    if random.random() < p_insert and n > 3:\n        i, j, k = random.sample(range(n), 3)\n        if abs(i - j) > 1 and abs(j - k) > 1:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j], new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7510210493354966,
            0.2852834463119507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = 1 / (1 + diversity)  # Prefer objectives with lower diversity\n    scores = np.sum(weights * objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probabilities based on solution quality\n    p_reverse = 0.7 if objectives[selected_idx][0] > np.median(objectives[:,0]) else 0.4\n    p_swap = 0.6 if objectives[selected_idx][1] > np.median(objectives[:,1]) else 0.3\n    p_insert = 0.5\n\n    # Apply segment reversal\n    if random.random() < p_reverse:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node swap\n    if random.random() < p_swap:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply edge insertion\n    if random.random() < p_insert and n > 3:\n        i, j, k = random.sample(range(n), 3)\n        if abs(i - j) > 1 and abs(j - k) > 1:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j], new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment and reverse its edges\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.969510456280652,
            0.24821478128433228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment and reverse its edges\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment inversion, adaptive edge rotation, and probabilistic node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        for i in range(len(segments)):\n            if random.random() < 0.5:\n                segments[i] = segments[i][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation with probabilistic inversion\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        if random.random() < 0.7:\n            rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n            new_solution[start:start+k] = rotated\n        else:\n            new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic node insertion based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.6 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8887126905132621,
            0.3962637782096863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        for i in range(len(segments)):\n            if random.random() < 0.5:\n                segments[i] = segments[i][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation with probabilistic inversion\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        if random.random() < 0.7:\n            rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n            new_solution[start:start+k] = rotated\n        else:\n            new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic node insertion based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.6 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.880116782651734,
            0.13752394914627075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.880116782651734,
            0.13752394914627075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection to prioritize solutions in less crowded regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and segment permutation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    n_front = len(objectives)\n\n    # Calculate crowding distance\n    crowding_dist = np.zeros(n_front)\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, n_front-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and segment permutation\n    if n > 4:\n        # Step 1: Adaptive edge reversal (reverse a segment if it improves both objectives)\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n        # Calculate cost change\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= old_cost2):\n            new_solution = temp_solution\n\n        # Step 2: Segment permutation (swap two segments if it improves both objectives)\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        temp_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Calculate cost change\n        old_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(d+1)%n]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(b+1)%n]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(d+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(d+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(b+1)%n]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(d+1)%n]])\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= old_cost2):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.79994888803571,
            2.1190245747566223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    n_front = len(objectives)\n\n    # Calculate crowding distance\n    crowding_dist = np.zeros(n_front)\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, n_front-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and segment permutation\n    if n > 4:\n        # Step 1: Adaptive edge reversal (reverse a segment if it improves both objectives)\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n        # Calculate cost change\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= old_cost2):\n            new_solution = temp_solution\n\n        # Step 2: Segment permutation (swap two segments if it improves both objectives)\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        temp_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Calculate cost change\n        old_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(d+1)%n]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(b+1)%n]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(d+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(d+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(b+1)%n]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(d+1)%n]])\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= old_cost2):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This algorithm selects a solution from the archive based on a non-dominated sorting approach to identify Pareto-efficient solutions, then applies a novel local search strategy that combines partial tour reversal with constrained node swapping to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply constrained node swapping\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 2:\n            # Ensure the swap doesn't create immediate conflicts\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7837013337333623,
            0.40317612886428833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply constrained node swapping\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 2:\n            # Ensure the swap doesn't create immediate conflicts\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in less crowded regions of the Pareto front, then applies a hybrid local search combining adaptive segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        selected_idx = 0\n    else:\n        # Calculate crowding distance\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding = np.zeros(len(objectives))\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n        sorted_indices = np.argsort(objectives[:, 1])\n        crowding[sorted_indices[0]] += np.inf\n        crowding[sorted_indices[-1]] += np.inf\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n        selected_idx = np.argmin(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and node insertion\n    if n > 3:\n        # Step 1: Adaptive segment reversal (reverse a segment if it improves both objectives)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost1 = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost1 = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_1[new_solution[b-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[a]]\n        original_cost2 = distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[new_solution[b-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[a]]\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Node insertion (insert a node at a better position)\n        node = random.choice(new_solution)\n        current_pos = np.where(new_solution == node)[0][0]\n        new_pos = random.randint(0, n-1)\n        if new_pos != current_pos:\n            new_solution = np.delete(new_solution, current_pos)\n            if new_pos > current_pos:\n                new_pos -= 1\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7721114036438157,
            0.6134859919548035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        selected_idx = 0\n    else:\n        # Calculate crowding distance\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding = np.zeros(len(objectives))\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n        sorted_indices = np.argsort(objectives[:, 1])\n        crowding[sorted_indices[0]] += np.inf\n        crowding[sorted_indices[-1]] += np.inf\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n        selected_idx = np.argmin(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and node insertion\n    if n > 3:\n        # Step 1: Adaptive segment reversal (reverse a segment if it improves both objectives)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost1 = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost1 = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_1[new_solution[b-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[a]]\n        original_cost2 = distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[new_solution[b-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[a]]\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Node insertion (insert a node at a better position)\n        node = random.choice(new_solution)\n        current_pos = np.where(new_solution == node)[0][0]\n        new_pos = random.randint(0, n-1)\n        if new_pos != current_pos:\n            new_solution = np.delete(new_solution, current_pos)\n            if new_pos > current_pos:\n                new_pos -= 1\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection to promote diversity, then applies a hybrid local search combining edge reinsertion and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    if n == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(n)\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n        sorted_indices = np.argsort(objectives[:, 1])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid local search: edge reinsertion and path reversal\n        # Step 1: Edge reinsertion\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        edge = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, edge)\n\n        # Step 2: Path reversal\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.69034981870897,
            0.5667127966880798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    if n == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(n)\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n        sorted_indices = np.argsort(objectives[:, 1])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid local search: edge reinsertion and path reversal\n        # Step 1: Edge reinsertion\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        edge = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, edge)\n\n        # Step 2: Path reversal\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and edge swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Reverse a segment and swap edges at the segment boundaries\n        new_solution[i:j] = new_solution[i:j][::-1]\n        if i > 0 and j < n - 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8825883342213674,
            0.42806458473205566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and edge swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Reverse a segment and swap edges at the segment boundaries\n        new_solution[i:j] = new_solution[i:j][::-1]\n        if i > 0 and j < n - 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized rank-based score, then applies a hybrid local search combining segment reversal and edge insertion with objective-aware selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    sorted_indices = np.argsort(objectives, axis=0)\n    ranks = np.argsort(sorted_indices, axis=0)\n    normalized_scores = (ranks[:, 0] + ranks[:, 1]) / (2 * (len(archive) - 1))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9033830194853876,
            0.23434728384017944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    sorted_indices = np.argsort(objectives, axis=0)\n    ranks = np.argsort(sorted_indices, axis=0)\n    normalized_scores = (ranks[:, 0] + ranks[:, 1]) / (2 * (len(archive) - 1))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This algorithm selects a solution from the archive using a normalized weighted sum of objectives with adaptive weights based on objective ranges, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with dynamically adjusted probabilities to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj1_min, obj1_max = min(obj1), max(obj1)\n    obj2_min, obj2_max = min(obj2), max(obj2)\n\n    normalized_obj1 = [(x - obj1_min) / (obj1_max - obj1_min + 1e-8) for x in obj1]\n    normalized_obj2 = [(x - obj2_min) / (obj2_max - obj2_min + 1e-8) for x in obj2]\n\n    weights = [0.7, 0.3] if (obj1_max - obj1_min) > (obj2_max - obj2_min) else [0.3, 0.7]\n    scores = [weights[0] * normalized_obj1[i] + weights[1] * normalized_obj2[i] for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with dynamic probability\n    rot_prob = 0.8 if n > 20 else 0.6\n    if random.random() < rot_prob:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with dynamic probability\n    ins_prob = 0.7 if n > 20 else 0.5\n    if random.random() < ins_prob:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with dynamic probability\n    rev_prob = 0.6 if n > 20 else 0.4\n    if random.random() < rev_prob and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9766890163759946,
            0.38312000036239624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj1_min, obj1_max = min(obj1), max(obj1)\n    obj2_min, obj2_max = min(obj2), max(obj2)\n\n    normalized_obj1 = [(x - obj1_min) / (obj1_max - obj1_min + 1e-8) for x in obj1]\n    normalized_obj2 = [(x - obj2_min) / (obj2_max - obj2_min + 1e-8) for x in obj2]\n\n    weights = [0.7, 0.3] if (obj1_max - obj1_min) > (obj2_max - obj2_min) else [0.3, 0.7]\n    scores = [weights[0] * normalized_obj1[i] + weights[1] * normalized_obj2[i] for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with dynamic probability\n    rot_prob = 0.8 if n > 20 else 0.6\n    if random.random() < rot_prob:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with dynamic probability\n    ins_prob = 0.7 if n > 20 else 0.5\n    if random.random() < ins_prob:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with dynamic probability\n    rev_prob = 0.6 if n > 20 else 0.4\n    if random.random() < rev_prob and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a score function that combines objective values with non-equal weights, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with larger segment size\n    segment_size = max(2, n // 4)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with position selection based on distance\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a solution from the archive using a score function that combines objective values with dynamic weights based on solution quality, then applies a hybrid local search combining segment reversal with variable segment sizes and edge insertion with distance-aware position selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_avg = sum(obj[0] for _, obj in archive) / len(archive)\n    obj2_avg = sum(obj[1] for _, obj in archive) / len(archive)\n    weights = [0.6 if obj[0] < obj1_avg and obj[1] < obj2_avg else 0.4 for _, obj in archive]\n\n    scores = [weights[i] * obj[0] + (1 - weights[i]) * obj[1] for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_size = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Distance-aware edge insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n\n    # Select insertion point based on distance in both objectives\n    candidate_positions = [i, j, (i + j) // 2]\n    best_position = i\n    min_total_distance = float('inf')\n\n    for pos in candidate_positions:\n        if pos == i or pos == j:\n            continue\n        edge = new_solution[i:j+1]\n        temp_solution = np.concatenate([new_solution[:pos], edge, new_solution[pos:]])\n        total_distance = 0\n        for k in range(n):\n            u = temp_solution[k]\n            v = temp_solution[(k + 1) % n]\n            total_distance += distance_matrix_1[u, v] * 0.7 + distance_matrix_2[u, v] * 0.3\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_position = pos\n\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:best_position], edge, new_solution[best_position:]])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.733397120594977,
            4.289411664009094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_avg = sum(obj[0] for _, obj in archive) / len(archive)\n    obj2_avg = sum(obj[1] for _, obj in archive) / len(archive)\n    weights = [0.6 if obj[0] < obj1_avg and obj[1] < obj2_avg else 0.4 for _, obj in archive]\n\n    scores = [weights[i] * obj[0] + (1 - weights[i]) * obj[1] for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_size = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Distance-aware edge insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n\n    # Select insertion point based on distance in both objectives\n    candidate_positions = [i, j, (i + j) // 2]\n    best_position = i\n    min_total_distance = float('inf')\n\n    for pos in candidate_positions:\n        if pos == i or pos == j:\n            continue\n        edge = new_solution[i:j+1]\n        temp_solution = np.concatenate([new_solution[:pos], edge, new_solution[pos:]])\n        total_distance = 0\n        for k in range(n):\n            u = temp_solution[k]\n            v = temp_solution[(k + 1) % n]\n            total_distance += distance_matrix_1[u, v] * 0.7 + distance_matrix_2[u, v] * 0.3\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_position = pos\n\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:best_position], edge, new_solution[best_position:]])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment and reverse its edges\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{The new algorithm combines adaptive segment selection with a novel multi-objective edge insertion strategy, where promising segments are identified based on their potential to improve both objectives, and edges are dynamically inserted or replaced to balance the tour's cost in both spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the most promising segments based on both objectives\n    segment_scores = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            segment = new_solution[i:j]\n            cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            segment_scores.append((i, j, cost1 + cost2))\n\n    if not segment_scores:\n        return new_solution\n\n    # Select the top 5 segments by score\n    top_segments = sorted(segment_scores, key=lambda x: x[2], reverse=True)[:5]\n\n    for i, j, _ in top_segments:\n        # Extract the segment and reverse it\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n        # Insert a new edge from a randomly selected node to improve both objectives\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            # Find the best node to insert between k and k+1\n            best_node = None\n            best_score = float('inf')\n            for node in range(n):\n                if node not in new_solution:\n                    cost1 = distance_matrix_1[new_solution[k], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                    cost2 = distance_matrix_2[new_solution[k], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                    total_cost = cost1 + cost2\n                    if total_cost < best_score:\n                        best_score = total_cost\n                        best_node = node\n\n            if best_node is not None:\n                new_solution = np.concatenate([new_solution[:k+1], [best_node], new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9806309163476365,
            2.163069009780884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the most promising segments based on both objectives\n    segment_scores = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            segment = new_solution[i:j]\n            cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            segment_scores.append((i, j, cost1 + cost2))\n\n    if not segment_scores:\n        return new_solution\n\n    # Select the top 5 segments by score\n    top_segments = sorted(segment_scores, key=lambda x: x[2], reverse=True)[:5]\n\n    for i, j, _ in top_segments:\n        # Extract the segment and reverse it\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n        # Insert a new edge from a randomly selected node to improve both objectives\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            # Find the best node to insert between k and k+1\n            best_node = None\n            best_score = float('inf')\n            for node in range(n):\n                if node not in new_solution:\n                    cost1 = distance_matrix_1[new_solution[k], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                    cost2 = distance_matrix_2[new_solution[k], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                    total_cost = cost1 + cost2\n                    if total_cost < best_score:\n                        best_score = total_cost\n                        best_node = node\n\n            if best_node is not None:\n                new_solution = np.concatenate([new_solution[:k+1], [best_node], new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{A novel hybrid local search approach that combines adaptive segment reversal with dynamic edge swapping, prioritizing solutions from the archive with high potential for improvement by analyzing objective values and applying a probabilistic selection mechanism to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    probabilities = 1 - np.prod(normalized_obj, axis=1)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with dynamic edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n        # Dynamic edge swapping based on distance improvements\n        for _ in range(2):\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k == l or abs(k - l) < 2:\n                continue\n\n            # Calculate current and potential distances\n            current_dist1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            current_dist2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n            potential_dist1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l-1]]\n            potential_dist2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l-1]]\n\n            if (potential_dist1 < current_dist1 and potential_dist2 < current_dist2) or np.random.random() < 0.3:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9059294838071301,
            0.3384819030761719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    probabilities = 1 - np.prod(normalized_obj, axis=1)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with dynamic edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n        # Dynamic edge swapping based on distance improvements\n        for _ in range(2):\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k == l or abs(k - l) < 2:\n                continue\n\n            # Calculate current and potential distances\n            current_dist1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            current_dist2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n            potential_dist1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l-1]]\n            potential_dist2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l-1]]\n\n            if (potential_dist1 < current_dist1 and potential_dist2 < current_dist2) or np.random.random() < 0.3:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{A novel local search heuristic that prioritizes solutions with balanced improvement across objectives by dynamically adjusting weights based on their Pareto dominance, then applies a hybrid strategy combining segment rotation, node insertion, and edge swapping with adaptive intensity to explore high-quality neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    weights = [0.5, 0.5]  # Default balanced weights\n    if len(archive) > 1:\n        # Identify non-dominated solutions\n        non_dominated = []\n        for i, obj in enumerate(objectives):\n            dominated = False\n            for j, other_obj in enumerate(objectives):\n                if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append(i)\n        if non_dominated:\n            weights = [0.3, 0.7] if len(non_dominated) <= len(archive)/2 else [0.7, 0.3]\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = rotated_segment\n\n    # Adaptive node insertion\n    if n > 3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        # Insert at a position that maintains diversity\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive edge swap\n    if n > 4:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1 and abs(i - j) < n - 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9026695067720552,
            0.3108954429626465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    weights = [0.5, 0.5]  # Default balanced weights\n    if len(archive) > 1:\n        # Identify non-dominated solutions\n        non_dominated = []\n        for i, obj in enumerate(objectives):\n            dominated = False\n            for j, other_obj in enumerate(objectives):\n                if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append(i)\n        if non_dominated:\n            weights = [0.3, 0.7] if len(non_dominated) <= len(archive)/2 else [0.7, 0.3]\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = rotated_segment\n\n    # Adaptive node insertion\n    if n > 3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        # Insert at a position that maintains diversity\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive edge swap\n    if n > 4:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1 and abs(i - j) < n - 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search strategy that combines adaptive segment rotation with distance-aware edge swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation with distance consideration\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Calculate segment distances in both objectives\n    segment_dist1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_dist2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Decide rotation direction based on which objective is more critical\n    if segment_dist1 > segment_dist2:\n        rotation = np.random.choice([1, -1], p=[0.7, 0.3])\n    else:\n        rotation = np.random.choice([1, -1], p=[0.3, 0.7])\n\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Distance-aware edge swapping\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            # Calculate current and potential distances\n            current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            potential_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            potential_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept swap if it improves at least one objective\n            if (potential_dist1 < current_dist1) or (potential_dist2 < current_dist2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8070260311637883,
            0.33775681257247925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation with distance consideration\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Calculate segment distances in both objectives\n    segment_dist1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_dist2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Decide rotation direction based on which objective is more critical\n    if segment_dist1 > segment_dist2:\n        rotation = np.random.choice([1, -1], p=[0.7, 0.3])\n    else:\n        rotation = np.random.choice([1, -1], p=[0.3, 0.7])\n\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Distance-aware edge swapping\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            # Calculate current and potential distances\n            current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            potential_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            potential_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept swap if it improves at least one objective\n            if (potential_dist1 < current_dist1) or (potential_dist2 < current_dist2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Select a solution based on normalized objective values\n    normalized_scores = []\n    max_obj1 = max(obj[0] for _, obj in pareto_front)\n    max_obj2 = max(obj[1] for _, obj in pareto_front)\n    for sol, obj in pareto_front:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        normalized_scores.append(0.7 * norm_obj1 + 0.3 * norm_obj2)\n\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with probability\n    if random.random() < 0.5:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion with probability\n    if random.random() < 0.4:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Edge swap with probability\n    if random.random() < 0.3 and n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7745065161710001,
            2.8910841941833496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Select a solution based on normalized objective values\n    normalized_scores = []\n    max_obj1 = max(obj[0] for _, obj in pareto_front)\n    max_obj2 = max(obj[1] for _, obj in pareto_front)\n    for sol, obj in pareto_front:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        normalized_scores.append(0.7 * norm_obj1 + 0.3 * norm_obj2)\n\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with probability\n    if random.random() < 0.5:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion with probability\n    if random.random() < 0.4:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Edge swap with probability\n    if random.random() < 0.3 and n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and structural diversity, then applies a novel hybrid local search combining adaptive segment swapping, dynamic edge reinsertion, and probabilistic node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective quality and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    selection_weights = (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)) * diversity_scores\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swapping, dynamic edge reinsertion, and probabilistic node relocation\n    if n > 3:\n        # Step 1: Adaptive segment swapping (swap two segments of varying lengths)\n        if random.random() < 0.6:\n            seg_len = random.randint(2, min(5, n//2))\n            start1 = random.randint(0, n - seg_len)\n            start2 = random.randint(0, n - seg_len)\n            if start1 != start2:\n                seg1 = new_solution[start1:start1+seg_len]\n                seg2 = new_solution[start2:start2+seg_len]\n                new_solution[start1:start1+seg_len] = seg2\n                new_solution[start2:start2+seg_len] = seg1\n\n        # Step 2: Dynamic edge reinsertion (remove an edge and reinsert it at a different position)\n        if random.random() < 0.5:\n            i = random.randint(0, n-2)\n            edge = new_solution[i:i+2]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+2:], edge])\n\n        # Step 3: Probabilistic node relocation (move a node to a random position with probability based on its position)\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8222564202694462,
            0.6767973303794861
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective quality and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    selection_weights = (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)) * diversity_scores\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swapping, dynamic edge reinsertion, and probabilistic node relocation\n    if n > 3:\n        # Step 1: Adaptive segment swapping (swap two segments of varying lengths)\n        if random.random() < 0.6:\n            seg_len = random.randint(2, min(5, n//2))\n            start1 = random.randint(0, n - seg_len)\n            start2 = random.randint(0, n - seg_len)\n            if start1 != start2:\n                seg1 = new_solution[start1:start1+seg_len]\n                seg2 = new_solution[start2:start2+seg_len]\n                new_solution[start1:start1+seg_len] = seg2\n                new_solution[start2:start2+seg_len] = seg1\n\n        # Step 2: Dynamic edge reinsertion (remove an edge and reinsert it at a different position)\n        if random.random() < 0.5:\n            i = random.randint(0, n-2)\n            edge = new_solution[i:i+2]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+2:], edge])\n\n        # Step 3: Probabilistic node relocation (move a node to a random position with probability based on its position)\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This algorithm selects a solution from the archive based on the most under-represented objective dimension, then applies a novel local search combining segment inversion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0) + 1e-6\n    weights = (1 / std_obj) / np.sum(1 / std_obj)\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment inversion with adaptive edge swapping\n    if n > 3:\n        # Select segment to invert\n        segment_len = np.random.randint(2, min(n//2, 10))\n        start = np.random.randint(0, n - segment_len)\n        end = start + segment_len\n\n        # Invert the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adaptive edge swapping\n        for _ in range(np.random.randint(1, 3)):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and abs(i - j) > 1:\n                # Calculate improvement potential\n                obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Swap if improves at least one objective\n                if (obj1_after < obj1_before) or (obj2_after < obj2_before):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8268751867930964,
            0.2849687933921814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0) + 1e-6\n    weights = (1 / std_obj) / np.sum(1 / std_obj)\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment inversion with adaptive edge swapping\n    if n > 3:\n        # Select segment to invert\n        segment_len = np.random.randint(2, min(n//2, 10))\n        start = np.random.randint(0, n - segment_len)\n        end = start + segment_len\n\n        # Invert the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adaptive edge swapping\n        for _ in range(np.random.randint(1, 3)):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and abs(i - j) > 1:\n                # Calculate improvement potential\n                obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Swap if improves at least one objective\n                if (obj1_after < obj1_before) or (obj2_after < obj2_before):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment and reverse its edges\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and solution structure diversity, then applies a novel local search combining adaptive segment rotation, dynamic edge swapping, and objective-aware node relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    selection_weights = improvement_potential * diversity_scores\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n        rotation = random.randint(1, segment_len-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Dynamic edge swapping\n        if random.random() < 0.6:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            if i != j:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n                new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n        # Objective-aware node relocation\n        if random.random() < 0.8:\n            worst_nodes = np.argsort([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])[-3:]\n            for node_idx in worst_nodes:\n                if random.random() < 0.5:\n                    pos = random.randint(0, n-1)\n                    node = new_solution[node_idx]\n                    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n                    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8106793363467721,
            0.37309330701828003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    selection_weights = improvement_potential * diversity_scores\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n        rotation = random.randint(1, segment_len-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Dynamic edge swapping\n        if random.random() < 0.6:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            if i != j:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n                new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n        # Objective-aware node relocation\n        if random.random() < 0.8:\n            worst_nodes = np.argsort([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])[-3:]\n            for node_idx in worst_nodes:\n                if random.random() < 0.5:\n                    pos = random.randint(0, n-1)\n                    node = new_solution[node_idx]\n                    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n                    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm selects a solution from the archive based on the Pareto dominance relationship between solutions, then applies a novel hybrid local search combining node swapping, partial tour reversal, and adaptive segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if not pareto_front:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(pareto_front).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    if n > 3:\n        # Step 1: Node swapping\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Step 2: Partial tour reversal\n        if random.random() < 0.6:\n            start, end = sorted(random.sample(range(n), 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Step 3: Adaptive segment relocation\n        if random.random() < 0.4:\n            segment_len = random.randint(2, min(4, n//3))\n            start = random.randint(0, n - segment_len)\n            segment = new_solution[start:start+segment_len]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_len:]])\n            insert_pos = random.randint(0, len(new_solution) - segment_len)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9358541892320638,
            0.237970232963562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if not pareto_front:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(pareto_front).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    if n > 3:\n        # Step 1: Node swapping\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Step 2: Partial tour reversal\n        if random.random() < 0.6:\n            start, end = sorted(random.sample(range(n), 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Step 3: Adaptive segment relocation\n        if random.random() < 0.4:\n            segment_len = random.randint(2, min(4, n//3))\n            start = random.randint(0, n - segment_len)\n            segment = new_solution[start:start+segment_len]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_len:]])\n            insert_pos = random.randint(0, len(new_solution) - segment_len)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment and reverse its edges\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-10)\n    scores = np.max(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment length based on solution quality\n    segment_length = max(2, int(np.random.normal(n/4, n/8)))\n    segment_length = max(2, min(segment_length, n-1))\n\n    # Hybrid local search: segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = (i + segment_length) % n\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a random edge from another segment\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7876966784145516,
            0.2817528247833252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-10)\n    scores = np.max(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment length based on solution quality\n    segment_length = max(2, int(np.random.normal(n/4, n/8)))\n    segment_length = max(2, min(segment_length, n-1))\n\n    # Hybrid local search: segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = (i + segment_length) % n\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a random edge from another segment\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -1.0215060247628296,
            0.691538393497467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions and their structural diversity, then applies a hybrid local search combining adaptive node swapping and segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment insertion\n    if n > 3:\n        # Step 1: Adaptive node swapping (swap two nodes based on their distance)\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n           distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment insertion (insert a segment from one position to another)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -1.0215060247628296,
            0.691538393497467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{A novel heuristic that combines adaptive segment replacement, edge reversal with dynamic segment selection, and a probabilistic acceptance criterion to balance exploration and exploitation in the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select from top 30% with higher probability\n        selection_prob = np.linspace(0.7, 0.1, len(sorted_archive))\n        selection_prob = selection_prob / np.sum(selection_prob)\n        selected_idx = np.random.choice(len(sorted_archive), p=selection_prob)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment replacement\n    segment_size = min(n // 4, 5)\n    i = np.random.randint(0, n - segment_size)\n    j = i + segment_size\n    segment1 = new_solution[i:j]\n\n    k = np.random.randint(0, n - segment_size)\n    l = k + segment_size\n    segment2 = new_solution[k:l]\n\n    # With 70% probability, swap segments\n    if np.random.rand() < 0.7:\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Edge reversal with dynamic segment size\n    rev_size = min(n // 3, 7)\n    k = np.random.randint(0, n - rev_size)\n    l = k + rev_size\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Probabilistic acceptance based on objective improvement\n    if len(np.unique(new_solution)) != n:\n        if np.random.rand() < 0.3:  # 30% chance to accept invalid solution\n            return new_solution\n        else:\n            return base_solution\n    else:\n        # Calculate objective improvement\n        old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n        old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Accept with probability based on improvement\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.4:\n            return new_solution\n        else:\n            return base_solution\n\n",
        "score": [
            -0.6568710352223793,
            0.7572510242462158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select from top 30% with higher probability\n        selection_prob = np.linspace(0.7, 0.1, len(sorted_archive))\n        selection_prob = selection_prob / np.sum(selection_prob)\n        selected_idx = np.random.choice(len(sorted_archive), p=selection_prob)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment replacement\n    segment_size = min(n // 4, 5)\n    i = np.random.randint(0, n - segment_size)\n    j = i + segment_size\n    segment1 = new_solution[i:j]\n\n    k = np.random.randint(0, n - segment_size)\n    l = k + segment_size\n    segment2 = new_solution[k:l]\n\n    # With 70% probability, swap segments\n    if np.random.rand() < 0.7:\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Edge reversal with dynamic segment size\n    rev_size = min(n // 3, 7)\n    k = np.random.randint(0, n - rev_size)\n    l = k + rev_size\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Probabilistic acceptance based on objective improvement\n    if len(np.unique(new_solution)) != n:\n        if np.random.rand() < 0.3:  # 30% chance to accept invalid solution\n            return new_solution\n        else:\n            return base_solution\n    else:\n        # Calculate objective improvement\n        old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n        old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Accept with probability based on improvement\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.4:\n            return new_solution\n        else:\n            return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric that combines objective values and solution structure, then applies a novel neighborhood exploration strategy that combines partial tour reversal, segment transposition, and adaptive node relocation to generate diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity_metric(sol, obj):\n        return obj[0] * 0.4 + obj[1] * 0.4 + (sum(np.abs(sol[:-1] - sol[1:])) / len(sol)) * 0.2\n\n    scores = [diversity_metric(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply partial tour reversal\n    if random.random() < 0.6:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment transposition\n    if random.random() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        if j - i > 1 and k != i and k != j:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Apply adaptive node relocation\n    if random.random() < 0.7:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        # Find best insertion point based on both objectives\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(len(new_solution)):\n            temp_sol = np.insert(new_solution, i, node)\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(len(temp_sol)-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(len(temp_sol)-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 * 0.5 + cost2 * 0.5\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7655088369792427,
            1.9751948714256287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity_metric(sol, obj):\n        return obj[0] * 0.4 + obj[1] * 0.4 + (sum(np.abs(sol[:-1] - sol[1:])) / len(sol)) * 0.2\n\n    scores = [diversity_metric(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply partial tour reversal\n    if random.random() < 0.6:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment transposition\n    if random.random() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        if j - i > 1 and k != i and k != j:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Apply adaptive node relocation\n    if random.random() < 0.7:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        # Find best insertion point based on both objectives\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(len(new_solution)):\n            temp_sol = np.insert(new_solution, i, node)\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(len(temp_sol)-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(len(temp_sol)-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 * 0.5 + cost2 * 0.5\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective quality score that combines objective values with solution structure, then applies a novel hybrid local search combining segment rotation, edge swapping with distance-aware selection, and adaptive node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective quality score selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    quality_scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n\n    # Select solution with highest quality (lowest score)\n    selected_idx = np.argmin(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation with distance awareness\n    if n > 3:\n        # Step 1: Segment rotation with distance-aware selection\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n\n        # Calculate segment distances in both objectives\n        segment_dist1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_len]] for i in range(segment_len))\n        segment_dist2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_len]] for i in range(segment_len))\n\n        # Rotate segment based on which objective has higher distance\n        if segment_dist1 > segment_dist2:\n            rotation = random.randint(1, segment_len-1)\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Edge swapping with distance improvement check\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Adaptive node relocation based on both objectives\n        if random.random() < 0.5:\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n            # Find best insertion point considering both objectives\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    prev = len(new_solution) - 1\n                else:\n                    prev = pos - 1\n\n                dist1 = distance_matrix_1[new_solution[prev], node] + distance_matrix_1[node, new_solution[pos]]\n                dist2 = distance_matrix_2[new_solution[prev], node] + distance_matrix_2[node, new_solution[pos]]\n                score = 0.5 * dist1 + 0.5 * dist2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.821605760098187,
            0.4148139953613281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective quality score selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    quality_scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n\n    # Select solution with highest quality (lowest score)\n    selected_idx = np.argmin(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation with distance awareness\n    if n > 3:\n        # Step 1: Segment rotation with distance-aware selection\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n\n        # Calculate segment distances in both objectives\n        segment_dist1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_len]] for i in range(segment_len))\n        segment_dist2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_len]] for i in range(segment_len))\n\n        # Rotate segment based on which objective has higher distance\n        if segment_dist1 > segment_dist2:\n            rotation = random.randint(1, segment_len-1)\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Edge swapping with distance improvement check\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Adaptive node relocation based on both objectives\n        if random.random() < 0.5:\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n            # Find best insertion point considering both objectives\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    prev = len(new_solution) - 1\n                else:\n                    prev = pos - 1\n\n                dist1 = distance_matrix_1[new_solution[prev], node] + distance_matrix_1[node, new_solution[pos]]\n                dist2 = distance_matrix_2[new_solution[prev], node] + distance_matrix_2[node, new_solution[pos]]\n                score = 0.5 * dist1 + 0.5 * dist2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based selection strategy, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                dominated[i] = True\n                break\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n    selected_idx = random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9473045994896787,
            0.35796672105789185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                dominated[i] = True\n                break\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n    selected_idx = random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining adaptive segment swapping, distance-aware node reinsertion, and objective-balanced edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swapping\n    if random.random() < 0.8:\n        segment_length = random.randint(2, min(5, n // 3))\n        start1 = random.randint(0, n - segment_length)\n        end1 = start1 + segment_length\n        start2 = random.randint(0, n - segment_length)\n        end2 = start2 + segment_length\n        if start1 != start2:\n            segment1 = new_solution[start1:end1].copy()\n            segment2 = new_solution[start2:end2].copy()\n            new_solution[start1:end1] = segment2\n            new_solution[start2:end2] = segment1\n\n    # Distance-aware node reinsertion\n    if random.random() < 0.7:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        candidates = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            candidates.append((i, cost1 + cost2))\n        if candidates:\n            insert_pos = min(candidates, key=lambda x: x[1])[0]\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Objective-balanced edge flipping\n    if random.random() < 0.6 and n > 3:\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, min(i + 3, n - 1))\n        segment = new_solution[i:j+1]\n        flipped_segment = segment[::-1]\n        original_cost1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        flipped_cost1 = sum(distance_matrix_1[flipped_segment[k], flipped_segment[k+1]] for k in range(len(flipped_segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        flipped_cost2 = sum(distance_matrix_2[flipped_segment[k], flipped_segment[k+1]] for k in range(len(flipped_segment)-1))\n        if (flipped_cost1 + flipped_cost2) < (original_cost1 + original_cost2):\n            new_solution[i:j+1] = flipped_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6898294150812256,
            0.8437181711196899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swapping\n    if random.random() < 0.8:\n        segment_length = random.randint(2, min(5, n // 3))\n        start1 = random.randint(0, n - segment_length)\n        end1 = start1 + segment_length\n        start2 = random.randint(0, n - segment_length)\n        end2 = start2 + segment_length\n        if start1 != start2:\n            segment1 = new_solution[start1:end1].copy()\n            segment2 = new_solution[start2:end2].copy()\n            new_solution[start1:end1] = segment2\n            new_solution[start2:end2] = segment1\n\n    # Distance-aware node reinsertion\n    if random.random() < 0.7:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        candidates = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            candidates.append((i, cost1 + cost2))\n        if candidates:\n            insert_pos = min(candidates, key=lambda x: x[1])[0]\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Objective-balanced edge flipping\n    if random.random() < 0.6 and n > 3:\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, min(i + 3, n - 1))\n        segment = new_solution[i:j+1]\n        flipped_segment = segment[::-1]\n        original_cost1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        flipped_cost1 = sum(distance_matrix_1[flipped_segment[k], flipped_segment[k+1]] for k in range(len(flipped_segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        flipped_cost2 = sum(distance_matrix_2[flipped_segment[k], flipped_segment[k+1]] for k in range(len(flipped_segment)-1))\n        if (flipped_cost1 + flipped_cost2) < (original_cost1 + original_cost2):\n            new_solution[i:j+1] = flipped_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a novel local search combining multi-segment inversion, probabilistic edge reversal, and adaptive node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance for diversity\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-10)\n\n    # Combine Pareto dominance and crowding distance\n    selection_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated_count += 1\n        selection_scores[i] = dominated_count + crowding_distances[i]\n\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment size\n    if n > 4:\n        num_segments = random.randint(1, min(3, n//4))\n        for _ in range(num_segments):\n            start = random.randint(0, n-2)\n            end = random.randint(start+1, min(start+4, n-1))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Probabilistic edge reversal based on distance improvement\n    if n > 2:\n        for _ in range(random.randint(1, min(2, n//3))):\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, min(i+3, n-1))\n            current_cost = distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + \\\n                           distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[i]][new_solution[(j+1)%n]] + \\\n                       distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[(j+1)%n]]\n            if new_cost < current_cost and random.random() < 0.7:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive node insertion based on distance\n    if n > 3:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i, j = random.sample(range(n), 2)\n            if i != j and abs(i-j) > 1:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7817172524309217,
            0.24888968467712402
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance for diversity\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-10)\n\n    # Combine Pareto dominance and crowding distance\n    selection_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated_count += 1\n        selection_scores[i] = dominated_count + crowding_distances[i]\n\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment size\n    if n > 4:\n        num_segments = random.randint(1, min(3, n//4))\n        for _ in range(num_segments):\n            start = random.randint(0, n-2)\n            end = random.randint(start+1, min(start+4, n-1))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Probabilistic edge reversal based on distance improvement\n    if n > 2:\n        for _ in range(random.randint(1, min(2, n//3))):\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, min(i+3, n-1))\n            current_cost = distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + \\\n                           distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[i]][new_solution[(j+1)%n]] + \\\n                       distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[(j+1)%n]]\n            if new_cost < current_cost and random.random() < 0.7:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive node insertion based on distance\n    if n > 3:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i, j = random.sample(range(n), 2)\n            if i != j and abs(i-j) > 1:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and structural diversity, then applies a novel local search combining adaptive segment inversion, probabilistic edge flipping, and multi-objective aware node relocation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.linalg.norm(normalized_obj, axis=1)\n\n    if random.random() < 0.7:\n        # Prefer solutions with better combined objective scores\n        selected_idx = np.argmin(scores)\n    else:\n        # Occasionally explore diverse solutions\n        selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 4:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge flipping\n    if n > 3:\n        for _ in range(random.randint(1, min(3, n//3))):\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, n-1)\n            if (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) < \\\n               (distance_matrix_1[new_solution[i]][new_solution[i+1]] + distance_matrix_2[new_solution[i]][new_solution[i+1]] +\n                distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]]):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Multi-objective aware node relocation\n    if n > 2:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate improvement in both objectives\n                old_cost = (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]])\n                if new_cost < old_cost:\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8582305468217882,
            0.28914886713027954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.linalg.norm(normalized_obj, axis=1)\n\n    if random.random() < 0.7:\n        # Prefer solutions with better combined objective scores\n        selected_idx = np.argmin(scores)\n    else:\n        # Occasionally explore diverse solutions\n        selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 4:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge flipping\n    if n > 3:\n        for _ in range(random.randint(1, min(3, n//3))):\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, n-1)\n            if (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) < \\\n               (distance_matrix_1[new_solution[i]][new_solution[i+1]] + distance_matrix_2[new_solution[i]][new_solution[i+1]] +\n                distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]]):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Multi-objective aware node relocation\n    if n > 2:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate improvement in both objectives\n                old_cost = (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]])\n                if new_cost < old_cost:\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal and distance-aware edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = np.array([(obj[0] / max_obj[0], obj[1] / max_obj[1]) for obj in objectives])\n    scores = [0.7 * norm_obj[i][0] + 0.3 * norm_obj[i][1] for i in range(len(norm_obj))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with distance-aware selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    new_solution[start:end] = segment\n\n    # Distance-aware edge insertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8594806844423536,
            0.31463974714279175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = np.array([(obj[0] / max_obj[0], obj[1] / max_obj[1]) for obj in objectives])\n    scores = [0.7 * norm_obj[i][0] + 0.3 * norm_obj[i][1] for i in range(len(norm_obj))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with distance-aware selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    new_solution[start:end] = segment\n\n    # Distance-aware edge insertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to promote diversity, then applies a novel local search combining segment inversion, adaptive node insertion, and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n = len(objectives)\n    if n == 1:\n        selected_idx = 0\n    else:\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n        crowding_dist = np.zeros(n)\n        crowding_dist[0] = crowding_dist[-1] = float('inf')\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            objectives_sorted = objectives[sorted_idx]\n            f_min = objectives_sorted[0, m]\n            f_max = objectives_sorted[-1, m]\n            if f_max == f_min:\n                continue\n            crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                crowding_dist[sorted_idx[i]] += (objectives_sorted[i+1, m] - objectives_sorted[i-1, m]) / (f_max - f_min)\n\n        selected_idx = np.argmax(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Adaptive node insertion\n    if n > 4:\n        for _ in range(random.randint(1, 2)):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Probabilistic edge flipping\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//3))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.5 * (1 - (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[i]] +\n                                   distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[i]]) /\n                          (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8860045745903604,
            0.3365916609764099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n = len(objectives)\n    if n == 1:\n        selected_idx = 0\n    else:\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n        crowding_dist = np.zeros(n)\n        crowding_dist[0] = crowding_dist[-1] = float('inf')\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            objectives_sorted = objectives[sorted_idx]\n            f_min = objectives_sorted[0, m]\n            f_max = objectives_sorted[-1, m]\n            if f_max == f_min:\n                continue\n            crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                crowding_dist[sorted_idx[i]] += (objectives_sorted[i+1, m] - objectives_sorted[i-1, m]) / (f_max - f_min)\n\n        selected_idx = np.argmax(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Adaptive node insertion\n    if n > 4:\n        for _ in range(random.randint(1, 2)):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Probabilistic edge flipping\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//3))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.5 * (1 - (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[i]] +\n                                   distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[i]]) /\n                          (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that combines objective values with structural diversity, then applies a novel local search operator that combines a multi-segment rotation with adaptive node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    # Combine objectives and diversity for selection\n    combined = np.sum(objectives, axis=1) / (diversity + 1e-10)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment rotation with adaptive segment selection\n    num_segments = min(3, max(2, n // 4))\n    segment_lengths = sorted(random.sample(range(2, n // 3), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        segment = new_solution[start:end]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[start:end] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Adaptive node relocation based on distance improvement\n    for _ in range(min(4, n // 3)):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n\n        # Find best insertion position\n        best_pos = i\n        best_improvement = 0\n\n        for j in range(n):\n            if j == i or j == (i-1)%n or j == (i+1)%n:\n                continue\n\n            # Calculate potential improvement\n            prev_nodes = [new_solution[(j-1)%n], new_solution[(i-1)%n]]\n            next_nodes = [new_solution[(j+1)%n], new_solution[(i+1)%n]]\n\n            original_cost = (distance_matrix_1[prev_nodes[0], node] + distance_matrix_1[node, next_nodes[0]] +\n                            distance_matrix_2[prev_nodes[0], node] + distance_matrix_2[node, next_nodes[0]])\n\n            # Remove node from current position\n            if i < j:\n                temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n            else:\n                temp_sol = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n            new_cost = (distance_matrix_1[temp_sol[(j-1)%n], node] + distance_matrix_1[node, temp_sol[(j+1)%n]] +\n                        distance_matrix_2[temp_sol[(j-1)%n], node] + distance_matrix_2[node, temp_sol[(j+1)%n]])\n\n            improvement = original_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = j\n\n        if best_pos != i:\n            # Perform the relocation\n            if i < best_pos:\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:i], new_solution[i+1:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8226901126940829,
            2.7453880310058594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    # Combine objectives and diversity for selection\n    combined = np.sum(objectives, axis=1) / (diversity + 1e-10)\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment rotation with adaptive segment selection\n    num_segments = min(3, max(2, n // 4))\n    segment_lengths = sorted(random.sample(range(2, n // 3), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        segment = new_solution[start:end]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[start:end] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Adaptive node relocation based on distance improvement\n    for _ in range(min(4, n // 3)):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n\n        # Find best insertion position\n        best_pos = i\n        best_improvement = 0\n\n        for j in range(n):\n            if j == i or j == (i-1)%n or j == (i+1)%n:\n                continue\n\n            # Calculate potential improvement\n            prev_nodes = [new_solution[(j-1)%n], new_solution[(i-1)%n]]\n            next_nodes = [new_solution[(j+1)%n], new_solution[(i+1)%n]]\n\n            original_cost = (distance_matrix_1[prev_nodes[0], node] + distance_matrix_1[node, next_nodes[0]] +\n                            distance_matrix_2[prev_nodes[0], node] + distance_matrix_2[node, next_nodes[0]])\n\n            # Remove node from current position\n            if i < j:\n                temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n            else:\n                temp_sol = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n            new_cost = (distance_matrix_1[temp_sol[(j-1)%n], node] + distance_matrix_1[node, temp_sol[(j+1)%n]] +\n                        distance_matrix_2[temp_sol[(j-1)%n], node] + distance_matrix_2[node, temp_sol[(j+1)%n]])\n\n            improvement = original_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = j\n\n        if best_pos != i:\n            # Perform the relocation\n            if i < best_pos:\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:i], new_solution[i+1:]])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment and reverse its edges\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search strategy that combines segment rotation with adaptive edge reversal and node insertion, while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if j - i > 1:\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[i:j] = rotated_segment\n\n    k = np.random.randint(0, n)\n    if k < i or k > j:\n        l = np.random.randint(0, n)\n        if l != k and (l < i or l > j):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9262866966538218,
            0.24016129970550537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if j - i > 1:\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[i:j] = rotated_segment\n\n    k = np.random.randint(0, n)\n    if k < i or k > j:\n        l = np.random.randint(0, n)\n        if l != k and (l < i or l > j):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid crowding-distance and objective-space diversity metric, then applies a novel local search combining segment inversion, adaptive k-swap, and probabilistic edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on crowding distance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n    crowding_dist = np.zeros(n)\n\n    # Calculate crowding distance for each objective\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Combine crowding distance and objective diversity\n    diversity_scores = []\n    for i in range(n):\n        total_dist = 0\n        for j in range(n):\n            if i != j:\n                total_dist += np.linalg.norm(objectives[i] - objectives[j])\n        diversity_scores.append(crowding_dist[i] * total_dist)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Segment inversion with adaptive segment length\n    if n_nodes > 4:\n        inv_length = random.randint(2, min(6, n_nodes//2))\n        start = random.randint(0, n_nodes - inv_length)\n        new_solution[start:start+inv_length] = new_solution[start:start+inv_length][::-1]\n\n    # Adaptive k-swap based on distance improvement\n    k = random.randint(2, min(4, n_nodes//3))\n    for _ in range(k):\n        i, j = random.sample(range(n_nodes), 2)\n        delta1 = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n_nodes]] -\n                 (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n_nodes]]))\n        delta2 = (distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n_nodes]] -\n                 (distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n_nodes]]))\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge insertion based on distance\n    if n_nodes > 3:\n        for _ in range(random.randint(1, min(2, n_nodes//5))):\n            i, j = random.sample(range(n_nodes), 2)\n            prob = 0.3 * (1 - (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) /\n                         (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + 1e-10))\n            if random.random() < prob:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9027981700293269,
            2.7833991646766663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on crowding distance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n    crowding_dist = np.zeros(n)\n\n    # Calculate crowding distance for each objective\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Combine crowding distance and objective diversity\n    diversity_scores = []\n    for i in range(n):\n        total_dist = 0\n        for j in range(n):\n            if i != j:\n                total_dist += np.linalg.norm(objectives[i] - objectives[j])\n        diversity_scores.append(crowding_dist[i] * total_dist)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Segment inversion with adaptive segment length\n    if n_nodes > 4:\n        inv_length = random.randint(2, min(6, n_nodes//2))\n        start = random.randint(0, n_nodes - inv_length)\n        new_solution[start:start+inv_length] = new_solution[start:start+inv_length][::-1]\n\n    # Adaptive k-swap based on distance improvement\n    k = random.randint(2, min(4, n_nodes//3))\n    for _ in range(k):\n        i, j = random.sample(range(n_nodes), 2)\n        delta1 = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n_nodes]] -\n                 (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n_nodes]]))\n        delta2 = (distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n_nodes]] -\n                 (distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n_nodes]]))\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge insertion based on distance\n    if n_nodes > 3:\n        for _ in range(random.randint(1, min(2, n_nodes//5))):\n            i, j = random.sample(range(n_nodes), 2)\n            prob = 0.3 * (1 - (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) /\n                         (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + 1e-10))\n            if random.random() < prob:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel adaptive local search algorithm that combines segment reversal, edge swapping, and dynamic edge insertion while prioritizing non-dominated solutions and incorporating objective-specific distance metrics to guide the search toward high-quality multi-objective solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_solutions = []\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for other_sol, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 < cost2) or (other_cost1 < cost1 and other_cost2 <= cost2):\n                dominated = True\n                break\n        if not dominated:\n            potential_solutions.append((sol, cost1, cost2))\n\n    if not potential_solutions:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select based on combined objective score with distance metrics\n        scores = []\n        for sol, cost1, cost2 in potential_solutions:\n            # Calculate average distance in both spaces\n            avg_dist1 = np.mean([distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n            avg_dist2 = np.mean([distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n            # Score combines objective values and local distances\n            score = (cost1 + cost2) / (1 + avg_dist1 + avg_dist2)\n            scores.append(score)\n        selected_idx = np.argmin(scores)\n        base_solution = potential_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, edge swap, and dynamic edge insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    if j - i > 1:\n        # Adaptive segment reversal\n        segment = new_solution[i:j+1]\n        if np.random.random() < 0.5:\n            segment = segment[::-1]  # Reverse\n        else:\n            segment = np.roll(segment, np.random.randint(1, len(segment)))  # Rotate\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    if l - k > 1 and abs(i - k) > 1 and abs(j - l) > 1:\n        # Edge swap between non-overlapping segments\n        segment1 = new_solution[k:l+1]\n        segment2 = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:k], segment2, new_solution[l+1:]])\n        new_solution = np.concatenate([new_solution[:i], segment1, new_solution[j+1:]])\n\n    # Dynamic edge insertion based on distance metrics\n    if np.random.random() < 0.3:\n        # Select an edge from the most costly part of the tour\n        tour_costs1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n        tour_costs2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n        combined_costs = [tour_costs1[i] + tour_costs2[i] for i in range(n-1)]\n        worst_edge_idx = np.argmax(combined_costs)\n\n        # Find a better insertion point\n        node1, node2 = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n        current_cost = distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2]\n\n        best_insertion = None\n        best_improvement = 0\n\n        for pos in range(n-1):\n            if pos == worst_edge_idx or pos == worst_edge_idx-1:\n                continue\n            # Calculate potential improvement\n            prev_node = new_solution[pos]\n            next_node = new_solution[pos+1]\n            new_cost = (distance_matrix_1[prev_node, node1] + distance_matrix_1[node2, next_node] +\n                        distance_matrix_2[prev_node, node1] + distance_matrix_2[node2, next_node])\n            improvement = current_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insertion = pos\n\n        if best_insertion is not None:\n            # Remove the edge\n            new_solution = np.concatenate([new_solution[:worst_edge_idx], new_solution[worst_edge_idx+2:]])\n            # Insert between best_insertion and best_insertion+1\n            new_solution = np.concatenate([new_solution[:best_insertion+1], [node1, node2], new_solution[best_insertion+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8856924722481956,
            8.53360801935196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_solutions = []\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for other_sol, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 < cost2) or (other_cost1 < cost1 and other_cost2 <= cost2):\n                dominated = True\n                break\n        if not dominated:\n            potential_solutions.append((sol, cost1, cost2))\n\n    if not potential_solutions:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select based on combined objective score with distance metrics\n        scores = []\n        for sol, cost1, cost2 in potential_solutions:\n            # Calculate average distance in both spaces\n            avg_dist1 = np.mean([distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n            avg_dist2 = np.mean([distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n            # Score combines objective values and local distances\n            score = (cost1 + cost2) / (1 + avg_dist1 + avg_dist2)\n            scores.append(score)\n        selected_idx = np.argmin(scores)\n        base_solution = potential_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, edge swap, and dynamic edge insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    if j - i > 1:\n        # Adaptive segment reversal\n        segment = new_solution[i:j+1]\n        if np.random.random() < 0.5:\n            segment = segment[::-1]  # Reverse\n        else:\n            segment = np.roll(segment, np.random.randint(1, len(segment)))  # Rotate\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    if l - k > 1 and abs(i - k) > 1 and abs(j - l) > 1:\n        # Edge swap between non-overlapping segments\n        segment1 = new_solution[k:l+1]\n        segment2 = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:k], segment2, new_solution[l+1:]])\n        new_solution = np.concatenate([new_solution[:i], segment1, new_solution[j+1:]])\n\n    # Dynamic edge insertion based on distance metrics\n    if np.random.random() < 0.3:\n        # Select an edge from the most costly part of the tour\n        tour_costs1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n        tour_costs2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n        combined_costs = [tour_costs1[i] + tour_costs2[i] for i in range(n-1)]\n        worst_edge_idx = np.argmax(combined_costs)\n\n        # Find a better insertion point\n        node1, node2 = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n        current_cost = distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2]\n\n        best_insertion = None\n        best_improvement = 0\n\n        for pos in range(n-1):\n            if pos == worst_edge_idx or pos == worst_edge_idx-1:\n                continue\n            # Calculate potential improvement\n            prev_node = new_solution[pos]\n            next_node = new_solution[pos+1]\n            new_cost = (distance_matrix_1[prev_node, node1] + distance_matrix_1[node2, next_node] +\n                        distance_matrix_2[prev_node, node1] + distance_matrix_2[node2, next_node])\n            improvement = current_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insertion = pos\n\n        if best_insertion is not None:\n            # Remove the edge\n            new_solution = np.concatenate([new_solution[:worst_edge_idx], new_solution[worst_edge_idx+2:]])\n            # Insert between best_insertion and best_insertion+1\n            new_solution = np.concatenate([new_solution[:best_insertion+1], [node1, node2], new_solution[best_insertion+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{A novel hybrid local search algorithm that combines segment inversion with adaptive edge swaps and Pareto-based selection to generate high-quality neighbors by intelligently exploring the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with adaptive edge swaps\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment and adaptively swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.5:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9141054449785218,
            0.26162898540496826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with adaptive edge swaps\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment and adaptively swap edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.5:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric in the objective space, then applies a novel local search combining multi-objective path relinking with adaptive segment inversion and probabilistic node reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_dist[i] = float('inf')\n        else:\n            crowding_dist[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path relinking\n    if len(archive) > 1 and random.random() < 0.7:\n        guide_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        guide_solution = archive[guide_idx][0]\n        matching_positions = [i for i in range(n) if new_solution[i] == guide_solution[i]]\n\n        if len(matching_positions) > 1:\n            start, end = sorted(random.sample(matching_positions, 2))\n            new_solution[start:end+1] = guide_solution[start:end+1]\n\n    # Adaptive segment inversion\n    if n > 4 and random.random() < 0.6:\n        segment_length = random.randint(2, min(6, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment cost in both objectives\n        cost1 = sum(distance_matrix_1[segment[i-1]][segment[i]] for i in range(len(segment)))\n        cost1 += distance_matrix_1[segment[-1]][segment[0]] if segment_length > 1 else 0\n        cost2 = sum(distance_matrix_2[segment[i-1]][segment[i]] for i in range(len(segment)))\n        cost2 += distance_matrix_2[segment[-1]][segment[0]] if segment_length > 1 else 0\n\n        # Invert if it improves both objectives\n        inv_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inv_segment[i-1]][inv_segment[i]] for i in range(len(inv_segment)))\n        inv_cost1 += distance_matrix_1[inv_segment[-1]][inv_segment[0]] if segment_length > 1 else 0\n        inv_cost2 = sum(distance_matrix_2[inv_segment[i-1]][inv_segment[i]] for i in range(len(inv_segment)))\n        inv_cost2 += distance_matrix_2[inv_segment[-1]][inv_segment[0]] if segment_length > 1 else 0\n\n        if (inv_cost1 < cost1 and inv_cost2 < cost2) or (random.random() < 0.3):\n            new_solution[start:start+segment_length] = inv_segment\n\n    # Probabilistic node reinsertion\n    if n > 3 and random.random() < 0.5:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Find best insertion position\n        min_cost = float('inf')\n        best_pos = 0\n        for i in range(len(new_solution)):\n            cost1 = distance_matrix_1[new_solution[i-1]][node] + distance_matrix_1[node][new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1]][node] + distance_matrix_2[node][new_solution[i]]\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6765564566527018,
            0.8883986473083496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_dist[i] = float('inf')\n        else:\n            crowding_dist[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path relinking\n    if len(archive) > 1 and random.random() < 0.7:\n        guide_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        guide_solution = archive[guide_idx][0]\n        matching_positions = [i for i in range(n) if new_solution[i] == guide_solution[i]]\n\n        if len(matching_positions) > 1:\n            start, end = sorted(random.sample(matching_positions, 2))\n            new_solution[start:end+1] = guide_solution[start:end+1]\n\n    # Adaptive segment inversion\n    if n > 4 and random.random() < 0.6:\n        segment_length = random.randint(2, min(6, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment cost in both objectives\n        cost1 = sum(distance_matrix_1[segment[i-1]][segment[i]] for i in range(len(segment)))\n        cost1 += distance_matrix_1[segment[-1]][segment[0]] if segment_length > 1 else 0\n        cost2 = sum(distance_matrix_2[segment[i-1]][segment[i]] for i in range(len(segment)))\n        cost2 += distance_matrix_2[segment[-1]][segment[0]] if segment_length > 1 else 0\n\n        # Invert if it improves both objectives\n        inv_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inv_segment[i-1]][inv_segment[i]] for i in range(len(inv_segment)))\n        inv_cost1 += distance_matrix_1[inv_segment[-1]][inv_segment[0]] if segment_length > 1 else 0\n        inv_cost2 = sum(distance_matrix_2[inv_segment[i-1]][inv_segment[i]] for i in range(len(inv_segment)))\n        inv_cost2 += distance_matrix_2[inv_segment[-1]][inv_segment[0]] if segment_length > 1 else 0\n\n        if (inv_cost1 < cost1 and inv_cost2 < cost2) or (random.random() < 0.3):\n            new_solution[start:start+segment_length] = inv_segment\n\n    # Probabilistic node reinsertion\n    if n > 3 and random.random() < 0.5:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Find best insertion position\n        min_cost = float('inf')\n        best_pos = 0\n        for i in range(len(new_solution)):\n            cost1 = distance_matrix_1[new_solution[i-1]][node] + distance_matrix_1[node][new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1]][node] + distance_matrix_2[node][new_solution[i]]\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a novel local search combining segment reshuffling, adaptive edge swapping, and objective-aware node reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        is_dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment reshuffling, adaptive edge swapping, and objective-aware reinsertion\n    if n > 3:\n        # Step 1: Segment reshuffling\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_size] = segment\n\n        # Step 2: Adaptive edge swapping based on objective improvement\n        i, j = random.sample(range(n), 2)\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        if (obj1_after > obj1_before and obj2_after > obj2_before) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Objective-aware node reinsertion\n        if random.random() < 0.6:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(n-1):\n                temp_solution = np.insert(new_solution, pos, node)\n                score = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_2[temp_solution[pos-1], temp_solution[pos]]\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9614318146401281,
            1.6416239738464355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        is_dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment reshuffling, adaptive edge swapping, and objective-aware reinsertion\n    if n > 3:\n        # Step 1: Segment reshuffling\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_size] = segment\n\n        # Step 2: Adaptive edge swapping based on objective improvement\n        i, j = random.sample(range(n), 2)\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        if (obj1_after > obj1_before and obj2_after > obj2_before) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Objective-aware node reinsertion\n        if random.random() < 0.6:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(n-1):\n                temp_solution = np.insert(new_solution, pos, node)\n                score = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_2[temp_solution[pos-1], temp_solution[pos]]\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8204762466172162,
            0.10981303453445435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8204762466172162,
            0.10981303453445435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel adaptive objective-weighting metric that dynamically balances Pareto dominance and solution quality, then applies a hybrid local search combining multi-segment inversion, adaptive path reversal, and probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive objective-weighting selection\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment selection\n    if n > 4:\n        num_segments = random.randint(2, min(5, n//2))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        for i in range(0, len(segment_points), 2):\n            if i+1 < len(segment_points):\n                start, end = segment_points[i], segment_points[i+1]\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive path reversal\n    if n > 3:\n        k = random.randint(2, min(6, n//3))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge insertion\n    if n > 2:\n        for _ in range(random.randint(1, min(4, n//5))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.6 * (1 - (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[i-1]][new_solution[j]]) /\n                             (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]] + 1e-10))\n                if random.random() < prob:\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9331405885677861,
            0.27531760931015015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive objective-weighting selection\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment selection\n    if n > 4:\n        num_segments = random.randint(2, min(5, n//2))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        for i in range(0, len(segment_points), 2):\n            if i+1 < len(segment_points):\n                start, end = segment_points[i], segment_points[i+1]\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive path reversal\n    if n > 3:\n        k = random.randint(2, min(6, n//3))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge insertion\n    if n > 2:\n        for _ in range(random.randint(1, min(4, n//5))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.6 * (1 - (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[i-1]][new_solution[j]]) /\n                             (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]] + 1e-10))\n                if random.random() < prob:\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This algorithm selects a solution from the archive based on a novelty metric that combines objective values and structural diversity, then applies a hybrid local search combining segment reversal, adaptive edge swapping, and probabilistic insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novelty-based selection\n    objectives = np.array([obj for _, obj in archive])\n    novelty_scores = []\n    for i in range(len(archive)):\n        novelty = 0\n        for j in range(len(archive)):\n            if i != j:\n                novelty += np.exp(-np.linalg.norm(objectives[i] - objectives[j])**2)\n        novelty_scores.append(novelty)\n    selected_idx = np.argmin(novelty_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Adaptive edge swapping based on objective improvement\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            delta_cost1 = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] -\n                          distance_matrix_1[new_solution[i-1]][new_solution[i]] - distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]])\n            delta_cost2 = (distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]] -\n                          distance_matrix_2[new_solution[i-1]][new_solution[i]] - distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n            if delta_cost1 < 0 or delta_cost2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic insertion based on objective space\n    if n > 2:\n        node = random.choice(new_solution)\n        mask = new_solution != node\n        remaining = new_solution[mask]\n        pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.864427324205703,
            7.95021653175354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novelty-based selection\n    objectives = np.array([obj for _, obj in archive])\n    novelty_scores = []\n    for i in range(len(archive)):\n        novelty = 0\n        for j in range(len(archive)):\n            if i != j:\n                novelty += np.exp(-np.linalg.norm(objectives[i] - objectives[j])**2)\n        novelty_scores.append(novelty)\n    selected_idx = np.argmin(novelty_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Adaptive edge swapping based on objective improvement\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            delta_cost1 = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] -\n                          distance_matrix_1[new_solution[i-1]][new_solution[i]] - distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]])\n            delta_cost2 = (distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]] -\n                          distance_matrix_2[new_solution[i-1]][new_solution[i]] - distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n            if delta_cost1 < 0 or delta_cost2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic insertion based on objective space\n    if n > 2:\n        node = random.choice(new_solution)\n        mask = new_solution != node\n        remaining = new_solution[mask]\n        pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines segment rotation with edge swapping and insertion, while ensuring feasibility through careful validation and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with objective-aware selection\n    if n > 3:\n        segment_length = random.randint(2, min(n // 3, 5))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        rotation = random.randint(1, len(segment) - 1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end] = rotated_segment\n\n    # Edge swapping with distance-based selection\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge insertion with objective-aware selection\n    if n > 3:\n        i = random.randint(0, n - 1)\n        j = (i + random.randint(1, n // 3)) % n\n        if i > j:\n            i, j = j, i\n        edge = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9054001429916769,
            0.24006837606430054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with objective-aware selection\n    if n > 3:\n        segment_length = random.randint(2, min(n // 3, 5))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        rotation = random.randint(1, len(segment) - 1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end] = rotated_segment\n\n    # Edge swapping with distance-based selection\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge insertion with objective-aware selection\n    if n > 3:\n        i = random.randint(0, n - 1)\n        j = (i + random.randint(1, n // 3)) % n\n        if i > j:\n            i, j = j, i\n        edge = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive using a novel hybrid selection criterion that combines objective values with solution structure diversity, then applies a unique local search operator that combines a multi-segment reversal with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection strategy: combine objective values with structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate structural diversity (inverse of commonality in positions)\n    diversity = np.zeros(len(archive))\n    for i, sol in enumerate(solutions):\n        for j in range(n):\n            pos = np.where(sol == j)[0][0]\n            diversity[i] += 1 / (np.sum(solutions[:, pos] == j) + 1)\n\n    combined = np.sum(objectives, axis=1) / diversity\n    selection_probs = np.exp(-combined / np.sum(combined))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal with adaptive segment selection\n    num_segments = min(3, max(2, n // 5))\n    segment_lengths = sorted(random.sample(range(2, n // 2), num_segments))\n    segments = []\n\n    for length in segment_lengths:\n        start = random.randint(0, n - length)\n        segments.append((start, start + length))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for start, end in merged_segments:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swapping based on distance improvement\n    for _ in range(min(3, n // 2)):\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement\n        prev_nodes = [new_solution[(i-1)%n], new_solution[(j-1)%n]]\n        next_nodes = [new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        original_cost = (distance_matrix_1[prev_nodes[0], node_i] + distance_matrix_1[node_i, next_nodes[0]] +\n                         distance_matrix_1[prev_nodes[1], node_j] + distance_matrix_1[node_j, next_nodes[1]] +\n                         distance_matrix_2[prev_nodes[0], node_i] + distance_matrix_2[node_i, next_nodes[0]] +\n                         distance_matrix_2[prev_nodes[1], node_j] + distance_matrix_2[node_j, next_nodes[1]])\n\n        swapped_cost = (distance_matrix_1[prev_nodes[0], node_j] + distance_matrix_1[node_j, next_nodes[0]] +\n                        distance_matrix_1[prev_nodes[1], node_i] + distance_matrix_1[node_i, next_nodes[1]] +\n                        distance_matrix_2[prev_nodes[0], node_j] + distance_matrix_2[node_j, next_nodes[0]] +\n                        distance_matrix_2[prev_nodes[1], node_i] + distance_matrix_2[node_i, next_nodes[1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment and reverse its edges\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects the solution with the highest sum of objectives from the archive and generates a neighbor by performing a novel \"partial tour rotation\" operation that rotates a randomly selected segment of the tour by a random amount while ensuring feasibility through careful segment boundary handling and position validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partial tour rotation operation\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(n, 10))\n    rotation = np.random.randint(1, length)\n\n    if start + length <= n:\n        segment = new_solution[start:start+length]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+length] = rotated_segment\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:length-(n-start)]])\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:] = rotated_segment[:n-start]\n        new_solution[:length-(n-start)] = rotated_segment[n-start:]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8783141039700566,
            0.2572547197341919
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Partial tour rotation operation\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(n, 10))\n    rotation = np.random.randint(1, length)\n\n    if start + length <= n:\n        segment = new_solution[start:start+length]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+length] = rotated_segment\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:length-(n-start)]])\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:] = rotated_segment[:n-start]\n        new_solution[:length-(n-start)] = rotated_segment[n-start:]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and solution structure, then applies a novel hybrid local search combining adaptive segment rotation, dynamic node swapping, and probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective quality and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    quality_scores = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-10)\n\n    # Calculate structural diversity (number of unique edges)\n    diversity_scores = np.zeros(len(archive))\n    for i, (sol, _) in enumerate(archive):\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity_scores[i] = len(edges)\n\n    combined_scores = quality_scores * diversity_scores\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, dynamic node swapping, and probabilistic edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation (rotate a segment by k positions)\n        a, b = sorted(random.sample(range(n), 2))\n        k = random.randint(1, b - a)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, k)\n        new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Dynamic node swapping (swap nodes based on their relative positions)\n        if random.random() < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Probabilistic edge insertion (insert a node between two existing nodes)\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j and new_solution[j] not in new_solution[:i]:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9160828024176649,
            1.2242414355278015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective quality and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    quality_scores = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-10)\n\n    # Calculate structural diversity (number of unique edges)\n    diversity_scores = np.zeros(len(archive))\n    for i, (sol, _) in enumerate(archive):\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity_scores[i] = len(edges)\n\n    combined_scores = quality_scores * diversity_scores\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, dynamic node swapping, and probabilistic edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation (rotate a segment by k positions)\n        a, b = sorted(random.sample(range(n), 2))\n        k = random.randint(1, b - a)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, k)\n        new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Dynamic node swapping (swap nodes based on their relative positions)\n        if random.random() < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Probabilistic edge insertion (insert a node between two existing nodes)\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j and new_solution[j] not in new_solution[:i]:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective performance and solution structure diversity, then applies a novel local search combining multi-segment inversion, adaptive node relocation, and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility through structural validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate selection scores (combination of objective and structural diversity)\n    selection_scores = []\n    for i in range(len(archive)):\n        obj_score = objectives[i][0] * 0.4 + objectives[i][1] * 0.6  # Weighted objective\n        struct_div = 0\n        for j in range(len(archive)):\n            if i != j:\n                # Calculate structural diversity as number of different positions\n                struct_div += np.sum(solutions[i] != solutions[j])\n        selection_scores.append(obj_score + struct_div * 0.001)  # Small weight for diversity\n\n    selected_idx = np.argmin(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment inversion\n    if n > 4:\n        num_segments = random.randint(2, min(4, n//2))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        for i in range(0, len(segment_points), 2):\n            if i+1 < len(segment_points):\n                start, end = segment_points[i], segment_points[i+1]\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Adaptive node relocation\n    if n > 3:\n        for _ in range(random.randint(1, min(3, n//3))):\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Probabilistic edge swapping based on objective improvement\n    if n > 2:\n        for _ in range(random.randint(1, min(4, n//2))):\n            i, j = random.sample(range(n), 2)\n            current_cost = (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]])\n            if swapped_cost < current_cost and random.random() < 0.7:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8531066992984531,
            1.0124489665031433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate selection scores (combination of objective and structural diversity)\n    selection_scores = []\n    for i in range(len(archive)):\n        obj_score = objectives[i][0] * 0.4 + objectives[i][1] * 0.6  # Weighted objective\n        struct_div = 0\n        for j in range(len(archive)):\n            if i != j:\n                # Calculate structural diversity as number of different positions\n                struct_div += np.sum(solutions[i] != solutions[j])\n        selection_scores.append(obj_score + struct_div * 0.001)  # Small weight for diversity\n\n    selected_idx = np.argmin(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment inversion\n    if n > 4:\n        num_segments = random.randint(2, min(4, n//2))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        for i in range(0, len(segment_points), 2):\n            if i+1 < len(segment_points):\n                start, end = segment_points[i], segment_points[i+1]\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Adaptive node relocation\n    if n > 3:\n        for _ in range(random.randint(1, min(3, n//3))):\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Probabilistic edge swapping based on objective improvement\n    if n > 2:\n        for _ in range(random.randint(1, min(4, n//2))):\n            i, j = random.sample(range(n), 2)\n            current_cost = (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]])\n            if swapped_cost < current_cost and random.random() < 0.7:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based score, then applies a hybrid local search combining node reinsertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node reinsertion with distance-based selection\n    i = random.randint(0, n - 1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    j = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n    # Segment rotation with objective-aware selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.roll(new_solution[start:end], random.randint(1, segment_length - 1))\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.880035067911367,
            0.22626996040344238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node reinsertion with distance-based selection\n    i = random.randint(0, n - 1)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    j = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n    # Segment rotation with objective-aware selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.roll(new_solution[start:end], random.randint(1, segment_length - 1))\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal with a probability-based selection to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with probability\n    if random.random() < 0.7:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = rotated_segment\n\n    # Apply node insertion with probability\n    if random.random() < 0.6:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply edge reversal with probability\n    if random.random() < 0.5 and n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This algorithm selects a solution from the archive based on the Pareto dominance criterion, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping with adaptive probabilities to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected_idx = random.randint(0, len(non_dominated)-1)\n        base_solution = non_dominated[selected_idx][0].copy()\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probabilities based on solution quality\n    prob_relocation = min(0.8, 0.5 + 0.3 * (1 - min(obj[0], obj[1]) / max(obj[0], obj[1])))\n    prob_inversion = min(0.7, 0.4 + 0.3 * (1 - min(obj[0], obj[1]) / max(obj[0], obj[1])))\n    prob_swap = min(0.6, 0.3 + 0.3 * (1 - min(obj[0], obj[1]) / max(obj[0], obj[1])))\n\n    # Apply node relocation with adaptive probability\n    if random.random() < prob_relocation:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Apply segment inversion with adaptive probability\n    if random.random() < prob_inversion and n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply edge swapping with adaptive probability\n    if random.random() < prob_swap and n > 3:\n        i = random.randint(0, n-3)\n        j = random.randint(i+2, n-1)\n        if j-i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8369257542093216,
            0.5829450488090515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected_idx = random.randint(0, len(non_dominated)-1)\n        base_solution = non_dominated[selected_idx][0].copy()\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probabilities based on solution quality\n    prob_relocation = min(0.8, 0.5 + 0.3 * (1 - min(obj[0], obj[1]) / max(obj[0], obj[1])))\n    prob_inversion = min(0.7, 0.4 + 0.3 * (1 - min(obj[0], obj[1]) / max(obj[0], obj[1])))\n    prob_swap = min(0.6, 0.3 + 0.3 * (1 - min(obj[0], obj[1]) / max(obj[0], obj[1])))\n\n    # Apply node relocation with adaptive probability\n    if random.random() < prob_relocation:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Apply segment inversion with adaptive probability\n    if random.random() < prob_inversion and n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply edge swapping with adaptive probability\n    if random.random() < prob_swap and n > 3:\n        i = random.randint(0, n-3)\n        j = random.randint(i+2, n-1)\n        if j-i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment and reverse its edges\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            reversed_edge = edge[::-1]\n            new_solution = np.concatenate([new_solution[:k], reversed_edge, new_solution[k+2:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9699656213682843,
            0.24710822105407715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9592633838131188,
            0.216597318649292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a hybrid local search combining segment rotation, adaptive edge swapping, and probabilistic node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation, adaptive edge swapping, and probabilistic node relocation\n    if n > 3:\n        # Step 1: Segment rotation (rotate a segment by a random amount)\n        if random.random() < 0.6:\n            segment_len = random.randint(2, min(4, n//3))\n            start = random.randint(0, n - segment_len)\n            shift = random.randint(1, segment_len - 1)\n            segment = new_solution[start:start+segment_len]\n            new_solution[start:start+segment_len] = np.concatenate([segment[shift:], segment[:shift]])\n\n        # Step 2: Adaptive edge swapping (swap edges based on their contribution to objectives)\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate cost change for both objectives\n                cost_change1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                               distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_change2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                               distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                # Accept if both objectives improve or one improves significantly\n                if (cost_change1 < 0 and cost_change2 < 0) or (random.random() < 0.3 and (cost_change1 < 0 or cost_change2 < 0)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Probabilistic node relocation (move a node to a better position)\n        if random.random() < 0.4:\n            node_idx = random.randint(0, n-1)\n            node = new_solution[node_idx]\n            best_pos = node_idx\n            best_cost = float('inf')\n\n            for pos in range(n):\n                if pos != node_idx:\n                    # Calculate cost for both objectives\n                    if pos == 0:\n                        prev = new_solution[-1]\n                        next_node = new_solution[1]\n                    elif pos == n-1:\n                        prev = new_solution[-2]\n                        next_node = new_solution[0]\n                    else:\n                        prev = new_solution[pos-1]\n                        next_node = new_solution[pos+1]\n\n                    current_cost = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] + \\\n                                 distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        best_pos = pos\n\n            if best_pos != node_idx:\n                new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9042481229715669,
            5.496088683605194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation, adaptive edge swapping, and probabilistic node relocation\n    if n > 3:\n        # Step 1: Segment rotation (rotate a segment by a random amount)\n        if random.random() < 0.6:\n            segment_len = random.randint(2, min(4, n//3))\n            start = random.randint(0, n - segment_len)\n            shift = random.randint(1, segment_len - 1)\n            segment = new_solution[start:start+segment_len]\n            new_solution[start:start+segment_len] = np.concatenate([segment[shift:], segment[:shift]])\n\n        # Step 2: Adaptive edge swapping (swap edges based on their contribution to objectives)\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate cost change for both objectives\n                cost_change1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                               distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_change2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                               distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                # Accept if both objectives improve or one improves significantly\n                if (cost_change1 < 0 and cost_change2 < 0) or (random.random() < 0.3 and (cost_change1 < 0 or cost_change2 < 0)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Probabilistic node relocation (move a node to a better position)\n        if random.random() < 0.4:\n            node_idx = random.randint(0, n-1)\n            node = new_solution[node_idx]\n            best_pos = node_idx\n            best_cost = float('inf')\n\n            for pos in range(n):\n                if pos != node_idx:\n                    # Calculate cost for both objectives\n                    if pos == 0:\n                        prev = new_solution[-1]\n                        next_node = new_solution[1]\n                    elif pos == n-1:\n                        prev = new_solution[-2]\n                        next_node = new_solution[0]\n                    else:\n                        prev = new_solution[pos-1]\n                        next_node = new_solution[pos+1]\n\n                    current_cost = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] + \\\n                                 distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        best_pos = pos\n\n            if best_pos != node_idx:\n                new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This algorithm selects a solution with the highest combined improvement potential from the archive, then applies a hybrid local search combining node insertion and adaptive segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion combined with adaptive segment rotation\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Node insertion\n    if abs(i - j) > 1 and k not in range(i, j):\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        new_solution = np.insert(new_solution, k, node)\n\n    # Adaptive segment rotation\n    if np.random.random() < 0.4:\n        m = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - m)\n        shift = np.random.randint(1, m)\n        new_solution[start:start+m] = np.roll(new_solution[start:start+m], shift)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9021259903415585,
            0.33526521921157837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion combined with adaptive segment rotation\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Node insertion\n    if abs(i - j) > 1 and k not in range(i, j):\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        new_solution = np.insert(new_solution, k, node)\n\n    # Adaptive segment rotation\n    if np.random.random() < 0.4:\n        m = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - m)\n        shift = np.random.randint(1, m)\n        new_solution[start:start+m] = np.roll(new_solution[start:start+m], shift)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective-diversity metric that prioritizes solutions with better objective values and higher structural diversity, then applies a novel local search combining adaptive segment inversion, probabilistic edge flipping, and multi-objective aware node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective-diversity metric\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = []\n    for i in range(len(archive)):\n        total_dist = 0\n        for j in range(len(archive)):\n            if i != j:\n                total_dist += np.linalg.norm(objectives[i] - objectives[j])\n        diversity_scores.append(total_dist)\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-10)\n    combined_scores = 0.7 * (1 - normalized_obj[:, 0]) + 0.3 * (1 - normalized_obj[:, 1]) + 0.2 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 4:\n        k = random.randint(2, min(6, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge flipping\n    if n > 3:\n        for _ in range(random.randint(1, min(4, n//3))):\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if abs(i - j) > 1:\n                prob = 0.5 * (1 - (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) /\n                            (distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    if i < j:\n                        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                    else:\n                        new_solution[j:i+1] = new_solution[j:i+1][::-1]\n\n    # Multi-objective aware node insertion\n    if n > 5:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i, j = random.sample(range(n), 2)\n            if i != j:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                cost1 = sum(distance_matrix_1[temp[k]][temp[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp[k]][temp[(k+1)%n]] for k in range(n))\n                if (cost1 <= sum(distance_matrix_1[new_solution[k]][new_solution[(k+1)%n]] for k in range(n)) and\n                    cost2 <= sum(distance_matrix_2[new_solution[k]][new_solution[(k+1)%n]] for k in range(n))):\n                    new_solution = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8340335779048704,
            4.062917709350586
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective-diversity metric\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = []\n    for i in range(len(archive)):\n        total_dist = 0\n        for j in range(len(archive)):\n            if i != j:\n                total_dist += np.linalg.norm(objectives[i] - objectives[j])\n        diversity_scores.append(total_dist)\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-10)\n    combined_scores = 0.7 * (1 - normalized_obj[:, 0]) + 0.3 * (1 - normalized_obj[:, 1]) + 0.2 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 4:\n        k = random.randint(2, min(6, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge flipping\n    if n > 3:\n        for _ in range(random.randint(1, min(4, n//3))):\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if abs(i - j) > 1:\n                prob = 0.5 * (1 - (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) /\n                            (distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    if i < j:\n                        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                    else:\n                        new_solution[j:i+1] = new_solution[j:i+1][::-1]\n\n    # Multi-objective aware node insertion\n    if n > 5:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i, j = random.sample(range(n), 2)\n            if i != j:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                cost1 = sum(distance_matrix_1[temp[k]][temp[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp[k]][temp[(k+1)%n]] for k in range(n))\n                if (cost1 <= sum(distance_matrix_1[new_solution[k]][new_solution[(k+1)%n]] for k in range(n)) and\n                    cost2 <= sum(distance_matrix_2[new_solution[k]][new_solution[(k+1)%n]] for k in range(n))):\n                    new_solution = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that prioritizes solutions with high variance in their objective values, then applies a novel local search operator that combines adaptive path inversion with constrained edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high variance in objective values\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive path inversion with constrained edge insertion\n    if n > 3:\n        # Step 1: Adaptive path inversion (invert a segment based on objective improvement)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate original and reversed costs\n        original_cost1 = distance_matrix_1[segment[-1], segment[0]] + sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        original_cost2 = distance_matrix_2[segment[-1], segment[0]] + sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        reversed_cost1 = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = distance_matrix_2[reversed_segment[-1], reversed_segment[0]] + sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept inversion if it improves at least one objective\n        if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Constrained edge insertion (insert an edge from another solution if it improves both objectives)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for i in range(len(other_solution)-1):\n                node1, node2 = other_solution[i], other_solution[i+1]\n                if node1 not in new_solution and node2 not in new_solution:\n                    # Find insertion points that maintain feasibility\n                    pos1 = random.randint(0, n-1)\n                    pos2 = random.randint(0, n-1)\n                    if pos1 != pos2:\n                        # Calculate cost before insertion\n                        cost1_before = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n                        cost2_before = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n\n                        # Calculate cost after insertion\n                        cost1_after = distance_matrix_1[new_solution[pos1-1], node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_solution[pos2]]\n                        cost2_after = distance_matrix_2[new_solution[pos1-1], node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_solution[pos2]]\n\n                        if (cost1_after < cost1_before) and (cost2_after < cost2_before):\n                            new_solution = np.insert(new_solution, pos1, node1)\n                            new_solution = np.insert(new_solution, pos2+1, node2)\n                            new_solution = new_solution[:n+2]  # Ensure length remains the same\n                            break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.4819823428675615,
            1.5998554229736328
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high variance in objective values\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive path inversion with constrained edge insertion\n    if n > 3:\n        # Step 1: Adaptive path inversion (invert a segment based on objective improvement)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate original and reversed costs\n        original_cost1 = distance_matrix_1[segment[-1], segment[0]] + sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        original_cost2 = distance_matrix_2[segment[-1], segment[0]] + sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        reversed_cost1 = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = distance_matrix_2[reversed_segment[-1], reversed_segment[0]] + sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept inversion if it improves at least one objective\n        if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Constrained edge insertion (insert an edge from another solution if it improves both objectives)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for i in range(len(other_solution)-1):\n                node1, node2 = other_solution[i], other_solution[i+1]\n                if node1 not in new_solution and node2 not in new_solution:\n                    # Find insertion points that maintain feasibility\n                    pos1 = random.randint(0, n-1)\n                    pos2 = random.randint(0, n-1)\n                    if pos1 != pos2:\n                        # Calculate cost before insertion\n                        cost1_before = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n                        cost2_before = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n\n                        # Calculate cost after insertion\n                        cost1_after = distance_matrix_1[new_solution[pos1-1], node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_solution[pos2]]\n                        cost2_after = distance_matrix_2[new_solution[pos1-1], node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_solution[pos2]]\n\n                        if (cost1_after < cost1_before) and (cost2_after < cost2_before):\n                            new_solution = np.insert(new_solution, pos1, node1)\n                            new_solution = np.insert(new_solution, pos2+1, node2)\n                            new_solution = new_solution[:n+2]  # Ensure length remains the same\n                            break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining segment inversion, probabilistic edge insertion, and adaptive node relocation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = []\n    for i in range(len(archive)):\n        total_dist = 0\n        for j in range(len(archive)):\n            if i != j:\n                total_dist += np.linalg.norm(objectives[i] - objectives[j])\n        diversity_scores.append(total_dist)\n    normalized_div = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-10)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.3 * normalized_div\n    selected_idx = np.argmin(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive segment size\n    if n > 4:\n        seg_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Probabilistic edge insertion\n    if n > 3:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.7 * (1 - (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]]) /\n                             (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    if i < j:\n                        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n                    else:\n                        new_solution = np.concatenate([new_solution[:j+1], new_solution[i:i+1], new_solution[j+1:i], new_solution[i+1:]])\n\n    # Adaptive node relocation\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//3))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j and abs(i - j) > 1:\n                delta = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] -\n                         distance_matrix_1[new_solution[i-1]][new_solution[i]] - distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]] -\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] - distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n                if delta < 0 or random.random() < 0.3:\n                    node = new_solution[i]\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6042860555873274,
            3.477302074432373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = []\n    for i in range(len(archive)):\n        total_dist = 0\n        for j in range(len(archive)):\n            if i != j:\n                total_dist += np.linalg.norm(objectives[i] - objectives[j])\n        diversity_scores.append(total_dist)\n    normalized_div = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-10)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.3 * normalized_div\n    selected_idx = np.argmin(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive segment size\n    if n > 4:\n        seg_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Probabilistic edge insertion\n    if n > 3:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.7 * (1 - (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]]) /\n                             (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    if i < j:\n                        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n                    else:\n                        new_solution = np.concatenate([new_solution[:j+1], new_solution[i:i+1], new_solution[j+1:i], new_solution[i+1:]])\n\n    # Adaptive node relocation\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//3))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j and abs(i - j) > 1:\n                delta = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] -\n                         distance_matrix_1[new_solution[i-1]][new_solution[i]] - distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]] -\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] - distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n                if delta < 0 or random.random() < 0.3:\n                    node = new_solution[i]\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm selects a solution from the archive based on the average of its normalized objective values, then applies a novel hybrid local search that combines segment reversal with adaptive edge swapping to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    avg_scores = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(avg_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with adaptive edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Adaptive edge swapping based on distance matrices\n        if np.random.random() < 0.7:  # 70% chance to swap edges\n            a = np.random.randint(0, n)\n            b = np.random.randint(0, n)\n            if a != b:\n                # Calculate combined distance change\n                old_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]])\n                new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[a]])\n                if new_dist < old_dist:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8150838408353961,
            0.271686851978302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    avg_scores = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(avg_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with adaptive edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Adaptive edge swapping based on distance matrices\n        if np.random.random() < 0.7:  # 70% chance to swap edges\n            a = np.random.randint(0, n)\n            b = np.random.randint(0, n)\n            if a != b:\n                # Calculate combined distance change\n                old_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]])\n                new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[a]])\n                if new_dist < old_dist:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective-aware and structural diversity metric, then applies a novel local search strategy combining adaptive segment rotation, dynamic edge swapping, and probabilistic node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection metric combining objective values and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    structural_diversity = [np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))]\n    diversity_score = np.mean(structural_diversity) if structural_diversity else 0\n    hybrid_scores = (1 - normalized_obj[:, 0]) * 0.7 + (1 - normalized_obj[:, 1]) * 0.3 + diversity_score * 0.2\n    selected_idx = np.argmax(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 4:\n        segment_len = random.randint(2, min(6, n//3))\n        start = random.randint(0, n - segment_len)\n        rotation = random.randint(1, segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n    # Dynamic edge swapping\n    if n > 3 and random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic node relocation\n    if random.random() < 0.5:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9561490389251008,
            0.7599260807037354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection metric combining objective values and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    structural_diversity = [np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))]\n    diversity_score = np.mean(structural_diversity) if structural_diversity else 0\n    hybrid_scores = (1 - normalized_obj[:, 0]) * 0.7 + (1 - normalized_obj[:, 1]) * 0.3 + diversity_score * 0.2\n    selected_idx = np.argmax(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 4:\n        segment_len = random.randint(2, min(6, n//3))\n        start = random.randint(0, n - segment_len)\n        rotation = random.randint(1, segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n    # Dynamic edge swapping\n    if n > 3 and random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic node relocation\n    if random.random() < 0.5:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a novel hybrid local search combining segment swapping, adaptive edge flipping, and multi-objective-aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swapping, adaptive edge flipping, and multi-objective-aware node reinsertion\n    if n > 3:\n        # Step 1: Segment swapping\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n        # Step 2: Adaptive edge flipping (flip edges based on multi-objective criteria)\n        if random.random() < 0.6:\n            i = random.randint(0, n-2)\n            j = (i + 1) % n\n            k = (j + 1) % n\n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (new_cost1 < cost1 and new_cost2 < cost2) or (random.random() < 0.3):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Step 3: Multi-objective-aware node reinsertion\n        if random.random() < 0.8:\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            best_pos = 0\n            best_cost = float('inf')\n\n            for j in range(len(new_solution)):\n                temp_solution = np.insert(new_solution, j, node)\n                cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = j\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9058103647880014,
            0.9224817752838135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swapping, adaptive edge flipping, and multi-objective-aware node reinsertion\n    if n > 3:\n        # Step 1: Segment swapping\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n        # Step 2: Adaptive edge flipping (flip edges based on multi-objective criteria)\n        if random.random() < 0.6:\n            i = random.randint(0, n-2)\n            j = (i + 1) % n\n            k = (j + 1) % n\n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (new_cost1 < cost1 and new_cost2 < cost2) or (random.random() < 0.3):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Step 3: Multi-objective-aware node reinsertion\n        if random.random() < 0.8:\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            best_pos = 0\n            best_cost = float('inf')\n\n            for j in range(len(new_solution)):\n                temp_solution = np.insert(new_solution, j, node)\n                cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = j\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a hybrid local search combining segment inversion, probabilistic edge insertion, and adaptive node relocation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and quality\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = []\n    for i, obj in enumerate(objectives):\n        quality = (1 - obj[0] / np.max(objectives[:, 0])) * 0.6 + (1 - obj[1] / np.max(objectives[:, 1])) * 0.4\n        quality_scores.append(quality)\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge insertion\n    if n > 4:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.7 * (1 - (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]]) /\n                         (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive node relocation\n    if n > 3:\n        for _ in range(random.randint(1, min(2, n//4))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                gain = (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]]) - \\\n                       (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]])\n                if gain > 0:\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [new_solution[i]], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8297519276011881,
            0.5423035621643066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and quality\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = []\n    for i, obj in enumerate(objectives):\n        quality = (1 - obj[0] / np.max(objectives[:, 0])) * 0.6 + (1 - obj[1] / np.max(objectives[:, 1])) * 0.4\n        quality_scores.append(quality)\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge insertion\n    if n > 4:\n        for _ in range(random.randint(1, min(2, n//5))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.7 * (1 - (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]]) /\n                         (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive node relocation\n    if n > 3:\n        for _ in range(random.randint(1, min(2, n//4))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                gain = (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]]) - \\\n                       (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]])\n                if gain > 0:\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [new_solution[i]], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a novel hybrid local search combining adaptive segment rotation, multi-point inversion, and edge reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)\n    selection_probs = improvement_potential / np.sum(improvement_potential)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, multi-point inversion, and edge reinsertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation (rotate a segment by random positions)\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        shift = random.randint(1, segment_len-1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Multi-point inversion (invert multiple random segments)\n        for _ in range(random.randint(1, 3)):\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 3: Edge reinsertion (remove and reinsert a random edge)\n        if random.random() < 0.6:\n            i = random.randint(0, n-2)\n            node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8547990858460599,
            0.24059545993804932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)\n    selection_probs = improvement_potential / np.sum(improvement_potential)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, multi-point inversion, and edge reinsertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation (rotate a segment by random positions)\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        shift = random.randint(1, segment_len-1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Multi-point inversion (invert multiple random segments)\n        for _ in range(random.randint(1, 3)):\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 3: Edge reinsertion (remove and reinsert a random edge)\n        if random.random() < 0.6:\n            i = random.randint(0, n-2)\n            node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping with dynamic edge reversal and weighted objective-aware segment selection to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective weights\n    obj1, obj2 = archive[0][1]\n    weight1 = obj1 / (obj1 + obj2)\n    weight2 = obj2 / (obj1 + obj2)\n\n    # Dynamic segment swapping with weighted probability\n    if np.random.random() < weight1:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            segment = new_solution[i:j]\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[j:l], new_solution[k:j], new_solution[l:]])\n    else:\n        # Dynamic edge reversal with objective-aware segment size\n        segment_size = int(np.random.randint(2, min(5, n//2 + 1)))\n        k = np.random.randint(0, n - segment_size)\n        new_solution[k:k+segment_size] = new_solution[k:k+segment_size][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7927194066227611,
            0.2658660411834717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective weights\n    obj1, obj2 = archive[0][1]\n    weight1 = obj1 / (obj1 + obj2)\n    weight2 = obj2 / (obj1 + obj2)\n\n    # Dynamic segment swapping with weighted probability\n    if np.random.random() < weight1:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            segment = new_solution[i:j]\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[j:l], new_solution[k:j], new_solution[l:]])\n    else:\n        # Dynamic edge reversal with objective-aware segment size\n        segment_size = int(np.random.randint(2, min(5, n//2 + 1)))\n        k = np.random.randint(0, n - segment_size)\n        new_solution[k:k+segment_size] = new_solution[k:k+segment_size][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7730269848799013,
            0.10314202308654785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7730269848799013,
            0.10314202308654785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{A novel heuristic that combines adaptive segment swapping with dynamic edge reversal, guided by objective-specific distance matrices to balance exploration and exploitation in the bi-objective TSP landscape.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selection_prob = np.array([1.0 / (i + 1) for i in range(len(sorted_archive))])\n    selection_prob /= selection_prob.sum()\n    selected_idx = np.random.choice(len(sorted_archive), p=selection_prob)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective distances\n    def calculate_segment_cost(solution, i, j, distance_matrix):\n        cost = 0\n        for k in range(i, j-1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[j-1], solution[i]]\n        return cost\n\n    # Find segments with high potential for improvement\n    candidate_segments = []\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            cost1 = calculate_segment_cost(new_solution, i, j, distance_matrix_1)\n            cost2 = calculate_segment_cost(new_solution, i, j, distance_matrix_2)\n            candidate_segments.append((i, j, cost1 + cost2))\n\n    if candidate_segments:\n        # Select the segment with highest cost\n        i, j, _ = max(candidate_segments, key=lambda x: x[2])\n\n        # Dynamic edge reversal with objective-aware selection\n        if np.random.random() < 0.7:  # Higher probability for reversal\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Objective-aware segment swap\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                segment1 = new_solution[i:j].copy()\n                segment2 = new_solution[k:l].copy()\n\n                # Calculate potential improvement\n                old_cost1 = calculate_segment_cost(new_solution, i, j, distance_matrix_1) + calculate_segment_cost(new_solution, k, l, distance_matrix_1)\n                new_cost1 = calculate_segment_cost(np.concatenate([segment2, new_solution[j:k], segment1]), 0, len(segment2), distance_matrix_1)\n\n                old_cost2 = calculate_segment_cost(new_solution, i, j, distance_matrix_2) + calculate_segment_cost(new_solution, k, l, distance_matrix_2)\n                new_cost2 = calculate_segment_cost(np.concatenate([segment2, new_solution[j:k], segment1]), 0, len(segment2), distance_matrix_2)\n\n                if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8649356815901206,
            0.27502554655075073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selection_prob = np.array([1.0 / (i + 1) for i in range(len(sorted_archive))])\n    selection_prob /= selection_prob.sum()\n    selected_idx = np.random.choice(len(sorted_archive), p=selection_prob)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective distances\n    def calculate_segment_cost(solution, i, j, distance_matrix):\n        cost = 0\n        for k in range(i, j-1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[j-1], solution[i]]\n        return cost\n\n    # Find segments with high potential for improvement\n    candidate_segments = []\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            cost1 = calculate_segment_cost(new_solution, i, j, distance_matrix_1)\n            cost2 = calculate_segment_cost(new_solution, i, j, distance_matrix_2)\n            candidate_segments.append((i, j, cost1 + cost2))\n\n    if candidate_segments:\n        # Select the segment with highest cost\n        i, j, _ = max(candidate_segments, key=lambda x: x[2])\n\n        # Dynamic edge reversal with objective-aware selection\n        if np.random.random() < 0.7:  # Higher probability for reversal\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Objective-aware segment swap\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                segment1 = new_solution[i:j].copy()\n                segment2 = new_solution[k:l].copy()\n\n                # Calculate potential improvement\n                old_cost1 = calculate_segment_cost(new_solution, i, j, distance_matrix_1) + calculate_segment_cost(new_solution, k, l, distance_matrix_1)\n                new_cost1 = calculate_segment_cost(np.concatenate([segment2, new_solution[j:k], segment1]), 0, len(segment2), distance_matrix_1)\n\n                old_cost2 = calculate_segment_cost(new_solution, i, j, distance_matrix_2) + calculate_segment_cost(new_solution, k, l, distance_matrix_2)\n                new_cost2 = calculate_segment_cost(np.concatenate([segment2, new_solution[j:k], segment1]), 0, len(segment2), distance_matrix_2)\n\n                if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This new algorithm selects a solution from the archive using a hybrid metric combining objective performance and solution structure, then applies a novel local search combining adaptive segment inversion, probabilistic edge flipping, and multi-objective aware node insertion to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on objective performance and solution structure\n    objectives = np.array([obj for _, obj in archive])\n    structure_scores = []\n    for sol, _ in archive:\n        structure_score = 0\n        for i in range(len(sol)):\n            structure_score += distance_matrix_1[sol[i-1]][sol[i]] + distance_matrix_2[sol[i-1]][sol[i]]\n        structure_scores.append(structure_score)\n\n    combined_scores = objectives[:, 0] + objectives[:, 1] + np.array(structure_scores)\n    selected_idx = np.argmin(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 4:\n        k = random.randint(2, min(6, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge flipping\n    if n > 3:\n        for _ in range(random.randint(1, min(4, n//3))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.7 * (1 - (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) /\n                            (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]] +\n                             distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective aware node insertion\n    if n > 5:\n        for _ in range(random.randint(1, min(3, n//5))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                obj1_cost = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] -\n                            distance_matrix_1[new_solution[i-1]][new_solution[i]] - distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]])\n                obj2_cost = (distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]] -\n                            distance_matrix_2[new_solution[i-1]][new_solution[i]] - distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n                if obj1_cost + obj2_cost < 0:\n                    new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8695429937172858,
            1.0184975862503052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on objective performance and solution structure\n    objectives = np.array([obj for _, obj in archive])\n    structure_scores = []\n    for sol, _ in archive:\n        structure_score = 0\n        for i in range(len(sol)):\n            structure_score += distance_matrix_1[sol[i-1]][sol[i]] + distance_matrix_2[sol[i-1]][sol[i]]\n        structure_scores.append(structure_score)\n\n    combined_scores = objectives[:, 0] + objectives[:, 1] + np.array(structure_scores)\n    selected_idx = np.argmin(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 4:\n        k = random.randint(2, min(6, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Probabilistic edge flipping\n    if n > 3:\n        for _ in range(random.randint(1, min(4, n//3))):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                prob = 0.7 * (1 - (distance_matrix_1[new_solution[i]][new_solution[j]] + distance_matrix_2[new_solution[i]][new_solution[j]]) /\n                            (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i-1]][new_solution[i]] +\n                             distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]] + 1e-10))\n                if random.random() < prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective aware node insertion\n    if n > 5:\n        for _ in range(random.randint(1, min(3, n//5))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                obj1_cost = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] -\n                            distance_matrix_1[new_solution[i-1]][new_solution[i]] - distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]])\n                obj2_cost = (distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]] -\n                            distance_matrix_2[new_solution[i-1]][new_solution[i]] - distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n                if obj1_cost + obj2_cost < 0:\n                    new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a novel hybrid local search combining adaptive segment permutation, cross-segment insertion, and objective-aware edge selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection criterion: balance between objective improvement potential and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Calculate improvement potential (lower is better)\n    improvement_potential = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)\n\n    # Combine scores with adaptive weights\n    selection_weights = diversity_scores * improvement_potential\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment permutation, cross-segment insertion, and objective-aware edge selection\n    if n > 3:\n        # Step 1: Adaptive segment permutation (permute a segment with length based on objective values)\n        segment_len = max(2, min(5, int(n * 0.3 * (1 - (objectives[selected_idx, 0] + objectives[selected_idx, 1]) / (np.sum(objectives) + 1e-10)))))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n\n        # Permute segment with probability based on its length\n        if random.random() < (segment_len / n):\n            permuted_segment = np.random.permutation(segment)\n            new_solution[start:start+segment_len] = permuted_segment\n\n        # Step 2: Cross-segment insertion (insert a segment from another part of the tour)\n        if random.random() < 0.6:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b]\n            insert_pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Step 3: Objective-aware edge selection (swap edges based on their contribution to objectives)\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate potential improvement for both objectives\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9300430704612781,
            0.2432357668876648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection criterion: balance between objective improvement potential and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Calculate improvement potential (lower is better)\n    improvement_potential = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)\n\n    # Combine scores with adaptive weights\n    selection_weights = diversity_scores * improvement_potential\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment permutation, cross-segment insertion, and objective-aware edge selection\n    if n > 3:\n        # Step 1: Adaptive segment permutation (permute a segment with length based on objective values)\n        segment_len = max(2, min(5, int(n * 0.3 * (1 - (objectives[selected_idx, 0] + objectives[selected_idx, 1]) / (np.sum(objectives) + 1e-10)))))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n\n        # Permute segment with probability based on its length\n        if random.random() < (segment_len / n):\n            permuted_segment = np.random.permutation(segment)\n            new_solution[start:start+segment_len] = permuted_segment\n\n        # Step 2: Cross-segment insertion (insert a segment from another part of the tour)\n        if random.random() < 0.6:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b]\n            insert_pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Step 3: Objective-aware edge selection (swap edges based on their contribution to objectives)\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate potential improvement for both objectives\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{The new algorithm selects a promising solution from the archive and generates a neighbor by performing a multi-segment crossover with adaptive segment selection, while ensuring feasibility through validation and repairing invalid solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    num_segments = np.random.randint(2, min(5, n//2))\n    segment_indices = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n    segments = np.split(new_solution, segment_indices)\n\n    # Shuffle segments while preserving the first and last nodes\n    middle_segments = segments[1:-1]\n    np.random.shuffle(middle_segments)\n    new_solution = np.concatenate([segments[0]] + middle_segments + [segments[-1]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair by inserting missing nodes\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(1, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8559223671282686,
            0.29383569955825806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    num_segments = np.random.randint(2, min(5, n//2))\n    segment_indices = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n    segments = np.split(new_solution, segment_indices)\n\n    # Shuffle segments while preserving the first and last nodes\n    middle_segments = segments[1:-1]\n    np.random.shuffle(middle_segments)\n    new_solution = np.concatenate([segments[0]] + middle_segments + [segments[-1]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair by inserting missing nodes\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(1, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This algorithm selects a solution from the archive based on a novelty metric that combines objective space distance and solution structure, then applies a hybrid local search combining adaptive path inversion, multi-segment relinking, and probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novelty-based selection\n    objectives = np.array([obj for _, obj in archive])\n    novelty_scores = []\n    for i in range(len(archive)):\n        dist_sum = 0\n        for j in range(len(archive)):\n            if i != j:\n                obj_dist = np.linalg.norm(objectives[i] - objectives[j])\n                sol_dist = np.sum(archive[i][0] != archive[j][0])\n                dist_sum += obj_dist * sol_dist\n        novelty_scores.append(dist_sum)\n    selected_idx = np.argmax(novelty_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Multi-segment relinking\n    if n > 5:\n        num_segments = random.randint(2, min(3, n//4))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Probabilistic edge insertion\n    if n > 2:\n        for _ in range(random.randint(1, min(2, n//3))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.3 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]))\n            if random.random() < prob:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7289833129252645,
            5.913075149059296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novelty-based selection\n    objectives = np.array([obj for _, obj in archive])\n    novelty_scores = []\n    for i in range(len(archive)):\n        dist_sum = 0\n        for j in range(len(archive)):\n            if i != j:\n                obj_dist = np.linalg.norm(objectives[i] - objectives[j])\n                sol_dist = np.sum(archive[i][0] != archive[j][0])\n                dist_sum += obj_dist * sol_dist\n        novelty_scores.append(dist_sum)\n    selected_idx = np.argmax(novelty_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Multi-segment relinking\n    if n > 5:\n        num_segments = random.randint(2, min(3, n//4))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Probabilistic edge insertion\n    if n > 2:\n        for _ in range(random.randint(1, min(2, n//3))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.3 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]))\n            if random.random() < prob:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective correlation and structural entropy, then applies a hybrid local search combining adaptive segment inversion, multi-objective edge swapping, and probabilistic segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective correlation and structural entropy\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate correlation between objectives\n    corr = np.corrcoef(objectives.T)[0, 1]\n\n    # Calculate structural entropy (diversity)\n    entropy_scores = []\n    for sol in solutions:\n        entropy = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if sol[i] < sol[j]:\n                    entropy += 1\n        entropy_scores.append(entropy)\n\n    # Combine correlation and entropy for selection\n    weights = 0.7 if corr > 0 else 0.3  # More weight to entropy if objectives are anti-correlated\n    scores = weights * np.array(entropy_scores) + (1-weights) * np.linalg.norm(objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Adaptive segment inversion\n    if n > 4:\n        segment_length = max(2, min(n//3, random.randint(2, n//2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge swapping\n    if n > 3:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            delta1 = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] -\n                     (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]]))\n            delta2 = (distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]] -\n                     (distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]]))\n            if delta1 + delta2 < 0 or random.random() < 0.3:  # Accept if better or with small probability\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment rotation\n    if n > 5:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        if random.random() < 0.5:  # Apply with 50% probability\n            new_solution[start:start+k] = rotated\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8130446851708948,
            1.4617570638656616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective correlation and structural entropy\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate correlation between objectives\n    corr = np.corrcoef(objectives.T)[0, 1]\n\n    # Calculate structural entropy (diversity)\n    entropy_scores = []\n    for sol in solutions:\n        entropy = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if sol[i] < sol[j]:\n                    entropy += 1\n        entropy_scores.append(entropy)\n\n    # Combine correlation and entropy for selection\n    weights = 0.7 if corr > 0 else 0.3  # More weight to entropy if objectives are anti-correlated\n    scores = weights * np.array(entropy_scores) + (1-weights) * np.linalg.norm(objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Adaptive segment inversion\n    if n > 4:\n        segment_length = max(2, min(n//3, random.randint(2, n//2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge swapping\n    if n > 3:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            delta1 = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] -\n                     (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]]))\n            delta2 = (distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]] -\n                     (distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]]))\n            if delta1 + delta2 < 0 or random.random() < 0.3:  # Accept if better or with small probability\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment rotation\n    if n > 5:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        if random.random() < 0.5:  # Apply with 50% probability\n            new_solution[start:start+k] = rotated\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{The new algorithm combines adaptive segment reversal with guided edge swaps to explore diverse neighborhoods while maintaining feasibility, inspired by the segment rotation and edge insertion strategies but with a focus on systematic segment manipulation and objective-aware edge selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = np.random.randint(3, min(10, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided edge swaps based on distance matrices\n    for _ in range(min(3, n//2)):\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            # Calculate potential improvement in both objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[i]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[i]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n            if delta1 + delta2 < 0:  # Accept if improves at least one objective\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7507400822451167,
            0.23773574829101562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = np.random.randint(3, min(10, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided edge swaps based on distance matrices\n    for _ in range(min(3, n//2)):\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            # Calculate potential improvement in both objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[i]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[i]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n            if delta1 + delta2 < 0:  # Accept if improves at least one objective\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection criterion that combines objective improvement potential and solution structure diversity, then applies a novel local search combining adaptive edge swapping, partial tour reversal, and probabilistic node relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.where((objectives[:, 0] <= objectives[:, 0].min()) & (objectives[:, 1] <= objectives[:, 1].min()))[0]\n    if len(pareto_front) > 0:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[:, i].max() - objectives[:, i].min() + 1e-10)\n        selected_idx = np.argmax(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge swapping, partial tour reversal, and node relocation\n    if n > 3:\n        # Step 1: Adaptive edge swapping (swap edges based on objective improvement)\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n        # Step 2: Partial tour reversal (reverse a segment with probability based on segment length)\n        if random.random() < 0.6:\n            segment_len = random.randint(2, min(4, n//3))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Probabilistic node relocation (move a node to a better position)\n        if random.random() < 0.8:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6703796108878323,
            0.5073434710502625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.where((objectives[:, 0] <= objectives[:, 0].min()) & (objectives[:, 1] <= objectives[:, 1].min()))[0]\n    if len(pareto_front) > 0:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[:, i].max() - objectives[:, i].min() + 1e-10)\n        selected_idx = np.argmax(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge swapping, partial tour reversal, and node relocation\n    if n > 3:\n        # Step 1: Adaptive edge swapping (swap edges based on objective improvement)\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n        # Step 2: Partial tour reversal (reverse a segment with probability based on segment length)\n        if random.random() < 0.6:\n            segment_len = random.randint(2, min(4, n//3))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Probabilistic node relocation (move a node to a better position)\n        if random.random() < 0.8:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion with adaptive segment length and distance-aware edge selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (std_obj + 1e-6) / np.sum(std_obj + 1e-6)\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Distance-aware edge insertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8752550002460702,
            0.2631550431251526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (std_obj + 1e-6) / np.sum(std_obj + 1e-6)\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Distance-aware edge insertion\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 3)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score function that prioritizes solutions with balanced improvement potential in both objectives, then applies a hybrid local search combining edge cross-exchange with adaptive segment reversal, while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (max(x[1][0], x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    if np.random.random() < 0.4:\n        m = np.random.randint(2, n//3)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8704258399073244,
            0.17972862720489502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (max(x[1][0], x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    if np.random.random() < 0.4:\n        m = np.random.randint(2, n//3)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects a solution from the archive with the best combined objective value, then applies a novel segment-based local search that combines random segment insertion and adaptive edge swapping to explore the solution space while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= i and insert_pos <= j:\n            insert_pos = (insert_pos + j - i) % n\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6205212661610149,
            0.07301974296569824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= i and insert_pos <= j:\n            insert_pos = (insert_pos + j - i) % n\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects a solution from the archive with the best combined objective value, then applies a novel segment-based local search that combines random segment insertion and adaptive edge swapping to explore the solution space while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= i and insert_pos <= j:\n            insert_pos = (insert_pos + j - i) % n\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6205212661610149,
            0.07301974296569824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= i and insert_pos <= j:\n            insert_pos = (insert_pos + j - i) % n\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective diversity criterion that balances Pareto dominance and structural uniqueness, then applies a novel local search combining alternating path reversal, dynamic segment rotation, and adaptive edge swapping to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid objective diversity selection\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Alternating path reversal and dynamic segment rotation\n    if n > 3:\n        # Step 1: Alternating path reversal\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n        # Step 2: Dynamic segment rotation\n        segment_len = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n        rotation = random.randint(1, segment_len-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 3: Adaptive edge swapping\n        if random.random() < 0.6:\n            i, j = random.sample(range(n), 2)\n            if abs(i-j) > 1 and abs(i-j) < n-1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9816586767862957,
            0.38610559701919556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid objective diversity selection\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Alternating path reversal and dynamic segment rotation\n    if n > 3:\n        # Step 1: Alternating path reversal\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n        # Step 2: Dynamic segment rotation\n        segment_len = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n        rotation = random.randint(1, segment_len-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 3: Adaptive edge swapping\n        if random.random() < 0.6:\n            i, j = random.sample(range(n), 2)\n            if abs(i-j) > 1 and abs(i-j) < n-1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and adaptive edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment to explore different configurations\n        segment = new_solution[i:j]\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Insert a random node at a new position to diversify the solution\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8721369459852448,
            0.274074912071228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and adaptive edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment to explore different configurations\n        segment = new_solution[i:j]\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Insert a random node at a new position to diversify the solution\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel combination of node swapping and segment inversion with adaptive segment length to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    weighted_scores = [w * (obj[0] + obj[1]) for (_, obj), w in zip(archive, weights)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment length based on solution quality\n    base_obj = archive[selected_idx][1]\n    segment_length = max(2, min(n//2, int(n * (1 - (base_obj[0] + base_obj[1]) / (sum(obj[0] + obj[1] for _, obj in archive))))))\n\n    # Hybrid local search: node swapping with segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > segment_length:\n        # Invert middle segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Swap nodes with probability based on their distance improvement potential\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n        if a != b:\n            # Calculate potential improvement in both objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]) + \\\n                    (distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] -\n                     distance_matrix_1[new_solution[b-1], new_solution[b]] -\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]) + \\\n                    (distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] -\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] -\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            if (delta1 < 0 and delta2 < 0) or np.random.random() < 0.2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8128857148795903,
            0.31109142303466797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    weighted_scores = [w * (obj[0] + obj[1]) for (_, obj), w in zip(archive, weights)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment length based on solution quality\n    base_obj = archive[selected_idx][1]\n    segment_length = max(2, min(n//2, int(n * (1 - (base_obj[0] + base_obj[1]) / (sum(obj[0] + obj[1] for _, obj in archive))))))\n\n    # Hybrid local search: node swapping with segment inversion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > segment_length:\n        # Invert middle segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Swap nodes with probability based on their distance improvement potential\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n        if a != b:\n            # Calculate potential improvement in both objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]) + \\\n                    (distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] -\n                     distance_matrix_1[new_solution[b-1], new_solution[b]] -\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]) + \\\n                    (distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] -\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] -\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            if (delta1 < 0 and delta2 < 0) or np.random.random() < 0.2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{The new algorithm combines selection based on objective-weighted scores with a hybrid local search that intelligently rotates segments of the tour, performs edge swaps, and selectively applies insertion moves to explore the solution space more thoroughly while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8724756521473179,
            0.21741819381713867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a diverse solution from the archive based on both objective values and solution structure, then applies a novel adaptive local search combining segment rotation, node swapping, and dynamic path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and solution structure\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search: segment rotation, node swapping, and dynamic path inversion\n    if n > 3:\n        # Step 1: Segment rotation (rotate a segment by a random amount)\n        segment_len = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_len)\n        rotation = random.randint(1, segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Node swapping (swap two nodes with probability based on their positions)\n        if random.random() < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j and abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Dynamic path inversion (invert a path segment with adaptive length)\n        if random.random() < 0.4:\n            max_len = min(6, n//2)\n            inv_len = random.randint(2, max_len)\n            inv_start = random.randint(0, n - inv_len)\n            new_solution[inv_start:inv_start+inv_len] = new_solution[inv_start:inv_start+inv_len][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9148550508062685,
            0.33732104301452637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and solution structure\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search: segment rotation, node swapping, and dynamic path inversion\n    if n > 3:\n        # Step 1: Segment rotation (rotate a segment by a random amount)\n        segment_len = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_len)\n        rotation = random.randint(1, segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Node swapping (swap two nodes with probability based on their positions)\n        if random.random() < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j and abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Dynamic path inversion (invert a path segment with adaptive length)\n        if random.random() < 0.4:\n            max_len = min(6, n//2)\n            inv_len = random.randint(2, max_len)\n            inv_start = random.randint(0, n - inv_len)\n            new_solution[inv_start:inv_start+inv_len] = new_solution[inv_start:inv_start+inv_len][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to rotate\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end+1] = rotated_segment\n\n    # Randomly select a node to insert elsewhere\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = [obj[0] + obj[1] for _, obj in archive]\n    normalized_distances = np.array(crowding_distances) / np.sum(crowding_distances)\n    selected_idx = np.random.choice(len(archive), p=normalized_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to move to a different position\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two non-adjacent edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8855623112504101,
            0.2971792221069336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = [obj[0] + obj[1] for _, obj in archive]\n    normalized_distances = np.array(crowding_distances) / np.sum(crowding_distances)\n    selected_idx = np.random.choice(len(archive), p=normalized_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a novel local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to move to a different position\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly swap two non-adjacent edges if they exist\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9904990657529205,
            0.25266849994659424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware selection, then applies a hybrid local search combining node swapping and partial route reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform partial route reversal\n    if n > 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + n // 2, n - 1))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9153814153737603,
            0.2800784111022949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform partial route reversal\n    if n > 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + n // 2, n - 1))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and node insertion with adaptive selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment of the tour with adaptive segment selection\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n    # Insert a randomly selected node at a new position to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8782826003193118,
            0.2355138063430786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and node insertion with adaptive selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment of the tour with adaptive segment selection\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n    # Insert a randomly selected node at a new position to explore different paths\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes solutions with better objective values, then applies a novel local search combining adaptive node insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with better objective values\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate dominance count for each solution\n        dominance = np.zeros(len(objectives))\n        for i in range(len(objectives)):\n            for j in range(len(objectives)):\n                if i != j and all(objectives[i] <= objectives[j]):\n                    dominance[i] += 1\n\n        # Select solution with minimum dominance count\n        selected_idx = np.argmin(dominance)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive node insertion and segment rotation\n    if n > 3:\n        # Step 1: Adaptive node insertion (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n        # Step 2: Segment rotation (rotate a segment of the tour)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation_amount = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation_amount)\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9643229989897681,
            14.135311484336853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with better objective values\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate dominance count for each solution\n        dominance = np.zeros(len(objectives))\n        for i in range(len(objectives)):\n            for j in range(len(objectives)):\n                if i != j and all(objectives[i] <= objectives[j]):\n                    dominance[i] += 1\n\n        # Select solution with minimum dominance count\n        selected_idx = np.argmin(dominance)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive node insertion and segment rotation\n    if n > 3:\n        # Step 1: Adaptive node insertion (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n        # Step 2: Segment rotation (rotate a segment of the tour)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation_amount = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation_amount)\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective-diversity metric that combines Pareto dominance and structural diversity, then applies a novel local search combining multi-segment crossover, adaptive edge rotation, and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto front, select based on diversity\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_dist = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_dist += np.linalg.norm(objectives[i] - objectives[j])\n            diversity_scores.append(total_dist)\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment selection\n    if n > 5:\n        num_segments = random.randint(2, min(4, n//3))\n        segment_points = sorted(random.sample(range(1, n), num_segments-1))\n        segments = []\n        start = 0\n        for point in segment_points:\n            segments.append(new_solution[start:point])\n            start = point\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge rotation\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        rotated = np.roll(new_solution[start:start+k], random.randint(1, k-1))\n        new_solution[start:start+k] = rotated\n\n    # Probabilistic node swapping based on distance\n    if n > 2:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i, j = random.sample(range(n), 2)\n            prob = 0.5 * (1 - min(distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]],\n                                  distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]]) /\n                        (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] + 1e-10))\n            if random.random() < prob:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective improvement potential metric that combines objective value improvements and structural diversity, then applies a novel local search combining adaptive node clustering, probabilistic segment insertion, and multi-dimensional edge optimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_scores = []\n    for i, obj in enumerate(objectives):\n        improvement = 0\n        for j, other_obj in enumerate(objectives):\n            if i != j:\n                improvement += (obj[0] - other_obj[0]) + (obj[1] - other_obj[1])\n        diversity = np.sum(np.linalg.norm(objectives[i] - objectives, axis=1))\n        improvement_scores.append(improvement + 0.1 * diversity)\n\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering\n    if n > 5:\n        cluster_size = random.randint(2, min(5, n//3))\n        cluster_start = random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Probabilistic segment insertion\n        insert_pos = random.randint(0, n - cluster_size)\n        new_solution = np.concatenate([new_solution[:insert_pos], cluster, new_solution[insert_pos+cluster_size:]])\n\n    # Multi-dimensional edge optimization\n    if n > 3:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate improvement in both objectives\n                old_cost = (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]])\n                if new_cost < old_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9267927564349275,
            9.450539946556091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_scores = []\n    for i, obj in enumerate(objectives):\n        improvement = 0\n        for j, other_obj in enumerate(objectives):\n            if i != j:\n                improvement += (obj[0] - other_obj[0]) + (obj[1] - other_obj[1])\n        diversity = np.sum(np.linalg.norm(objectives[i] - objectives, axis=1))\n        improvement_scores.append(improvement + 0.1 * diversity)\n\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering\n    if n > 5:\n        cluster_size = random.randint(2, min(5, n//3))\n        cluster_start = random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Probabilistic segment insertion\n        insert_pos = random.randint(0, n - cluster_size)\n        new_solution = np.concatenate([new_solution[:insert_pos], cluster, new_solution[insert_pos+cluster_size:]])\n\n    # Multi-dimensional edge optimization\n    if n > 3:\n        for _ in range(random.randint(1, min(3, n//4))):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate improvement in both objectives\n                old_cost = (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[(i+1)%n]])\n                if new_cost < old_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and structural diversity, then applies a hybrid local search combining segment insertion with adaptive node selection and edge reversal with adaptive segment length, ensuring feasibility by validating the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high structural diversity\n    base_solution = archive[0][0].copy()\n    if len(archive) > 1:\n        # Calculate structural diversity based on node positions\n        diversity_scores = []\n        for sol, _ in archive:\n            diff = np.abs(sol - base_solution)\n            diversity = np.sum(diff) / len(sol)\n            diversity_scores.append(diversity)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment insertion with adaptive node selection\n    if n > 3:\n        # Select a segment to insert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Select nodes to insert from other solutions\n        if len(archive) > 1:\n            other_solutions = [sol for sol, _ in archive if not np.array_equal(sol, base_solution)]\n            if other_solutions:\n                other_sol = random.choice(other_solutions)\n                nodes_to_insert = [node for node in other_sol if node not in new_solution]\n                if nodes_to_insert:\n                    node = random.choice(nodes_to_insert)\n                    pos = random.randint(0, n-1)\n                    new_solution = np.insert(new_solution, pos, node)\n                    new_solution = new_solution[:n]  # Ensure length remains the same\n\n        # Adaptive edge reversal\n        c, d = sorted(random.sample(range(n), 2))\n        if d - c > 1:\n            segment = new_solution[c:d]\n            reversed_segment = segment[::-1]\n            original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n            reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n            if reversed_cost < original_cost:\n                new_solution[c:d] = reversed_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9532360909448212,
            1.0306081771850586
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high structural diversity\n    base_solution = archive[0][0].copy()\n    if len(archive) > 1:\n        # Calculate structural diversity based on node positions\n        diversity_scores = []\n        for sol, _ in archive:\n            diff = np.abs(sol - base_solution)\n            diversity = np.sum(diff) / len(sol)\n            diversity_scores.append(diversity)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment insertion with adaptive node selection\n    if n > 3:\n        # Select a segment to insert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Select nodes to insert from other solutions\n        if len(archive) > 1:\n            other_solutions = [sol for sol, _ in archive if not np.array_equal(sol, base_solution)]\n            if other_solutions:\n                other_sol = random.choice(other_solutions)\n                nodes_to_insert = [node for node in other_sol if node not in new_solution]\n                if nodes_to_insert:\n                    node = random.choice(nodes_to_insert)\n                    pos = random.randint(0, n-1)\n                    new_solution = np.insert(new_solution, pos, node)\n                    new_solution = new_solution[:n]  # Ensure length remains the same\n\n        # Adaptive edge reversal\n        c, d = sorted(random.sample(range(n), 2))\n        if d - c > 1:\n            segment = new_solution[c:d]\n            reversed_segment = segment[::-1]\n            original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n            reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n            if reversed_cost < original_cost:\n                new_solution[c:d] = reversed_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{A novel local search algorithm that combines adaptive segment reversal with objective-aware edge insertion, prioritizing solutions with balanced improvement potential in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.mean(axis=1)\n    selected_idx = np.argmin(scores)  # Select most balanced solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = max(3, min(10, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Objective-aware edge insertion\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 > obj2:\n        # More improvement potential in first objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # More improvement potential in second objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7588650019175549,
            0.3256117105484009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.mean(axis=1)\n    selected_idx = np.argmin(scores)  # Select most balanced solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = max(3, min(10, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Objective-aware edge insertion\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 > obj2:\n        # More improvement potential in first objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # More improvement potential in second objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective and structural diversity measure, then applies a novel hybrid local search combining adaptive segment rotation, dynamic node swapping, and objective-aware edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Calculate selection probabilities\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, dynamic node swapping, and objective-aware edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        k = random.randint(1, segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Dynamic node swapping\n        if random.random() < 0.6:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Objective-aware edge insertion\n        if random.random() < 0.8:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate potential improvement\n                node = new_solution[j]\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n                # Evaluate in both objective spaces\n                current_cost = (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node])\n                new_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n                if new_cost < current_cost:\n                    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8905663364742888,
            0.2715955376625061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Calculate selection probabilities\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, dynamic node swapping, and objective-aware edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        segment_len = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_len)\n        k = random.randint(1, segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[start:start+segment_len] = rotated_segment\n\n        # Step 2: Dynamic node swapping\n        if random.random() < 0.6:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Objective-aware edge insertion\n        if random.random() < 0.8:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate potential improvement\n                node = new_solution[j]\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n                # Evaluate in both objective spaces\n                current_cost = (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node])\n                new_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n                if new_cost < current_cost:\n                    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining adaptive edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(obj[0] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    selected = max(archive, key=lambda x: (0.7 * (x[1][0] - min_obj1) / (max_obj1 - min_obj1 + 1e-8) +\n                                          0.3 * (x[1][1] - min_obj2) / (max_obj2 - min_obj2 + 1e-8)))\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge swaps combined with segment reversals\n    for _ in range(2):\n        # Adaptive edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost change\n        cost_change1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]])\n\n        cost_change2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        if cost_change1 < 0 or cost_change2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal with adaptive length\n    segment_length = min(5, max(2, np.random.randint(n//4, n//2)))\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8848688703374787,
            0.328729510307312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(obj[0] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    selected = max(archive, key=lambda x: (0.7 * (x[1][0] - min_obj1) / (max_obj1 - min_obj1 + 1e-8) +\n                                          0.3 * (x[1][1] - min_obj2) / (max_obj2 - min_obj2 + 1e-8)))\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge swaps combined with segment reversals\n    for _ in range(2):\n        # Adaptive edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost change\n        cost_change1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]])\n\n        cost_change2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        if cost_change1 < 0 or cost_change2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal with adaptive length\n    segment_length = min(5, max(2, np.random.randint(n//4, n//2)))\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This algorithm combines adaptive segment selection based on objective improvement potential with a novel path-smoothing operator that optimizes the tour by iteratively realigning nodes to minimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with the best combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvements = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        n = len(sol)\n        if n > 3:\n            # Calculate improvement potential by evaluating random segment reversals\n            a, b = sorted(random.sample(range(n), 2))\n            segment = sol[a:b+1]\n            reversed_segment = segment[::-1]\n            original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n            reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n            improvements[i] = original_cost - reversed_cost\n\n    selected_idx = np.argmax(improvements) if len(improvements) > 0 else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: path smoothing with objective-aware node realignment\n    if n > 3:\n        # Select a segment to realign based on objective improvement\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        original_cost += sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Try different orderings of the segment\n        best_order = segment.copy()\n        best_cost = original_cost\n        for _ in range(3):  # Try 3 random permutations\n            permuted = segment.copy()\n            np.random.shuffle(permuted)\n            permuted_cost = sum(distance_matrix_1[permuted[i], permuted[i+1]] for i in range(len(permuted)-1)) + distance_matrix_1[permuted[-1], permuted[0]]\n            permuted_cost += sum(distance_matrix_2[permuted[i], permuted[i+1]] for i in range(len(permuted)-1)) + distance_matrix_2[permuted[-1], permuted[0]]\n            if permuted_cost < best_cost:\n                best_order = permuted.copy()\n                best_cost = permuted_cost\n\n        new_solution[a:b+1] = best_order\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8784054356768393,
            1.6932655572891235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with the best combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvements = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        n = len(sol)\n        if n > 3:\n            # Calculate improvement potential by evaluating random segment reversals\n            a, b = sorted(random.sample(range(n), 2))\n            segment = sol[a:b+1]\n            reversed_segment = segment[::-1]\n            original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n            reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n            improvements[i] = original_cost - reversed_cost\n\n    selected_idx = np.argmax(improvements) if len(improvements) > 0 else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: path smoothing with objective-aware node realignment\n    if n > 3:\n        # Select a segment to realign based on objective improvement\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        original_cost += sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Try different orderings of the segment\n        best_order = segment.copy()\n        best_cost = original_cost\n        for _ in range(3):  # Try 3 random permutations\n            permuted = segment.copy()\n            np.random.shuffle(permuted)\n            permuted_cost = sum(distance_matrix_1[permuted[i], permuted[i+1]] for i in range(len(permuted)-1)) + distance_matrix_1[permuted[-1], permuted[0]]\n            permuted_cost += sum(distance_matrix_2[permuted[i], permuted[i+1]] for i in range(len(permuted)-1)) + distance_matrix_2[permuted[-1], permuted[0]]\n            if permuted_cost < best_cost:\n                best_order = permuted.copy()\n                best_cost = permuted_cost\n\n        new_solution[a:b+1] = best_order\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines node insertion, segment reversal, and adaptive segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good objective values or diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: node insertion with segment reversal and adaptive segment swapping\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        insert_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment\n        i, j = np.random.randint(0, n - 1, size=2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Adaptive segment swapping\n        if n > 5:\n            seg_length = np.random.randint(2, min(5, n // 2))\n            i = np.random.randint(0, n - seg_length)\n            j = np.random.randint(i + seg_length, n)\n            if j - i >= seg_length:\n                segment1 = new_solution[i:i + seg_length]\n                segment2 = new_solution[j:j + seg_length]\n                new_solution = np.concatenate([new_solution[:i], segment2, new_solution[i + seg_length:j], segment1, new_solution[j + seg_length:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9053318487699455,
            0.29087305068969727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good objective values or diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: node insertion with segment reversal and adaptive segment swapping\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        insert_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment\n        i, j = np.random.randint(0, n - 1, size=2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Adaptive segment swapping\n        if n > 5:\n            seg_length = np.random.randint(2, min(5, n // 2))\n            i = np.random.randint(0, n - seg_length)\n            j = np.random.randint(i + seg_length, n)\n            if j - i >= seg_length:\n                segment1 = new_solution[i:i + seg_length]\n                segment2 = new_solution[j:j + seg_length]\n                new_solution = np.concatenate([new_solution[:i], segment2, new_solution[i + seg_length:j], segment1, new_solution[j + seg_length:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with the best combined objective value, then applies a novel segment-based local search that combines random segment insertion and adaptive edge swapping to explore the solution space while ensuring feasibility through validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= i and insert_pos <= j:\n            insert_pos = (insert_pos + j - i) % n\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive with the best individual objective value in the first space, then applies a hybrid local search combining random node swaps and biased edge reversals to generate a neighbor solution while maintaining feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: x[1][0])\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random node swaps\n    for _ in range(3):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Biased edge reversals\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, i + 3) % n\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.907166902030291,
            0.256436824798584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: x[1][0])\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random node swaps\n    for _ in range(3):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Biased edge reversals\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, i + 3) % n\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with the best combined objective value, then applies a novel segment-based local search that combines random segment insertion and adaptive edge swapping to explore the solution space while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= i and insert_pos <= j:\n            insert_pos = (insert_pos + j - i) % n\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This algorithm first selects a solution from the archive using a hybrid selection criterion that combines objective dominance and diversity, then applies a novel edge-swapping and segment-rotation hybrid local search that dynamically adapts the search depth based on the solution's proximity to the Pareto front, while ensuring feasibility through comprehensive validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate dominance ranks and crowding distances\n        dominance = np.zeros(len(objectives))\n        crowding = np.zeros(len(objectives))\n\n        # Dominance calculation (simplified)\n        for i in range(len(objectives)):\n            for j in range(len(objectives)):\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    dominance[i] += 1\n\n        # Crowding distance calculation\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Combine criteria (inverse dominance for minimization)\n        combined = -dominance + crowding\n        selected_idx = np.argmin(combined)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge-swapping and segment-rotation hybrid local search\n    if n > 3:\n        # Determine search depth based on solution's proximity to Pareto front\n        search_depth = max(2, int(np.sqrt(n)) if selected_idx == 0 else min(3, n//4))\n\n        for _ in range(search_depth):\n            # Random segment selection\n            a, b = sorted(random.sample(range(n), 2))\n            segment_length = min(b - a, n//3)\n\n            if segment_length > 1:\n                # Rotate segment\n                rotation = random.randint(1, segment_length-1)\n                segment = new_solution[a:b]\n                rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n                new_solution[a:b] = rotated_segment\n\n                # Edge-swapping within segment\n                swap_positions = random.sample(range(segment_length), 2)\n                segment[swap_positions[0]], segment[swap_positions[1]] = segment[swap_positions[1]], segment[swap_positions[0]]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7837732263888764,
            0.5167772769927979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate dominance ranks and crowding distances\n        dominance = np.zeros(len(objectives))\n        crowding = np.zeros(len(objectives))\n\n        # Dominance calculation (simplified)\n        for i in range(len(objectives)):\n            for j in range(len(objectives)):\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    dominance[i] += 1\n\n        # Crowding distance calculation\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Combine criteria (inverse dominance for minimization)\n        combined = -dominance + crowding\n        selected_idx = np.argmin(combined)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge-swapping and segment-rotation hybrid local search\n    if n > 3:\n        # Determine search depth based on solution's proximity to Pareto front\n        search_depth = max(2, int(np.sqrt(n)) if selected_idx == 0 else min(3, n//4))\n\n        for _ in range(search_depth):\n            # Random segment selection\n            a, b = sorted(random.sample(range(n), 2))\n            segment_length = min(b - a, n//3)\n\n            if segment_length > 1:\n                # Rotate segment\n                rotation = random.randint(1, segment_length-1)\n                segment = new_solution[a:b]\n                rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n                new_solution[a:b] = rotated_segment\n\n                # Edge-swapping within segment\n                swap_positions = random.sample(range(segment_length), 2)\n                segment[swap_positions[0]], segment[swap_positions[1]] = segment[swap_positions[1]], segment[swap_positions[0]]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based selection that prioritizes non-dominated solutions, then applies a hybrid local search combining segment reversal and node exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(objectives), dtype=bool)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(objectives)) if not is_dominated[i]]\n    if non_dominated_indices:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = random.choice(range(len(objectives)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and node exchange\n    if n > 3:\n        # Step 1: Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Node exchange\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8848673499869578,
            0.4619872570037842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(objectives), dtype=bool)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(objectives)) if not is_dominated[i]]\n    if non_dominated_indices:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = random.choice(range(len(objectives)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and node exchange\n    if n > 3:\n        # Step 1: Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Node exchange\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel diversity-aware selection that prioritizes solutions with unique edge patterns, then applies a hybrid local search combining adaptive node clustering and guided edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique edge patterns\n    edge_patterns = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        edge_patterns.append(len(pattern))\n\n    selected_idx = np.argmax(edge_patterns)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and guided edge swapping\n    if n > 3:\n        # Step 1: Adaptive node clustering (group nodes based on coordinate similarity)\n        clusters = []\n        current_cluster = [new_solution[0]]\n        for i in range(1, n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            prev_coords = instance[prev_node]\n            curr_coords = instance[curr_node]\n\n            # Check if nodes are close in both objective spaces\n            dist1 = np.sqrt((prev_coords[0] - curr_coords[0])**2 + (prev_coords[1] - curr_coords[1])**2)\n            dist2 = np.sqrt((prev_coords[2] - curr_coords[2])**2 + (prev_coords[3] - curr_coords[3])**2)\n            if (dist1 < np.mean(distance_matrix_1) * 0.3 and dist2 < np.mean(distance_matrix_2) * 0.3):\n                current_cluster.append(curr_node)\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [curr_node]\n        clusters.append(current_cluster)\n\n        # Step 2: Guided edge swapping (swap edges between different clusters)\n        if len(clusters) > 1:\n            cluster1, cluster2 = random.sample(clusters, 2)\n            if len(cluster1) > 1 and len(cluster2) > 1:\n                node1 = random.choice(cluster1)\n                node2 = random.choice(cluster2)\n                idx1 = np.where(new_solution == node1)[0][0]\n                idx2 = np.where(new_solution == node2)[0][0]\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9920973733187156,
            1.8318009972572327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique edge patterns\n    edge_patterns = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        edge_patterns.append(len(pattern))\n\n    selected_idx = np.argmax(edge_patterns)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and guided edge swapping\n    if n > 3:\n        # Step 1: Adaptive node clustering (group nodes based on coordinate similarity)\n        clusters = []\n        current_cluster = [new_solution[0]]\n        for i in range(1, n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            prev_coords = instance[prev_node]\n            curr_coords = instance[curr_node]\n\n            # Check if nodes are close in both objective spaces\n            dist1 = np.sqrt((prev_coords[0] - curr_coords[0])**2 + (prev_coords[1] - curr_coords[1])**2)\n            dist2 = np.sqrt((prev_coords[2] - curr_coords[2])**2 + (prev_coords[3] - curr_coords[3])**2)\n            if (dist1 < np.mean(distance_matrix_1) * 0.3 and dist2 < np.mean(distance_matrix_2) * 0.3):\n                current_cluster.append(curr_node)\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [curr_node]\n        clusters.append(current_cluster)\n\n        # Step 2: Guided edge swapping (swap edges between different clusters)\n        if len(clusters) > 1:\n            cluster1, cluster2 = random.sample(clusters, 2)\n            if len(cluster1) > 1 and len(cluster2) > 1:\n                node1 = random.choice(cluster1)\n                node2 = random.choice(cluster2)\n                idx1 = np.where(new_solution == node1)[0][0]\n                idx2 = np.where(new_solution == node2)[0][0]\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with the best combined objective value, then applies a novel segment-based local search that combines random segment insertion and adaptive edge swapping to explore the solution space while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= i and insert_pos <= j:\n            insert_pos = (insert_pos + j - i) % n\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective dominance-aware criterion, then applies a novel hybrid local search combining adaptive segment reshuffling, multi-dimensional edge optimization, and probabilistic node swapping to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective dominance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                dominated[i] = True\n                break\n    non_dominated = np.where(~dominated)[0]\n    if len(non_dominated) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(non_dominated)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reshuffling\n    segment_size = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n    np.random.shuffle(segment)\n    new_solution[start:start+segment_size] = segment\n\n    # Multi-dimensional edge optimization\n    for _ in range(3):\n        a = np.random.randint(0, n)\n        b = (a + np.random.randint(1, n)) % n\n        if a != b:\n            cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]])\n            cost_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n            if cost_after < cost_before:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Probabilistic node swapping\n    for i in range(n):\n        if np.random.random() < 0.3:\n            j = np.random.randint(0, n)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8159408036187892,
            0.406360924243927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective dominance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                dominated[i] = True\n                break\n    non_dominated = np.where(~dominated)[0]\n    if len(non_dominated) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(non_dominated)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reshuffling\n    segment_size = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n    np.random.shuffle(segment)\n    new_solution[start:start+segment_size] = segment\n\n    # Multi-dimensional edge optimization\n    for _ in range(3):\n        a = np.random.randint(0, n)\n        b = (a + np.random.randint(1, n)) % n\n        if a != b:\n            cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]])\n            cost_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n            if cost_after < cost_before:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Probabilistic node swapping\n    for i in range(n):\n        if np.random.random() < 0.3:\n            j = np.random.randint(0, n)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.913221903405332,
            0.14089322090148926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This algorithm selects the solution with the highest sum of objectives from the archive, performs a segment inversion between two random points, and applies a random edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8616305480619794,
            0.22687172889709473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment rotation, edge reversal, and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate segment by random amount\n        rotation = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Reverse a random edge\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8008751491873772,
            0.25346338748931885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate segment by random amount\n        rotation = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Reverse a random edge\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9186776753804139,
            0.12852120399475098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6731221897932584,
            0.050269901752471924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6731221897932584,
            0.050269901752471924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment selection and hybrid insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j:]])\n\n    # Objective-aware edge reversal\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        cost_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        cost_after = distance_matrix_1[new_solution[k-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[l]]\n        if cost_after < cost_before:\n            new_solution[k:l] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7640730319219984,
            0.535698652267456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment selection and hybrid insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j:]])\n\n    # Objective-aware edge reversal\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        cost_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        cost_after = distance_matrix_1[new_solution[k-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[l]]\n        if cost_after < cost_before:\n            new_solution[k:l] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that considers both objective values and structural differences, then applies a novel hybrid local search combining edge reversal, segment inversion, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection based on objective values and structural differences\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Combine objective and diversity scores\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment inversion, and adaptive node insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment inversion (invert a random segment with probability based on its length)\n        if random.random() < 0.5:\n            segment_len = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_len)\n            new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n        # Step 3: Adaptive node insertion (insert a node from another part of the tour)\n        if random.random() < 0.7:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that balances objective values, diversity, and local improvement potential, then applies a novel local search combining adaptive edge reversal, segment rotation, and probabilistic node relocation to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion combining objective values, diversity, and improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Calculate improvement potential based on distance matrices\n    improvement_potential = []\n    for sol, _ in archive:\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        improvement_potential.append((cost1 + cost2) / len(sol))\n\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)) * (1 / (np.array(improvement_potential) + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal, segment rotation, and probabilistic node relocation\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse segments based on distance savings)\n        a, b = sorted(random.sample(range(n), 2))\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b))\n        reversed_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] for i in range(b-1, a-1, -1))\n        if reversed_cost1 < segment_cost1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment rotation (rotate a segment with probability based on cost improvement)\n        if random.random() < 0.6:\n            segment_len = random.randint(2, min(4, n//2))\n            start = random.randint(0, n - segment_len)\n            segment = new_solution[start:start+segment_len]\n            rotated = np.roll(segment, 1)\n            original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_len]] for i in range(segment_len))\n            rotated_cost = sum(distance_matrix_1[rotated[i], rotated[(i+1)%segment_len]] for i in range(segment_len))\n            if rotated_cost < original_cost:\n                new_solution[start:start+segment_len] = rotated\n\n        # Step 3: Probabilistic node relocation (move nodes with high relocation potential)\n        if random.random() < 0.8:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i-1], node] +\n                           distance_matrix_1[node, new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], node] +\n                           distance_matrix_2[node, new_solution[(i+1)%n]])\n                if new_cost < original_cost:\n                    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7677567384568771,
            2.8130459785461426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion combining objective values, diversity, and improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n\n    # Calculate improvement potential based on distance matrices\n    improvement_potential = []\n    for sol, _ in archive:\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        improvement_potential.append((cost1 + cost2) / len(sol))\n\n    selection_weights = diversity_scores * (1 / (objectives[:, 0] + objectives[:, 1] + 1e-10)) * (1 / (np.array(improvement_potential) + 1e-10))\n    selection_probs = selection_weights / np.sum(selection_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal, segment rotation, and probabilistic node relocation\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse segments based on distance savings)\n        a, b = sorted(random.sample(range(n), 2))\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b))\n        reversed_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] for i in range(b-1, a-1, -1))\n        if reversed_cost1 < segment_cost1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment rotation (rotate a segment with probability based on cost improvement)\n        if random.random() < 0.6:\n            segment_len = random.randint(2, min(4, n//2))\n            start = random.randint(0, n - segment_len)\n            segment = new_solution[start:start+segment_len]\n            rotated = np.roll(segment, 1)\n            original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_len]] for i in range(segment_len))\n            rotated_cost = sum(distance_matrix_1[rotated[i], rotated[(i+1)%segment_len]] for i in range(segment_len))\n            if rotated_cost < original_cost:\n                new_solution[start:start+segment_len] = rotated\n\n        # Step 3: Probabilistic node relocation (move nodes with high relocation potential)\n        if random.random() < 0.8:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i-1], node] +\n                           distance_matrix_1[node, new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], node] +\n                           distance_matrix_2[node, new_solution[(i+1)%n]])\n                if new_cost < original_cost:\n                    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel diversity-aware selection that prioritizes solutions with unique edge patterns, then applies a hybrid local search combining adaptive node clustering and guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique edge patterns\n    edge_patterns = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        edge_patterns.append(len(pattern))\n\n    selected_idx = np.argmax(edge_patterns)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and guided edge swapping\n    if n > 3:\n        # Step 1: Adaptive node clustering (group nodes based on coordinate similarity)\n        clusters = []\n        current_cluster = [new_solution[0]]\n        for i in range(1, n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            prev_coords = instance[prev_node]\n            curr_coords = instance[curr_node]\n\n            # Check if nodes are close in both objective spaces\n            dist1 = np.sqrt((prev_coords[0] - curr_coords[0])**2 + (prev_coords[1] - curr_coords[1])**2)\n            dist2 = np.sqrt((prev_coords[2] - curr_coords[2])**2 + (prev_coords[3] - curr_coords[3])**2)\n            if (dist1 < np.mean(distance_matrix_1) * 0.3 and dist2 < np.mean(distance_matrix_2) * 0.3):\n                current_cluster.append(curr_node)\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [curr_node]\n        clusters.append(current_cluster)\n\n        # Step 2: Guided edge swapping (swap edges between different clusters)\n        if len(clusters) > 1:\n            cluster1, cluster2 = random.sample(clusters, 2)\n            if len(cluster1) > 1 and len(cluster2) > 1:\n                node1 = random.choice(cluster1)\n                node2 = random.choice(cluster2)\n                idx1 = np.where(new_solution == node1)[0][0]\n                idx2 = np.where(new_solution == node2)[0][0]\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective-balanced selection that prioritizes solutions with diverse objective trade-offs, then applies a hybrid local search combining adaptive segment rearrangement and guided node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with diverse objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives / objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rearrangement and guided node reinsertion\n    if n > 3:\n        # Step 1: Select a segment to rearrange\n        seg_start = np.random.randint(0, n-2)\n        seg_length = np.random.randint(2, min(5, n-seg_start))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Step 2: Adaptive rearrangement based on objective space distances\n        if np.random.random() < 0.5:\n            # Reverse the segment if it improves both objectives\n            reversed_segment = segment[::-1]\n            old_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n            new_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n            if new_cost < old_cost:\n                segment = reversed_segment\n        else:\n            # Rotate the segment if it improves the objectives\n            rotation = np.random.randint(1, len(segment))\n            rotated_segment = np.roll(segment, rotation)\n            old_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n            new_cost = distance_matrix_1[rotated_segment[-1], rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], rotated_segment[0]]\n            if new_cost < old_cost:\n                segment = rotated_segment\n\n        # Step 3: Guided node reinsertion\n        for node in segment:\n            # Find the best insertion position that minimizes both objectives\n            best_pos = seg_start\n            best_cost = float('inf')\n            for pos in range(seg_start, seg_start+seg_length):\n                if pos == 0:\n                    cost = distance_matrix_1[new_solution[-1], node] + distance_matrix_2[new_solution[-1], node] + \\\n                           distance_matrix_1[node, new_solution[1]] + distance_matrix_2[node, new_solution[1]]\n                elif pos == n-1:\n                    cost = distance_matrix_1[new_solution[-2], node] + distance_matrix_2[new_solution[-2], node] + \\\n                           distance_matrix_1[node, new_solution[0]] + distance_matrix_2[node, new_solution[0]]\n                else:\n                    cost = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_2[new_solution[pos-1], node] + \\\n                           distance_matrix_1[node, new_solution[pos+1]] + distance_matrix_2[node, new_solution[pos+1]]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Remove the node and insert it at the best position\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9460809393227755,
            0.3060966730117798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with diverse objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives / objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rearrangement and guided node reinsertion\n    if n > 3:\n        # Step 1: Select a segment to rearrange\n        seg_start = np.random.randint(0, n-2)\n        seg_length = np.random.randint(2, min(5, n-seg_start))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Step 2: Adaptive rearrangement based on objective space distances\n        if np.random.random() < 0.5:\n            # Reverse the segment if it improves both objectives\n            reversed_segment = segment[::-1]\n            old_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n            new_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n            if new_cost < old_cost:\n                segment = reversed_segment\n        else:\n            # Rotate the segment if it improves the objectives\n            rotation = np.random.randint(1, len(segment))\n            rotated_segment = np.roll(segment, rotation)\n            old_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n            new_cost = distance_matrix_1[rotated_segment[-1], rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], rotated_segment[0]]\n            if new_cost < old_cost:\n                segment = rotated_segment\n\n        # Step 3: Guided node reinsertion\n        for node in segment:\n            # Find the best insertion position that minimizes both objectives\n            best_pos = seg_start\n            best_cost = float('inf')\n            for pos in range(seg_start, seg_start+seg_length):\n                if pos == 0:\n                    cost = distance_matrix_1[new_solution[-1], node] + distance_matrix_2[new_solution[-1], node] + \\\n                           distance_matrix_1[node, new_solution[1]] + distance_matrix_2[node, new_solution[1]]\n                elif pos == n-1:\n                    cost = distance_matrix_1[new_solution[-2], node] + distance_matrix_2[new_solution[-2], node] + \\\n                           distance_matrix_1[node, new_solution[0]] + distance_matrix_2[node, new_solution[0]]\n                else:\n                    cost = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_2[new_solution[pos-1], node] + \\\n                           distance_matrix_1[node, new_solution[pos+1]] + distance_matrix_2[node, new_solution[pos+1]]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Remove the node and insert it at the best position\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel diversity-aware selection that prioritizes solutions with unique edge patterns, then applies a hybrid local search combining adaptive node clustering and guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique edge patterns\n    edge_patterns = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        edge_patterns.append(len(pattern))\n\n    selected_idx = np.argmax(edge_patterns)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and guided edge swapping\n    if n > 3:\n        # Step 1: Adaptive node clustering (group nodes based on coordinate similarity)\n        clusters = []\n        current_cluster = [new_solution[0]]\n        for i in range(1, n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            prev_coords = instance[prev_node]\n            curr_coords = instance[curr_node]\n\n            # Check if nodes are close in both objective spaces\n            dist1 = np.sqrt((prev_coords[0] - curr_coords[0])**2 + (prev_coords[1] - curr_coords[1])**2)\n            dist2 = np.sqrt((prev_coords[2] - curr_coords[2])**2 + (prev_coords[3] - curr_coords[3])**2)\n            if (dist1 < np.mean(distance_matrix_1) * 0.3 and dist2 < np.mean(distance_matrix_2) * 0.3):\n                current_cluster.append(curr_node)\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [curr_node]\n        clusters.append(current_cluster)\n\n        # Step 2: Guided edge swapping (swap edges between different clusters)\n        if len(clusters) > 1:\n            cluster1, cluster2 = random.sample(clusters, 2)\n            if len(cluster1) > 1 and len(cluster2) > 1:\n                node1 = random.choice(cluster1)\n                node2 = random.choice(cluster2)\n                idx1 = np.where(new_solution == node1)[0][0]\n                idx2 = np.where(new_solution == node2)[0][0]\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective-space aware selection that prioritizes solutions with balanced improvement potential in both objectives, then applies a hybrid local search combining adaptive path splitting and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with balanced improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = 1 - np.abs(normalized[:, 0] - normalized[:, 1])\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive path splitting and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive path splitting (find a split point based on objective balance)\n        split_point = n // 2\n        for i in range(n):\n            node_prev = new_solution[(i-1)%n]\n            node_curr = new_solution[i]\n            node_next = new_solution[(i+1)%n]\n\n            # Calculate potential improvement in both objectives\n            obj1_prev = distance_matrix_1[node_prev, node_curr] + distance_matrix_1[node_curr, node_next]\n            obj2_prev = distance_matrix_2[node_prev, node_curr] + distance_matrix_2[node_curr, node_next]\n\n            obj1_new = distance_matrix_1[node_prev, node_next]\n            obj2_new = distance_matrix_2[node_prev, node_next]\n\n            improvement1 = obj1_prev - obj1_new\n            improvement2 = obj2_prev - obj2_new\n\n            if improvement1 > 0 and improvement2 > 0:\n                split_point = i\n                break\n\n        # Step 2: Multi-objective edge insertion (insert best edge from other objective)\n        if split_point > 0 and split_point < n-1:\n            path1 = new_solution[:split_point+1]\n            path2 = new_solution[split_point+1:]\n\n            # Find best insertion point and edge from the other objective\n            best_insert_pos = 0\n            best_edge = None\n            best_improvement = -np.inf\n\n            for i in range(len(path1)-1):\n                node_prev = path1[i]\n                node_next = path1[i+1]\n\n                # Search for an edge in the other path that would improve both objectives\n                for j in range(len(path2)-1):\n                    candidate_edge = (path2[j], path2[j+1])\n\n                    # Calculate potential improvement\n                    old_dist1 = distance_matrix_1[node_prev, node_next]\n                    new_dist1 = distance_matrix_1[node_prev, candidate_edge[0]] + distance_matrix_1[candidate_edge[1], node_next]\n                    improvement1 = old_dist1 - new_dist1\n\n                    old_dist2 = distance_matrix_2[node_prev, node_next]\n                    new_dist2 = distance_matrix_2[node_prev, candidate_edge[0]] + distance_matrix_2[candidate_edge[1], node_next]\n                    improvement2 = old_dist2 - new_dist2\n\n                    if improvement1 > 0 and improvement2 > 0 and (improvement1 + improvement2) > best_improvement:\n                        best_improvement = improvement1 + improvement2\n                        best_insert_pos = i\n                        best_edge = candidate_edge\n\n            # Perform the insertion if beneficial\n            if best_edge is not None:\n                node_prev = path1[best_insert_pos]\n                node_next = path1[best_insert_pos+1]\n\n                # Remove the edge from path2\n                edge_pos = np.where((path2[:-1] == best_edge[0]) & (path2[1:] == best_edge[1]))[0]\n                if len(edge_pos) > 0:\n                    edge_pos = edge_pos[0]\n                    path2 = np.concatenate([path2[:edge_pos+1], path2[edge_pos+2:]])\n\n                # Insert the edge in path1\n                new_path1 = np.concatenate([path1[:best_insert_pos+1], [best_edge[0]], [best_edge[1]], path1[best_insert_pos+1:]])\n                new_solution = np.concatenate([new_path1, path2])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9389375420228149,
            0.24662506580352783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with balanced improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = 1 - np.abs(normalized[:, 0] - normalized[:, 1])\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive path splitting and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive path splitting (find a split point based on objective balance)\n        split_point = n // 2\n        for i in range(n):\n            node_prev = new_solution[(i-1)%n]\n            node_curr = new_solution[i]\n            node_next = new_solution[(i+1)%n]\n\n            # Calculate potential improvement in both objectives\n            obj1_prev = distance_matrix_1[node_prev, node_curr] + distance_matrix_1[node_curr, node_next]\n            obj2_prev = distance_matrix_2[node_prev, node_curr] + distance_matrix_2[node_curr, node_next]\n\n            obj1_new = distance_matrix_1[node_prev, node_next]\n            obj2_new = distance_matrix_2[node_prev, node_next]\n\n            improvement1 = obj1_prev - obj1_new\n            improvement2 = obj2_prev - obj2_new\n\n            if improvement1 > 0 and improvement2 > 0:\n                split_point = i\n                break\n\n        # Step 2: Multi-objective edge insertion (insert best edge from other objective)\n        if split_point > 0 and split_point < n-1:\n            path1 = new_solution[:split_point+1]\n            path2 = new_solution[split_point+1:]\n\n            # Find best insertion point and edge from the other objective\n            best_insert_pos = 0\n            best_edge = None\n            best_improvement = -np.inf\n\n            for i in range(len(path1)-1):\n                node_prev = path1[i]\n                node_next = path1[i+1]\n\n                # Search for an edge in the other path that would improve both objectives\n                for j in range(len(path2)-1):\n                    candidate_edge = (path2[j], path2[j+1])\n\n                    # Calculate potential improvement\n                    old_dist1 = distance_matrix_1[node_prev, node_next]\n                    new_dist1 = distance_matrix_1[node_prev, candidate_edge[0]] + distance_matrix_1[candidate_edge[1], node_next]\n                    improvement1 = old_dist1 - new_dist1\n\n                    old_dist2 = distance_matrix_2[node_prev, node_next]\n                    new_dist2 = distance_matrix_2[node_prev, candidate_edge[0]] + distance_matrix_2[candidate_edge[1], node_next]\n                    improvement2 = old_dist2 - new_dist2\n\n                    if improvement1 > 0 and improvement2 > 0 and (improvement1 + improvement2) > best_improvement:\n                        best_improvement = improvement1 + improvement2\n                        best_insert_pos = i\n                        best_edge = candidate_edge\n\n            # Perform the insertion if beneficial\n            if best_edge is not None:\n                node_prev = path1[best_insert_pos]\n                node_next = path1[best_insert_pos+1]\n\n                # Remove the edge from path2\n                edge_pos = np.where((path2[:-1] == best_edge[0]) & (path2[1:] == best_edge[1]))[0]\n                if len(edge_pos) > 0:\n                    edge_pos = edge_pos[0]\n                    path2 = np.concatenate([path2[:edge_pos+1], path2[edge_pos+2:]])\n\n                # Insert the edge in path1\n                new_path1 = np.concatenate([path1[:best_insert_pos+1], [best_edge[0]], [best_edge[1]], path1[best_insert_pos+1:]])\n                new_solution = np.concatenate([new_path1, path2])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.argmin([sum(obj) for sol, obj in pareto_front])\n    base_solution = pareto_front[selected_idx][0].copy() if pareto_front else archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Reverse a segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Insert a random node at a random position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9383562487322736,
            0.24323874711990356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.argmin([sum(obj) for sol, obj in pareto_front])\n    base_solution = pareto_front[selected_idx][0].copy() if pareto_front else archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Reverse a segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Insert a random node at a random position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a novel diversity-aware selection that prioritizes solutions with unique edge patterns, then applies a hybrid local search combining adaptive node clustering and guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique edge patterns\n    edge_patterns = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        edge_patterns.append(len(pattern))\n\n    selected_idx = np.argmax(edge_patterns)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and guided edge swapping\n    if n > 3:\n        # Step 1: Adaptive node clustering (group nodes based on coordinate similarity)\n        clusters = []\n        current_cluster = [new_solution[0]]\n        for i in range(1, n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            prev_coords = instance[prev_node]\n            curr_coords = instance[curr_node]\n\n            # Check if nodes are close in both objective spaces\n            dist1 = np.sqrt((prev_coords[0] - curr_coords[0])**2 + (prev_coords[1] - curr_coords[1])**2)\n            dist2 = np.sqrt((prev_coords[2] - curr_coords[2])**2 + (prev_coords[3] - curr_coords[3])**2)\n            if (dist1 < np.mean(distance_matrix_1) * 0.3 and dist2 < np.mean(distance_matrix_2) * 0.3):\n                current_cluster.append(curr_node)\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [curr_node]\n        clusters.append(current_cluster)\n\n        # Step 2: Guided edge swapping (swap edges between different clusters)\n        if len(clusters) > 1:\n            cluster1, cluster2 = random.sample(clusters, 2)\n            if len(cluster1) > 1 and len(cluster2) > 1:\n                node1 = random.choice(cluster1)\n                node2 = random.choice(cluster2)\n                idx1 = np.where(new_solution == node1)[0][0]\n                idx2 = np.where(new_solution == node2)[0][0]\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance-aware selection that prioritizes solutions in less crowded regions of the objective space, then applies a hybrid local search combining adaptive segment inversion and guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = [obj for _, obj in archive]\n    objectives = np.array(objectives)\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion and guided node insertion\n    if n > 3:\n        # Step 1: Adaptive segment inversion\n        segment_length = max(2, min(n//4, random.randint(2, n//2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Step 2: Guided node insertion\n        if n > 4:\n            node_to_move = random.choice(new_solution)\n            new_solution = new_solution[new_solution != node_to_move]\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7651254529181041,
            0.2880508303642273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in less crowded regions\n    objectives = [obj for _, obj in archive]\n    objectives = np.array(objectives)\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion and guided node insertion\n    if n > 3:\n        # Step 1: Adaptive segment inversion\n        segment_length = max(2, min(n//4, random.randint(2, n//2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Step 2: Guided node insertion\n        if n > 4:\n            node_to_move = random.choice(new_solution)\n            new_solution = new_solution[new_solution != node_to_move]\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    sorted_indices = np.argsort(objectives)\n    selection_prob = np.exp(-np.arange(len(archive)) / len(archive))\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(sorted_indices, p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment lengths\n    num_segments = np.random.randint(2, min(5, n//2))\n    segment_indices = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n\n    for i in range(len(segment_indices)):\n        start = segment_indices[i]\n        if i == len(segment_indices) - 1:\n            end = n\n        else:\n            end = segment_indices[i+1]\n        if end - start > 1:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge exchange based on distance improvement\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(1, n)\n        j = np.random.randint(1, n)\n        if i == j:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept exchange if it improves both objectives\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (np.random.rand() < 0.3 and (new_dist1 < current_dist1 or new_dist2 < current_dist2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9233696693261968,
            0.30642223358154297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    sorted_indices = np.argsort(objectives)\n    selection_prob = np.exp(-np.arange(len(archive)) / len(archive))\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(sorted_indices, p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive segment lengths\n    num_segments = np.random.randint(2, min(5, n//2))\n    segment_indices = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n\n    for i in range(len(segment_indices)):\n        start = segment_indices[i]\n        if i == len(segment_indices) - 1:\n            end = n\n        else:\n            end = segment_indices[i+1]\n        if end - start > 1:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge exchange based on distance improvement\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(1, n)\n        j = np.random.randint(1, n)\n        if i == j:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept exchange if it improves both objectives\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (np.random.rand() < 0.3 and (new_dist1 < current_dist1 or new_dist2 < current_dist2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines node reinsertion with path reversal and edge swapping, while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.array([np.std([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))]) for sol, _ in archive])\n    scores = objectives + 0.5 * diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search operator: Node Reinsertion with Path Reversal and Edge Swapping\n    # Step 1: Remove a random segment of nodes\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    removed_segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Step 2: Reverse the removed segment with probability 0.5\n    if np.random.rand() < 0.5:\n        removed_segment = removed_segment[::-1]\n\n    # Step 3: Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], removed_segment, new_solution[insert_pos:]])\n\n    # Step 4: Swap two randomly selected edges from different parts of the tour\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a != b and (a < i or a >= j) and (b < i or b >= j):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9006483932670584,
            2.901479125022888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.array([np.std([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))]) for sol, _ in archive])\n    scores = objectives + 0.5 * diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search operator: Node Reinsertion with Path Reversal and Edge Swapping\n    # Step 1: Remove a random segment of nodes\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    removed_segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Step 2: Reverse the removed segment with probability 0.5\n    if np.random.rand() < 0.5:\n        removed_segment = removed_segment[::-1]\n\n    # Step 3: Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], removed_segment, new_solution[insert_pos:]])\n\n    # Step 4: Swap two randomly selected edges from different parts of the tour\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a != b and (a < i or a >= j) and (b < i or b >= j):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a hybrid local search combining segment rotation and adaptive node substitution to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate diversity score\n        diversity = np.zeros(len(objectives))\n        for i in range(len(objectives)):\n            distances = np.linalg.norm(objectives - objectives[i], axis=1)\n            diversity[i] = np.mean(distances)\n\n        # Select solution with maximum diversity\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and adaptive node substitution\n    if n > 3:\n        # Step 1: Segment rotation (rotate a segment by a random amount)\n        segment_length = random.randint(2, min(n // 2, 5))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation = random.randint(1, segment_length - 1)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n        # Step 2: Adaptive node substitution (replace a node with one from another solution if it improves both objectives)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            candidate_node = random.choice(other_solution)\n            if candidate_node not in new_solution:\n                pos = random.randint(0, n - 1)\n                original_node = new_solution[pos]\n\n                # Calculate cost change\n                prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[(pos + 1) % n]\n\n                original_cost = (distance_matrix_1[prev_node, original_node] + distance_matrix_1[original_node, next_node] +\n                                distance_matrix_2[prev_node, original_node] + distance_matrix_2[original_node, next_node])\n\n                new_cost = (distance_matrix_1[prev_node, candidate_node] + distance_matrix_1[candidate_node, next_node] +\n                           distance_matrix_2[prev_node, candidate_node] + distance_matrix_2[candidate_node, next_node])\n\n                if new_cost < original_cost:\n                    new_solution[pos] = candidate_node\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.5986270116958413,
            0.7399953007698059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate diversity score\n        diversity = np.zeros(len(objectives))\n        for i in range(len(objectives)):\n            distances = np.linalg.norm(objectives - objectives[i], axis=1)\n            diversity[i] = np.mean(distances)\n\n        # Select solution with maximum diversity\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and adaptive node substitution\n    if n > 3:\n        # Step 1: Segment rotation (rotate a segment by a random amount)\n        segment_length = random.randint(2, min(n // 2, 5))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation = random.randint(1, segment_length - 1)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n        # Step 2: Adaptive node substitution (replace a node with one from another solution if it improves both objectives)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            candidate_node = random.choice(other_solution)\n            if candidate_node not in new_solution:\n                pos = random.randint(0, n - 1)\n                original_node = new_solution[pos]\n\n                # Calculate cost change\n                prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[(pos + 1) % n]\n\n                original_cost = (distance_matrix_1[prev_node, original_node] + distance_matrix_1[original_node, next_node] +\n                                distance_matrix_2[prev_node, original_node] + distance_matrix_2[original_node, next_node])\n\n                new_cost = (distance_matrix_1[prev_node, candidate_node] + distance_matrix_1[candidate_node, next_node] +\n                           distance_matrix_2[prev_node, candidate_node] + distance_matrix_2[candidate_node, next_node])\n\n                if new_cost < original_cost:\n                    new_solution[pos] = candidate_node\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining node swapping with adaptive segment reversal, ensuring feasibility by validating the resulting tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swapping with adaptive segment reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Reverse a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        reversed_segment = segment[::-1]\n        new_solution[k:l] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8351989802594755,
            0.2058330774307251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swapping with adaptive segment reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Reverse a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        reversed_segment = segment[::-1]\n        new_solution[k:l] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relocate a randomly selected edge to another position\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7724388850059243,
            0.19776475429534912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Invert a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relocate a randomly selected edge to another position\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9833534020790641,
            0.2400357723236084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{A novel adaptive hybrid local search algorithm that combines segment swapping with a dynamic edge reversal strategy, guided by objective-aware selection and feasibility-preserving constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    improvements = objectives - objectives.mean(axis=0)\n    scores = np.abs(improvements).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment swap with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    segment1 = new_solution[i:j]\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n\n    segment2 = new_solution[k:l]\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive edge reversal based on distance matrices\n    total_dist1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if total_dist1 > total_dist2:\n        # Reverse more edges in space 1\n        for _ in range(2):\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution[k:l] = new_solution[k:l][::-1]\n    else:\n        # Reverse more edges in space 2\n        for _ in range(3):\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7113485098666706,
            0.13195282220840454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    improvements = objectives - objectives.mean(axis=0)\n    scores = np.abs(improvements).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment swap with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    segment1 = new_solution[i:j]\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n\n    segment2 = new_solution[k:l]\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive edge reversal based on distance matrices\n    total_dist1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if total_dist1 > total_dist2:\n        # Reverse more edges in space 1\n        for _ in range(2):\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution[k:l] = new_solution[k:l][::-1]\n    else:\n        # Reverse more edges in space 2\n        for _ in range(3):\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement based on a hybrid scoring function combining dominance and crowding distance, then applies a novel local search combining adaptive edge swapping with segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol):\n        obj = sol[1]\n        dominated = sum(1 for s in archive if s[1][0] <= obj[0] and s[1][1] <= obj[1] and (s[1][0] < obj[0] or s[1][1] < obj[1]))\n        crowding = (sum(s[1][0] for s in archive) / len(archive) - obj[0])**2 + (sum(s[1][1] for s in archive) / len(archive) - obj[1])**2\n        return dominated - crowding\n\n    # Select solution with highest score\n    archive_sorted = sorted(archive, key=score, reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive edge swapping with segment reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Swap edges with higher probability for better edges\n    if np.random.random() < 0.7:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Reverse a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8514319614910776,
            3.9063716530799866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol):\n        obj = sol[1]\n        dominated = sum(1 for s in archive if s[1][0] <= obj[0] and s[1][1] <= obj[1] and (s[1][0] < obj[0] or s[1][1] < obj[1]))\n        crowding = (sum(s[1][0] for s in archive) / len(archive) - obj[0])**2 + (sum(s[1][1] for s in archive) / len(archive) - obj[1])**2\n        return dominated - crowding\n\n    # Select solution with highest score\n    archive_sorted = sorted(archive, key=score, reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive edge swapping with segment reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Swap edges with higher probability for better edges\n    if np.random.random() < 0.7:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Reverse a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining adaptive segment swapping with dynamic edge flipping, ensuring feasibility by validating the resulting tour while considering both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of similar length\n        segment_length = j - i\n        k = np.random.randint(0, n - segment_length)\n        l = k + segment_length\n\n        # Swap segments\n        new_solution[i:j], new_solution[k:l] = new_solution[k:l].copy(), new_solution[i:j].copy()\n\n    # Dynamic edge flipping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            # Flip edge based on both objective spaces\n            cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n            cost2 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n            if cost1 > cost2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8066892101628202,
            0.2583562135696411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of similar length\n        segment_length = j - i\n        k = np.random.randint(0, n - segment_length)\n        l = k + segment_length\n\n        # Swap segments\n        new_solution[i:j], new_solution[k:l] = new_solution[k:l].copy(), new_solution[i:j].copy()\n\n    # Dynamic edge flipping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            # Flip edge based on both objective spaces\n            cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n            cost2 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n            if cost1 > cost2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This algorithm selects a promising solution from the archive, performs a novel local search by combining adaptive node swapping with multi-objective edge reversal, ensuring feasibility through validation and leveraging distance matrices for informed neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node swapping based on distance matrices\n    for _ in range(min(3, n // 2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Check if swapping improves both objectives\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or np.random.rand() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective edge reversal\n    for _ in range(min(2, n // 3)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        if j - i > 1:\n            segment = new_solution[i:j]\n            # Check if reversing improves both objectives\n            cost1_before = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            cost1_after = sum(distance_matrix_1[segment[k+1], segment[k]] for k in range(len(segment)-1))\n            cost2_before = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            cost2_after = sum(distance_matrix_2[segment[k+1], segment[k]] for k in range(len(segment)-1))\n\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or np.random.rand() < 0.2:\n                new_solution[i:j] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.976525043679442,
            0.350375235080719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node swapping based on distance matrices\n    for _ in range(min(3, n // 2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Check if swapping improves both objectives\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or np.random.rand() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective edge reversal\n    for _ in range(min(2, n // 3)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        if j - i > 1:\n            segment = new_solution[i:j]\n            # Check if reversing improves both objectives\n            cost1_before = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            cost1_after = sum(distance_matrix_1[segment[k+1], segment[k]] for k in range(len(segment)-1))\n            cost2_before = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            cost2_after = sum(distance_matrix_2[segment[k+1], segment[k]] for k in range(len(segment)-1))\n\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or np.random.rand() < 0.2:\n                new_solution[i:j] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge insertion with distance-based selection\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(1, n // 2)) % n\n    if i > j:\n        i, j = j, i\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Validate solution\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel diversity-aware selection that prioritizes solutions with unique edge patterns, then applies a hybrid local search combining adaptive node clustering and guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique edge patterns\n    edge_patterns = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        edge_patterns.append(len(pattern))\n\n    selected_idx = np.argmax(edge_patterns)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and guided edge swapping\n    if n > 3:\n        # Step 1: Adaptive node clustering (group nodes based on coordinate similarity)\n        clusters = []\n        current_cluster = [new_solution[0]]\n        for i in range(1, n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            prev_coords = instance[prev_node]\n            curr_coords = instance[curr_node]\n\n            # Check if nodes are close in both objective spaces\n            dist1 = np.sqrt((prev_coords[0] - curr_coords[0])**2 + (prev_coords[1] - curr_coords[1])**2)\n            dist2 = np.sqrt((prev_coords[2] - curr_coords[2])**2 + (prev_coords[3] - curr_coords[3])**2)\n            if (dist1 < np.mean(distance_matrix_1) * 0.3 and dist2 < np.mean(distance_matrix_2) * 0.3):\n                current_cluster.append(curr_node)\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [curr_node]\n        clusters.append(current_cluster)\n\n        # Step 2: Guided edge swapping (swap edges between different clusters)\n        if len(clusters) > 1:\n            cluster1, cluster2 = random.sample(clusters, 2)\n            if len(cluster1) > 1 and len(cluster2) > 1:\n                node1 = random.choice(cluster1)\n                node2 = random.choice(cluster2)\n                idx1 = np.where(new_solution == node1)[0][0]\n                idx2 = np.where(new_solution == node2)[0][0]\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and spatial proximity, then applies a novel hybrid local search that combines adaptive segment rotation and guided node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and spatial diversity\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    spatial_scores = []\n    for sol, _ in archive:\n        total_dist = 0\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            total_dist += distance_matrix_1[a, b] + distance_matrix_2[a, b]\n        spatial_scores.append(total_dist)\n\n    combined_scores = [weights[0] * obj[0] + weights[1] * obj[1] + 0.5 * spatial_scores[i] for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and guided node reinsertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Rotate segment based on spatial proximity\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end] = rotated_segment\n\n        # Step 2: Guided node reinsertion\n        if random.random() < 0.7:  # Higher probability for this operation\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n\n            # Find insertion position based on both objectives\n            best_pos = -1\n            min_cost = float('inf')\n            for i in range(n):\n                if i == node_pos or i == (node_pos - 1) % n:\n                    continue\n\n                a = new_solution[(i-1)%n]\n                b = new_solution[i]\n                cost = distance_matrix_1[a, node] + distance_matrix_1[node, b] + \\\n                       distance_matrix_2[a, node] + distance_matrix_2[node, b]\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n                if best_pos > node_pos:\n                    best_pos -= 1\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6999607853101895,
            0.7125328779220581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with both good objectives and spatial diversity\n    objectives = [obj for _, obj in archive]\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    weights = (1 / (std_obj + 1e-6)) / np.sum(1 / (std_obj + 1e-6))\n\n    spatial_scores = []\n    for sol, _ in archive:\n        total_dist = 0\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            total_dist += distance_matrix_1[a, b] + distance_matrix_2[a, b]\n        spatial_scores.append(total_dist)\n\n    combined_scores = [weights[0] * obj[0] + weights[1] * obj[1] + 0.5 * spatial_scores[i] for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and guided node reinsertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Rotate segment based on spatial proximity\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end] = rotated_segment\n\n        # Step 2: Guided node reinsertion\n        if random.random() < 0.7:  # Higher probability for this operation\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n\n            # Find insertion position based on both objectives\n            best_pos = -1\n            min_cost = float('inf')\n            for i in range(n):\n                if i == node_pos or i == (node_pos - 1) % n:\n                    continue\n\n                a = new_solution[(i-1)%n]\n                b = new_solution[i]\n                cost = distance_matrix_1[a, node] + distance_matrix_1[node, b] + \\\n                       distance_matrix_2[a, node] + distance_matrix_2[node, b]\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n                if best_pos > node_pos:\n                    best_pos -= 1\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # Weight for each objective\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with segment reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Remove segment and insert elsewhere\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Reverse a segment with adaptive size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9372216870437406,
            0.23198455572128296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # Weight for each objective\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with segment reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Remove segment and insert elsewhere\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Reverse a segment with adaptive size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment inversion, edge reversal, and random node swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion, edge reversal, and random swaps\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n    # Reverse edges with probability 0.3\n    if np.random.rand() < 0.3:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Random node swaps with probability 0.2\n    if np.random.rand() < 0.2:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.943301921382981,
            0.24168634414672852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion, edge reversal, and random swaps\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n    # Reverse edges with probability 0.3\n    if np.random.rand() < 0.3:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Random node swaps with probability 0.2\n    if np.random.rand() < 0.2:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{A novel multi-objective local search that combines adaptive segment insertion with objective-aware edge flipping to balance exploration and exploitation across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    weights = np.random.uniform(0.3, 0.7, size=2)  # Random but biased weights\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware flipping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    segment = new_solution[i:j]\n    k = np.random.randint(0, n)\n    if k < i or k >= j:\n        # Calculate segment cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Flip segment if it improves the objective with higher weight\n        if weights[0] > weights[1] and seg_cost1 > seg_cost2:\n            segment = segment[::-1]\n        elif weights[1] > weights[0] and seg_cost2 > seg_cost1:\n            segment = segment[::-1]\n\n        # Insert segment\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8967370362189275,
            0.14772683382034302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    weights = np.random.uniform(0.3, 0.7, size=2)  # Random but biased weights\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware flipping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    segment = new_solution[i:j]\n    k = np.random.randint(0, n)\n    if k < i or k >= j:\n        # Calculate segment cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Flip segment if it improves the objective with higher weight\n        if weights[0] > weights[1] and seg_cost1 > seg_cost2:\n            segment = segment[::-1]\n        elif weights[1] > weights[0] and seg_cost2 > seg_cost1:\n            segment = segment[::-1]\n\n        # Insert segment\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining adaptive k-opt with segment reversal and insertion, ensuring feasibility by validating the resulting tour and reverting to the original if necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) - 0.5 * max(x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt with segment reversal and insertion\n    k = np.random.randint(2, min(5, n))\n    indices = np.random.choice(n, k, replace=False)\n    indices.sort()\n\n    # Reverse segments and insert nodes\n    for i in range(len(indices) - 1):\n        start, end = indices[i], indices[i+1]\n        if end - start > 1:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n            # Insert a random node from the segment elsewhere\n            node = segment[np.random.randint(0, len(segment))]\n            pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8001266262889715,
            0.14256316423416138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) - 0.5 * max(x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt with segment reversal and insertion\n    k = np.random.randint(2, min(5, n))\n    indices = np.random.choice(n, k, replace=False)\n    indices.sort()\n\n    # Reverse segments and insert nodes\n    for i in range(len(indices) - 1):\n        start, end = indices[i], indices[i+1]\n        if end - start > 1:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n            # Insert a random node from the segment elsewhere\n            node = segment[np.random.randint(0, len(segment))]\n            pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping, followed by a novel edge inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Invert edges between random nodes\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8464503392347832,
            0.22987478971481323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Invert edges between random nodes\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with the best combined objective value, then applies a novel segment-based local search that combines random segment insertion and adaptive edge swapping to explore the solution space while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= i and insert_pos <= j:\n            insert_pos = (insert_pos + j - i) % n\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment rotation and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment by a random amount\n        k = np.random.randint(1, j - i)\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges from different parts of the tour\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and (a < i or a >= j) and (b < i or b >= j):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel path inversion and segment reversal operator that combines random path inversion with segment reversal and adaptive edge insertion to explore the solution space while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment reversal\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9271836229517006,
            0.13225388526916504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment reversal\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{A novel adaptive hybrid local search algorithm that intelligently combines segment swapping, edge reversal, and dynamic segment selection to explore the solution space while maintaining feasibility and improving objective values in both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    potential = np.max(objectives, axis=1) - np.min(objectives, axis=1)  # Range of objectives\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection and swap\n    segment_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    new_pos = np.random.randint(0, n - segment_size)\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos+segment_size:]])\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n    # Adaptive edge reversal\n    reverse_size = np.random.randint(2, min(4, n//3))\n    reverse_start = np.random.randint(0, n - reverse_size)\n    new_solution[reverse_start:reverse_start+reverse_size] = new_solution[reverse_start:reverse_start+reverse_size][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7224714161684861,
            1.029479742050171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    potential = np.max(objectives, axis=1) - np.min(objectives, axis=1)  # Range of objectives\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection and swap\n    segment_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    new_pos = np.random.randint(0, n - segment_size)\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos+segment_size:]])\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n    # Adaptive edge reversal\n    reverse_size = np.random.randint(2, min(4, n//3))\n    reverse_start = np.random.randint(0, n - reverse_size)\n    new_solution[reverse_start:reverse_start+reverse_size] = new_solution[reverse_start:reverse_start+reverse_size][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution with balanced objectives from the archive, applies a novel hybrid local search combining adaptive segment flipping and multi-objective edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment flipping\n    segment_length = np.random.randint(2, n//2 + 1)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or abs(i - j) == 1:\n            continue\n\n        # Evaluate edge swap in both objectives\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n           (np.random.random() < 0.1 and (cost1_after < cost1_before or cost2_after < cost2_before)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7129330424424869,
            0.25069504976272583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment flipping\n    segment_length = np.random.randint(2, n//2 + 1)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or abs(i - j) == 1:\n            continue\n\n        # Evaluate edge swap in both objectives\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n           (np.random.random() < 0.1 and (cost1_after < cost1_before or cost2_after < cost2_before)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel diversity-aware selection that prioritizes solutions with unique edge patterns, then applies a hybrid local search combining adaptive node clustering and guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique edge patterns\n    edge_patterns = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        edge_patterns.append(len(pattern))\n\n    selected_idx = np.argmax(edge_patterns)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and guided edge swapping\n    if n > 3:\n        # Step 1: Adaptive node clustering (group nodes based on coordinate similarity)\n        clusters = []\n        current_cluster = [new_solution[0]]\n        for i in range(1, n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            prev_coords = instance[prev_node]\n            curr_coords = instance[curr_node]\n\n            # Check if nodes are close in both objective spaces\n            dist1 = np.sqrt((prev_coords[0] - curr_coords[0])**2 + (prev_coords[1] - curr_coords[1])**2)\n            dist2 = np.sqrt((prev_coords[2] - curr_coords[2])**2 + (prev_coords[3] - curr_coords[3])**2)\n            if (dist1 < np.mean(distance_matrix_1) * 0.3 and dist2 < np.mean(distance_matrix_2) * 0.3):\n                current_cluster.append(curr_node)\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [curr_node]\n        clusters.append(current_cluster)\n\n        # Step 2: Guided edge swapping (swap edges between different clusters)\n        if len(clusters) > 1:\n            cluster1, cluster2 = random.sample(clusters, 2)\n            if len(cluster1) > 1 and len(cluster2) > 1:\n                node1 = random.choice(cluster1)\n                node2 = random.choice(cluster2)\n                idx1 = np.where(new_solution == node1)[0][0]\n                idx2 = np.where(new_solution == node2)[0][0]\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution diversity, then applies a novel local search operator that combines adaptive segment rotation and guided node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        diversity.append(len(pattern))\n\n    scores = objectives * (1 + 0.1 * np.array(diversity) / max(diversity))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and guided node insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        seg_start = np.random.randint(0, n)\n        seg_size = np.random.randint(2, min(5, n//2))\n        seg_end = (seg_start + seg_size) % n\n\n        if seg_start < seg_end:\n            new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], 1)\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n            rotated = np.roll(segment, 1)\n            new_solution[seg_start:] = rotated[:n-seg_start]\n            new_solution[:seg_end] = rotated[n-seg_start:]\n\n        # Step 2: Guided node insertion\n        node_to_move = np.random.choice(new_solution)\n        node_idx = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find insertion point based on both objective spaces\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            elif pos == len(new_solution)-1:\n                prev_node = new_solution[-2]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos]\n\n            cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] - distance_matrix_2[prev_node, next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9364952887747019,
            1.710736870765686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = []\n    for sol, _ in archive:\n        pattern = set()\n        for i in range(len(sol)):\n            a, b = sol[i], sol[(i+1)%len(sol)]\n            pattern.add((min(a,b), max(a,b)))\n        diversity.append(len(pattern))\n\n    scores = objectives * (1 + 0.1 * np.array(diversity) / max(diversity))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and guided node insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        seg_start = np.random.randint(0, n)\n        seg_size = np.random.randint(2, min(5, n//2))\n        seg_end = (seg_start + seg_size) % n\n\n        if seg_start < seg_end:\n            new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], 1)\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n            rotated = np.roll(segment, 1)\n            new_solution[seg_start:] = rotated[:n-seg_start]\n            new_solution[:seg_end] = rotated[n-seg_start:]\n\n        # Step 2: Guided node insertion\n        node_to_move = np.random.choice(new_solution)\n        node_idx = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find insertion point based on both objective spaces\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            elif pos == len(new_solution)-1:\n                prev_node = new_solution[-2]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos]\n\n            cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] - distance_matrix_2[prev_node, next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -1.0077144265328175,
            0.4323732852935791
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining segment reversal with adaptive node swapping, ensuring feasibility by validating the resulting tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with adaptive node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Swap nodes to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.714412078007791,
            0.19625020027160645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with adaptive node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Swap nodes to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm selects a promising solution from the archive and applies a hybrid local search using adaptive segment insertion and edge reversal, ensuring feasibility by validating the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        k = np.random.randint(0, n)\n        if k > i:\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        else:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j:]])\n\n    # Edge reversal with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8133862192395691,
            0.1164746880531311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        k = np.random.randint(0, n)\n        if k > i:\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        else:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j:]])\n\n    # Edge reversal with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{A new algorithm that selects the solution with the highest combined objective value, applies a segment inversion and edge reversal operation, and ensures feasibility by verifying no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9485308391666273,
            0.22956395149230957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm selects a solution from the archive based on the best objective values, performs a novel local search by combining segment rotation and adaptive edge insertion, and ensures feasibility by validating the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographical order)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation: rotate a random segment to the left or right\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        rotation = np.random.choice([-1, 1])\n        if rotation == -1:\n            rotated_segment = np.roll(segment, -1)\n        else:\n            rotated_segment = np.roll(segment, 1)\n        new_solution[i:j] = rotated_segment\n\n    # Adaptive edge insertion: insert a random node at a random position\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node_to_insert = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8751423165027138,
            0.237537682056427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographical order)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation: rotate a random segment to the left or right\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment = new_solution[i:j]\n        rotation = np.random.choice([-1, 1])\n        if rotation == -1:\n            rotated_segment = np.roll(segment, -1)\n        else:\n            rotated_segment = np.roll(segment, 1)\n        new_solution[i:j] = rotated_segment\n\n    # Adaptive edge insertion: insert a random node at a random position\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node_to_insert = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel path inversion and segment reversal operator that combines random path inversion with segment reversal and adaptive edge insertion to explore the solution space while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment reversal\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel hybrid operator that combines segment merging, adaptive node relinking, and probabilistic edge flipping to explore the solution space while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment merging\n    i = np.random.randint(0, n-1)\n    j = np.random.randint(i+1, n)\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:]\n    merged_segment = np.concatenate([segment2, segment1, segment3])\n    new_solution = merged_segment\n\n    # Adaptive node relinking\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        if np.random.rand() < 0.5:\n            new_solution[k] = node_l\n            new_solution[l] = node_k\n        else:\n            new_solution[k] = node_l\n\n    # Probabilistic edge flipping\n    for idx in range(n-1):\n        if np.random.rand() < 0.3:\n            new_solution[idx], new_solution[idx+1] = new_solution[idx+1], new_solution[idx]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.703839954321712,
            0.276966392993927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment merging\n    i = np.random.randint(0, n-1)\n    j = np.random.randint(i+1, n)\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:]\n    merged_segment = np.concatenate([segment2, segment1, segment3])\n    new_solution = merged_segment\n\n    # Adaptive node relinking\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        if np.random.rand() < 0.5:\n            new_solution[k] = node_l\n            new_solution[l] = node_k\n        else:\n            new_solution[k] = node_l\n\n    # Probabilistic edge flipping\n    for idx in range(n-1):\n        if np.random.rand() < 0.3:\n            new_solution[idx], new_solution[idx+1] = new_solution[idx+1], new_solution[idx]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment reversal and edge insertion, while prioritizing nodes with the highest distance contributions in either objective space to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify nodes with highest distance contributions in either objective\n    total_distances_1 = np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]], axis=0)\n    total_distances_2 = np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]], axis=0)\n    total_distances = total_distances_1 + total_distances_2\n    high_contrib_nodes = np.argsort(total_distances)[-n//4:]\n\n    # Hybrid local search: prioritize reversing segments containing high-contribution nodes\n    i = np.random.choice(high_contrib_nodes)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a high-contribution node at a random position\n        k = np.random.choice(high_contrib_nodes)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8769553021076726,
            0.2657279968261719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify nodes with highest distance contributions in either objective\n    total_distances_1 = np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]], axis=0)\n    total_distances_2 = np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]], axis=0)\n    total_distances = total_distances_1 + total_distances_2\n    high_contrib_nodes = np.argsort(total_distances)[-n//4:]\n\n    # Hybrid local search: prioritize reversing segments containing high-contribution nodes\n    i = np.random.choice(high_contrib_nodes)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a high-contribution node at a random position\n        k = np.random.choice(high_contrib_nodes)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment reversal and edge exchange\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Reverse a segment and exchange it with another segment\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        k = np.random.randint(0, n - len(segment))\n        if k < i or k > j:\n            new_solution = np.concatenate([new_solution[:k], reversed_segment, new_solution[k + len(segment):]])\n\n        # Exchange two randomly selected edges\n        a, b = np.random.randint(0, n, size=2)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8946742231828364,
            0.8252356052398682
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment reversal and edge exchange\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Reverse a segment and exchange it with another segment\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        k = np.random.randint(0, n - len(segment))\n        if k < i or k > j:\n            new_solution = np.concatenate([new_solution[:k], reversed_segment, new_solution[k + len(segment):]])\n\n        # Exchange two randomly selected edges\n        a, b = np.random.randint(0, n, size=2)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    weighted_scores = [weights[i] * (obj[0] + obj[1]) for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    if j - i > 2:\n        segment = new_solution[i:j]\n        k = np.random.randint(1, len(segment))\n        new_solution = np.concatenate([new_solution[:i], segment[k:], segment[:k], new_solution[j:]])\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            # Calculate improvement potential in both objectives\n            cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n            cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n            new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n            new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < cost1) or (new_cost2 < cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8341250873691581,
            0.2360701560974121
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    weighted_scores = [weights[i] * (obj[0] + obj[1]) for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    if j - i > 2:\n        segment = new_solution[i:j]\n        k = np.random.randint(1, len(segment))\n        new_solution = np.concatenate([new_solution[:i], segment[k:], segment[:k], new_solution[j:]])\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            # Calculate improvement potential in both objectives\n            cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n            cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n            new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n            new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < cost1) or (new_cost2 < cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment reversal and multi-objective node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and multi-objective node swapping\n    if n > 3:\n        # Step 1: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] + distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Multi-objective node swapping\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for i in range(n):\n                for j in range(i+1, n):\n                    node_i = new_solution[i]\n                    node_j = new_solution[j]\n                    if node_j in other_solution and node_i not in other_solution:\n                        temp_solution = new_solution.copy()\n                        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                        if cost1 < sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and cost2 < sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)):\n                            new_solution = temp_solution\n                            break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.829594757315314,
            1.4887628555297852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and multi-objective node swapping\n    if n > 3:\n        # Step 1: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] + distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Multi-objective node swapping\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for i in range(n):\n                for j in range(i+1, n):\n                    node_i = new_solution[i]\n                    node_j = new_solution[j]\n                    if node_j in other_solution and node_i not in other_solution:\n                        temp_solution = new_solution.copy()\n                        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                        if cost1 < sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and cost2 < sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)):\n                            new_solution = temp_solution\n                            break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective and diversity criterion, then applies a novel hybrid local search combining adaptive segment rotation, multi-objective edge insertion, and a new segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, multi-objective edge insertion, and segment inversion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n        # Step 3: Segment inversion with adaptive size\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            inverted_segment = segment[::-1]\n            original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] + distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            inverted_cost = sum(distance_matrix_1[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] + distance_matrix_2[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment)))\n            if inverted_cost < original_cost:\n                new_solution[i:j] = inverted_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9299208933088411,
            0.4752964973449707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, multi-objective edge insertion, and segment inversion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n        # Step 3: Segment inversion with adaptive size\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            inverted_segment = segment[::-1]\n            original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] + distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            inverted_cost = sum(distance_matrix_1[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] + distance_matrix_2[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment)))\n            if inverted_cost < original_cost:\n                new_solution[i:j] = inverted_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm selects a solution with high diversity (measured by the difference between objectives) from the archive, applies a hybrid local search combining node insertion with adaptive segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion combined with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i:\n        j = np.random.randint(0, n)\n\n    # Node insertion\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive segment rotation\n    if np.random.random() < 0.4:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        shift = np.random.randint(1, m)\n        new_solution[start:start+m] = np.roll(new_solution[start:start+m], shift)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5883079679180415,
            0.2233651876449585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion combined with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i:\n        j = np.random.randint(0, n)\n\n    # Node insertion\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive segment rotation\n    if np.random.random() < 0.4:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        shift = np.random.randint(1, m)\n        new_solution[start:start+m] = np.roll(new_solution[start:start+m], shift)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel adaptive segment rotation and node reinsertion operator to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = [sum(abs(archive[i][1][0] - archive[j][1][0]) + abs(archive[i][1][1] - archive[j][1][1])\n                 for j in range(len(archive)) if j != i) for i in range(len(archive))]\n    scores = objectives + np.array(diversity) * 0.5\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation and node reinsertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    segment_length = max(2, min(j - i, np.random.randint(1, n//2)))\n\n    if segment_length > 1:\n        segment = new_solution[i:i+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[i+segment_length:]])\n\n    # Reinsert a randomly selected node at a different position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6179439978362802,
            2.7271377444267273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = [sum(abs(archive[i][1][0] - archive[j][1][0]) + abs(archive[i][1][1] - archive[j][1][1])\n                 for j in range(len(archive)) if j != i) for i in range(len(archive))]\n    scores = objectives + np.array(diversity) * 0.5\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation and node reinsertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    segment_length = max(2, min(j - i, np.random.randint(1, n//2)))\n\n    if segment_length > 1:\n        segment = new_solution[i:i+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[i+segment_length:]])\n\n    # Reinsert a randomly selected node at a different position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted sum of objectives with adaptive weights, then applies a hybrid local search combining segment inversion, edge reversal, and a probabilistic node swap to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet([1, 1])  # Random weights for objectives\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    # 1. Segment inversion with adaptive length\n    seg_length = np.random.randint(2, min(5, n))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment[::-1]\n\n    # 2. Probabilistic edge reversal\n    for i in range(n-1):\n        if np.random.rand() < 0.3:  # 30% chance to reverse edge\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # 3. Node swap based on distance improvement\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n        if delta1 < 0 or delta2 < 0:  # Only accept if at least one objective improves\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8495753064403977,
            0.26571738719940186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet([1, 1])  # Random weights for objectives\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    # 1. Segment inversion with adaptive length\n    seg_length = np.random.randint(2, min(5, n))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment[::-1]\n\n    # 2. Probabilistic edge reversal\n    for i in range(n-1):\n        if np.random.rand() < 0.3:  # 30% chance to reverse edge\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # 3. Node swap based on distance improvement\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n        if delta1 < 0 or delta2 < 0:  # Only accept if at least one objective improves\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution with the highest diversity in its objective values from the archive, then applies a hybrid local search combining node insertion with adaptive segment rotation and edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with adaptive segment rotation and edge flipping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Adaptive segment rotation\n    if j - i > 1:\n        segment = new_solution[i:j]\n        rotated = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[i:j] = rotated\n\n    # Node insertion\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Edge flipping\n    if np.random.random() < 0.5:\n        m = np.random.randint(0, n-1)\n        new_solution[m], new_solution[m+1] = new_solution[m+1], new_solution[m]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6000077215563038,
            0.23316532373428345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with adaptive segment rotation and edge flipping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Adaptive segment rotation\n    if j - i > 1:\n        segment = new_solution[i:j]\n        rotated = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[i:j] = rotated\n\n    # Node insertion\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Edge flipping\n    if np.random.random() < 0.5:\n        m = np.random.randint(0, n-1)\n        new_solution[m], new_solution[m+1] = new_solution[m+1], new_solution[m]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing solutions with extreme objective values, then applies a novel hybrid local search combining adaptive node swapping with segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with extreme objective values\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate extreme value score for each solution\n        extreme_scores = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            extreme_scores[sorted_indices[0]] += 1\n            extreme_scores[sorted_indices[-1]] += 1\n\n        # Select solution with highest extreme value score\n        selected_idx = np.argmax(extreme_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping with segment inversion\n    if n > 3:\n        # Step 1: Adaptive node swapping based on distance improvement\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            b = (b + 1) % n\n\n        original_dist = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + \\\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        swapped_dist = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] + \\\n                       distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if swapped_dist < original_dist:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Step 2: Segment inversion with feasibility check\n        c, d = sorted(random.sample(range(n), 2))\n        if c == d:\n            d = (d + 1) % n\n\n        segment = new_solution[c:d]\n        inverted_segment = segment[::-1]\n\n        original_segment_cost = distance_matrix_1[new_solution[c-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[d]] + \\\n                              distance_matrix_2[new_solution[c-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[d]]\n        inverted_segment_cost = distance_matrix_1[new_solution[c-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[d]] + \\\n                               distance_matrix_2[new_solution[c-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[d]]\n\n        if inverted_segment_cost < original_segment_cost:\n            new_solution[c:d] = inverted_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6821639629955641,
            0.6467373967170715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with extreme objective values\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate extreme value score for each solution\n        extreme_scores = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            extreme_scores[sorted_indices[0]] += 1\n            extreme_scores[sorted_indices[-1]] += 1\n\n        # Select solution with highest extreme value score\n        selected_idx = np.argmax(extreme_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping with segment inversion\n    if n > 3:\n        # Step 1: Adaptive node swapping based on distance improvement\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            b = (b + 1) % n\n\n        original_dist = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + \\\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        swapped_dist = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] + \\\n                       distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if swapped_dist < original_dist:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Step 2: Segment inversion with feasibility check\n        c, d = sorted(random.sample(range(n), 2))\n        if c == d:\n            d = (d + 1) % n\n\n        segment = new_solution[c:d]\n        inverted_segment = segment[::-1]\n\n        original_segment_cost = distance_matrix_1[new_solution[c-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[d]] + \\\n                              distance_matrix_2[new_solution[c-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[d]]\n        inverted_segment_cost = distance_matrix_1[new_solution[c-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[d]] + \\\n                               distance_matrix_2[new_solution[c-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[d]]\n\n        if inverted_segment_cost < original_segment_cost:\n            new_solution[c:d] = inverted_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        norm_obj1 = obj1 / np.max(distance_matrix_1.sum(axis=1))\n        norm_obj2 = obj2 / np.max(distance_matrix_2.sum(axis=1))\n        normalized_objectives.append(norm_obj1 + norm_obj2)\n\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and edge swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment by a random amount\n        segment = new_solution[i:j]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8985033563358995,
            1.2229647040367126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        norm_obj1 = obj1 / np.max(distance_matrix_1.sum(axis=1))\n        norm_obj2 = obj2 / np.max(distance_matrix_2.sum(axis=1))\n        normalized_objectives.append(norm_obj1 + norm_obj2)\n\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and edge swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment by a random amount\n        segment = new_solution[i:j]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.roll(segment, k)\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Swap two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel path inversion and segment reversal operator that combines random path inversion with segment reversal and adaptive edge insertion to explore the solution space while ensuring feasibility through validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment reversal\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel segment permutation and edge swapping operator that combines random segment permutation with adaptive edge swapping and node reinsertion to explore the solution space while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment permutation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j]\n    np.random.shuffle(segment)\n    new_solution[i:j] = segment\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Node reinsertion\n    for _ in range(1):\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8528199898432629,
            0.21813476085662842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment permutation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j]\n    np.random.shuffle(segment)\n    new_solution[i:j] = segment\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Node reinsertion\n    for _ in range(1):\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining segment inversion with edge swaps and distance-aware node insertions to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.7, 0.3])\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with edge swaps and distance-aware insertions\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Swap two edges based on distance improvement\n        for _ in range(2):\n            a = np.random.randint(0, n)\n            b = np.random.randint(0, n)\n            if a != b:\n                # Calculate distance change in both objectives\n                old_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n                new_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n                if new_dist >= old_dist:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8546963673475527,
            0.3334130048751831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.7, 0.3])\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with edge swaps and distance-aware insertions\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Swap two edges based on distance improvement\n        for _ in range(2):\n            a = np.random.randint(0, n)\n            b = np.random.randint(0, n)\n            if a != b:\n                # Calculate distance change in both objectives\n                old_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n                new_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n                if new_dist >= old_dist:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective dominance-based criterion, then applies a novel hybrid local search combining adaptive node insertion with multi-objective path reversal to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: find non-dominated solutions and select one with best combined objective\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = pareto_front[np.argmin([sum(obj) for i, obj in enumerate(objectives) if i in pareto_front])]\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node insertion with multi-objective path reversal\n    if n > 3:\n        # Step 1: Adaptive node insertion\n        for _ in range(min(3, n//2)):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                node = new_solution[j]\n                temp_solution = np.delete(new_solution, j)\n                best_pos = 0\n                min_cost = float('inf')\n                for pos in range(n-1):\n                    temp_solution = np.insert(temp_solution, pos, node)\n                    cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%(n-1)]] for k in range(n-1))\n                    cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%(n-1)]] for k in range(n-1))\n                    total_cost = cost1 + cost2\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_pos = pos\n                    temp_solution = np.delete(temp_solution, pos)\n                new_solution = np.insert(np.delete(new_solution, j), best_pos, node)\n\n        # Step 2: Multi-objective path reversal\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (reversed_cost1 <= original_cost1 and reversed_cost2 < original_cost2 * 1.1) or \\\n           (reversed_cost1 < original_cost1 * 1.1 and reversed_cost2 <= original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8828266874166494,
            2.8429152965545654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: find non-dominated solutions and select one with best combined objective\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = pareto_front[np.argmin([sum(obj) for i, obj in enumerate(objectives) if i in pareto_front])]\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node insertion with multi-objective path reversal\n    if n > 3:\n        # Step 1: Adaptive node insertion\n        for _ in range(min(3, n//2)):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                node = new_solution[j]\n                temp_solution = np.delete(new_solution, j)\n                best_pos = 0\n                min_cost = float('inf')\n                for pos in range(n-1):\n                    temp_solution = np.insert(temp_solution, pos, node)\n                    cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%(n-1)]] for k in range(n-1))\n                    cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%(n-1)]] for k in range(n-1))\n                    total_cost = cost1 + cost2\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_pos = pos\n                    temp_solution = np.delete(temp_solution, pos)\n                new_solution = np.insert(np.delete(new_solution, j), best_pos, node)\n\n        # Step 2: Multi-objective path reversal\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (reversed_cost1 <= original_cost1 and reversed_cost2 < original_cost2 * 1.1) or \\\n           (reversed_cost1 < original_cost1 * 1.1 and reversed_cost2 <= original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel path inversion and segment reversal operator that combines random path inversion with segment reversal and adaptive edge insertion to explore the solution space while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment reversal\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining adaptive node swapping with segment inversion, ensuring feasibility by validating the resulting tour and intelligently selecting nodes based on their potential to reduce both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node swapping based on distance reduction potential\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate potential improvement in both objectives\n        prev_node_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node_i = new_solution[(i+1)%n]\n        prev_node_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_node_j = new_solution[(j+1)%n]\n\n        # Potential cost change if we swap nodes i and j\n        cost_change_1 = (distance_matrix_1[prev_node_i, new_solution[j]] +\n                        distance_matrix_1[new_solution[j], next_node_i] +\n                        distance_matrix_1[prev_node_j, new_solution[i]] +\n                        distance_matrix_1[new_solution[i], next_node_j] -\n                        distance_matrix_1[prev_node_i, new_solution[i]] -\n                        distance_matrix_1[new_solution[i], next_node_i] -\n                        distance_matrix_1[prev_node_j, new_solution[j]] -\n                        distance_matrix_1[new_solution[j], next_node_j])\n\n        cost_change_2 = (distance_matrix_2[prev_node_i, new_solution[j]] +\n                        distance_matrix_2[new_solution[j], next_node_i] +\n                        distance_matrix_2[prev_node_j, new_solution[i]] +\n                        distance_matrix_2[new_solution[i], next_node_j] -\n                        distance_matrix_2[prev_node_i, new_solution[i]] -\n                        distance_matrix_2[new_solution[i], next_node_i] -\n                        distance_matrix_2[prev_node_j, new_solution[j]] -\n                        distance_matrix_2[new_solution[j], next_node_j])\n\n        # Accept swap if it reduces both objectives\n        if cost_change_1 < 0 and cost_change_2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion with adaptive length selection\n    if n > 3:\n        segment_length = min(5, n//2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8287216098186809,
            0.25944507122039795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node swapping based on distance reduction potential\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate potential improvement in both objectives\n        prev_node_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node_i = new_solution[(i+1)%n]\n        prev_node_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_node_j = new_solution[(j+1)%n]\n\n        # Potential cost change if we swap nodes i and j\n        cost_change_1 = (distance_matrix_1[prev_node_i, new_solution[j]] +\n                        distance_matrix_1[new_solution[j], next_node_i] +\n                        distance_matrix_1[prev_node_j, new_solution[i]] +\n                        distance_matrix_1[new_solution[i], next_node_j] -\n                        distance_matrix_1[prev_node_i, new_solution[i]] -\n                        distance_matrix_1[new_solution[i], next_node_i] -\n                        distance_matrix_1[prev_node_j, new_solution[j]] -\n                        distance_matrix_1[new_solution[j], next_node_j])\n\n        cost_change_2 = (distance_matrix_2[prev_node_i, new_solution[j]] +\n                        distance_matrix_2[new_solution[j], next_node_i] +\n                        distance_matrix_2[prev_node_j, new_solution[i]] +\n                        distance_matrix_2[new_solution[i], next_node_j] -\n                        distance_matrix_2[prev_node_i, new_solution[i]] -\n                        distance_matrix_2[new_solution[i], next_node_i] -\n                        distance_matrix_2[prev_node_j, new_solution[j]] -\n                        distance_matrix_2[new_solution[j], next_node_j])\n\n        # Accept swap if it reduces both objectives\n        if cost_change_1 < 0 and cost_change_2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion with adaptive length selection\n    if n > 3:\n        segment_length = min(5, n//2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware selection that prioritizes non-dominated solutions, then applies a hybrid local search combining segment inversion and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and node relocation\n    if n > 3:\n        # Step 1: Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Node relocation\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8985805227884793,
            0.3502578139305115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize non-dominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and node relocation\n    if n > 3:\n        # Step 1: Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Node relocation\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A novel heuristic that combines adaptive segment swapping with probabilistic edge flipping, prioritizing solutions with balanced objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    improvements = objectives - np.min(objectives, axis=0)\n    scores = np.sum(improvements, axis=1) * (1 + np.random.rand(len(archive)) * 0.1)  # Add slight randomness\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swap\n    segment_length = max(2, min(n//4, np.random.randint(2, n//2)))\n    a = np.random.randint(0, n - segment_length)\n    b = np.random.randint(0, n - segment_length)\n    if a > b:\n        a, b = b, a\n\n    # Swap segments with probability based on objective balance\n    obj_balance = (objectives[selected_idx][0] - objectives[selected_idx][1]) / (np.sum(objectives[selected_idx]) + 1e-6)\n    if np.random.rand() < 0.5 + 0.3 * obj_balance:\n        segment_a = new_solution[a:a+segment_length]\n        segment_b = new_solution[b:b+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:a], segment_b, new_solution[a+segment_length:b],\n            segment_a, new_solution[b+segment_length:]\n        ])\n\n    # Probabilistic edge flip\n    if np.random.rand() < 0.7:\n        k = np.random.randint(1, min(5, n//2))\n        for _ in range(k):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and np.random.rand() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.890696020102517,
            0.23049980401992798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    improvements = objectives - np.min(objectives, axis=0)\n    scores = np.sum(improvements, axis=1) * (1 + np.random.rand(len(archive)) * 0.1)  # Add slight randomness\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swap\n    segment_length = max(2, min(n//4, np.random.randint(2, n//2)))\n    a = np.random.randint(0, n - segment_length)\n    b = np.random.randint(0, n - segment_length)\n    if a > b:\n        a, b = b, a\n\n    # Swap segments with probability based on objective balance\n    obj_balance = (objectives[selected_idx][0] - objectives[selected_idx][1]) / (np.sum(objectives[selected_idx]) + 1e-6)\n    if np.random.rand() < 0.5 + 0.3 * obj_balance:\n        segment_a = new_solution[a:a+segment_length]\n        segment_b = new_solution[b:b+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:a], segment_b, new_solution[a+segment_length:b],\n            segment_a, new_solution[b+segment_length:]\n        ])\n\n    # Probabilistic edge flip\n    if np.random.rand() < 0.7:\n        k = np.random.randint(1, min(5, n//2))\n        for _ in range(k):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and np.random.rand() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with unique objective combinations, then applies a novel segment insertion and rotation operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique objective combinations\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate diversity score for each solution\n        diversity = np.zeros(len(objectives))\n        for i in range(len(objectives)):\n            distances = np.sqrt(np.sum((objectives - objectives[i])**2, axis=1))\n            diversity[i] = np.sum(distances)\n\n        # Select solution with maximum diversity\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment insertion and rotation\n    if n > 3:\n        # Step 1: Select a segment to rotate\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Step 2: Rotate the segment\n        rotation_amount = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation_amount)\n\n        # Step 3: Insert the rotated segment back\n        new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b+1:]])\n\n        # Step 4: Insert a node from another solution\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7703741023940192,
            0.5481575131416321
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with unique objective combinations\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate diversity score for each solution\n        diversity = np.zeros(len(objectives))\n        for i in range(len(objectives)):\n            distances = np.sqrt(np.sum((objectives - objectives[i])**2, axis=1))\n            diversity[i] = np.sum(distances)\n\n        # Select solution with maximum diversity\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment insertion and rotation\n    if n > 3:\n        # Step 1: Select a segment to rotate\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Step 2: Rotate the segment\n        rotation_amount = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation_amount)\n\n        # Step 3: Insert the rotated segment back\n        new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b+1:]])\n\n        # Step 4: Insert a node from another solution\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel path inversion and segment reversal operator that combines random path inversion with segment reversal and adaptive edge insertion to explore the solution space while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path inversion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment reversal\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that combines adaptive segment rotation with dynamic edge swapping to explore the solution space while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    if j - i > 1:\n        segment = new_solution[i:j]\n        k = np.random.randint(1, len(segment))\n        new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n    # Dynamic edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.819649785995097,
            0.2907385230064392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    if j - i > 1:\n        segment = new_solution[i:j]\n        k = np.random.randint(1, len(segment))\n        new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n    # Dynamic edge swapping\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b and abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This algorithm first selects a solution from the archive based on a combination of objective quality and diversity, then applies a novel hybrid local search combining multi-objective path inversion and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-objective path inversion and adaptive edge swapping\n    if n > 2:\n        # Step 1: Multi-objective path inversion\n        a, b = sorted(random.sample(range(n), 2))\n        original_cost = (sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)) +\n                         sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)))\n        inverted_segment = new_solution[a:b+1][::-1]\n        inverted_cost = (sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment))) +\n                         sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment))))\n        if inverted_cost < original_cost:\n            new_solution[a:b+1] = inverted_segment\n\n        # Step 2: Adaptive edge swapping\n        for _ in range(min(3, n//2)):\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j and (j - i) % n > 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                original_edges = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                 distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n                new_edges = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                             distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]])\n                if new_edges < original_edges:\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7008499135895271,
            0.47924333810806274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-objective path inversion and adaptive edge swapping\n    if n > 2:\n        # Step 1: Multi-objective path inversion\n        a, b = sorted(random.sample(range(n), 2))\n        original_cost = (sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)) +\n                         sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)))\n        inverted_segment = new_solution[a:b+1][::-1]\n        inverted_cost = (sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment))) +\n                         sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment))))\n        if inverted_cost < original_cost:\n            new_solution[a:b+1] = inverted_segment\n\n        # Step 2: Adaptive edge swapping\n        for _ in range(min(3, n//2)):\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j and (j - i) % n > 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                original_edges = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                 distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n                new_edges = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                             distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]])\n                if new_edges < original_edges:\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            edge = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, edge)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9613844083891536,
            0.30121564865112305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            edge = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, edge)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining random segment transposition with adaptive edge flipping, ensuring feasibility by validating the resulting tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment transposition with adaptive edge flipping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Transpose a segment to explore different configurations\n    if j - i > 1:\n        segment = new_solution[i:j]\n        transposed_segment = segment[::-1] if np.random.rand() > 0.5 else np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], transposed_segment, new_solution[j:]])\n\n    # Flip edges adaptively based on objective improvement potential\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]) - (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b-1]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]) - (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b-1]])\n            if delta1 + delta2 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8810426993973244,
            0.3298304080963135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment transposition with adaptive edge flipping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Transpose a segment to explore different configurations\n    if j - i > 1:\n        segment = new_solution[i:j]\n        transposed_segment = segment[::-1] if np.random.rand() > 0.5 else np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], transposed_segment, new_solution[j:]])\n\n    # Flip edges adaptively based on objective improvement potential\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]) - (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b-1]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]) - (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b-1]])\n            if delta1 + delta2 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid score combining both objectives, performs a novel local search by combining segment rotation and adaptive edge insertion, and ensures feasibility through validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a hybrid score combining both objectives\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment rotation and adaptive edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment by a random amount\n        segment = new_solution[i:j]\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n        new_solution[i:j] = segment\n\n    # Adaptive edge insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        # Insert a random segment between two positions\n        segment = new_solution[k:l]\n        m = np.random.randint(0, n - len(segment))\n        if m != k and m != l:\n            new_solution = np.concatenate([new_solution[:m], segment, new_solution[m:k], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring the original segment if invalid\n        new_solution[i:j] = base_solution[i:j]\n\n    return new_solution\n\n",
        "score": [
            -0.9173540159413653,
            0.20312631130218506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a hybrid score combining both objectives\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment rotation and adaptive edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate a segment by a random amount\n        segment = new_solution[i:j]\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n        new_solution[i:j] = segment\n\n    # Adaptive edge insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        # Insert a random segment between two positions\n        segment = new_solution[k:l]\n        m = np.random.randint(0, n - len(segment))\n        if m != k and m != l:\n            new_solution = np.concatenate([new_solution[:m], segment, new_solution[m:k], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring the original segment if invalid\n        new_solution[i:j] = base_solution[i:j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, node insertion, and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n        # Swap two randomly selected edges\n        m = np.random.randint(0, n)\n        p = np.random.randint(0, n)\n        if m != p:\n            new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9119196092439534,
            0.272263765335083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, node insertion, and edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n        # Swap two randomly selected edges\n        m = np.random.randint(0, n)\n        p = np.random.randint(0, n)\n        if m != p:\n            new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment inversion with multi-objective crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion with multi-objective crossover\n    if n > 3:\n        # Step 1: Adaptive segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        inverted_cost = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] + distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n        if inverted_cost < original_cost:\n            new_solution[a:b+1] = inverted_segment\n\n        # Step 2: Multi-objective crossover\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            crossover_point = random.randint(1, n-1)\n            new_solution = np.concatenate([new_solution[:crossover_point], other_solution[crossover_point:]])\n            new_solution = np.unique(new_solution, return_index=False, axis=0)\n            if len(new_solution) < n:\n                missing_nodes = [node for node in base_solution if node not in new_solution]\n                new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9088717457032364,
            0.3718782663345337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion with multi-objective crossover\n    if n > 3:\n        # Step 1: Adaptive segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        inverted_cost = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] + distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n        if inverted_cost < original_cost:\n            new_solution[a:b+1] = inverted_segment\n\n        # Step 2: Multi-objective crossover\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            crossover_point = random.randint(1, n-1)\n            new_solution = np.concatenate([new_solution[:crossover_point], other_solution[crossover_point:]])\n            new_solution = np.unique(new_solution, return_index=False, axis=0)\n            if len(new_solution) < n:\n                missing_nodes = [node for node in base_solution if node not in new_solution]\n                new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a solution from the archive based on a balance between objective values, then applies a novel combination of adaptive segment swapping and multi-objective edge optimization to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swapping\n    segment_size = max(2, min(n//3, np.random.randint(2, n//2)))\n    pos1 = np.random.randint(0, n - segment_size)\n    pos2 = np.random.randint(0, n - segment_size)\n    while abs(pos1 - pos2) < segment_size:\n        pos2 = np.random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n    new_solution = np.concatenate([\n        new_solution[:pos1], segment2, new_solution[pos1+segment_size:pos2],\n        segment1, new_solution[pos2+segment_size:]\n    ])\n\n    # Multi-objective edge optimization\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate potential improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 and (old_cost2 - new_cost2) < 0.1 * old_cost2) or \\\n               (new_cost2 < old_cost2 and (old_cost1 - new_cost1) < 0.1 * old_cost1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8539684199911426,
            0.14634913206100464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swapping\n    segment_size = max(2, min(n//3, np.random.randint(2, n//2)))\n    pos1 = np.random.randint(0, n - segment_size)\n    pos2 = np.random.randint(0, n - segment_size)\n    while abs(pos1 - pos2) < segment_size:\n        pos2 = np.random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n    new_solution = np.concatenate([\n        new_solution[:pos1], segment2, new_solution[pos1+segment_size:pos2],\n        segment1, new_solution[pos2+segment_size:]\n    ])\n\n    # Multi-objective edge optimization\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate potential improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 and (old_cost2 - new_cost2) < 0.1 * old_cost2) or \\\n               (new_cost2 < old_cost2 and (old_cost1 - new_cost1) < 0.1 * old_cost1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a hybrid local search combining random segment reversal and node relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and node relinking\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relink a node from another solution in the archive\n        if len(archive) > 1:\n            other_solution = archive[np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])][0]\n            k = np.random.randint(0, n)\n            node = other_solution[k]\n            if node not in new_solution:\n                l = np.random.randint(0, n-1)\n                new_solution = np.insert(new_solution, l, node)\n                new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8106189548679368,
            0.2533208131790161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and node relinking\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relink a node from another solution in the archive\n        if len(archive) > 1:\n            other_solution = archive[np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])][0]\n            k = np.random.randint(0, n)\n            node = other_solution[k]\n            if node not in new_solution:\n                l = np.random.randint(0, n-1)\n                new_solution = np.insert(new_solution, l, node)\n                new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm selects the solution with the highest maximum objective value from the archive, then applies a hybrid local search combining segment rotation and multi-edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([max(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and multi-edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate segment\n        segment = new_solution[i:j]\n        shift = np.random.randint(1, len(segment))\n        new_solution[i:j] = np.concatenate([segment[shift:], segment[:shift]])\n\n        # Multi-edge swapping\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and new_solution[k] != new_solution[l]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5846122789314014,
            0.2363949418067932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([max(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation and multi-edge swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Rotate segment\n        segment = new_solution[i:j]\n        shift = np.random.randint(1, len(segment))\n        new_solution[i:j] = np.concatenate([segment[shift:], segment[:shift]])\n\n        # Multi-edge swapping\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and new_solution[k] != new_solution[l]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel hybrid selection criterion combining dominance probability and adaptive segment mutation, then applies a creative local search operator that combines node insertion with adaptive segment reversal and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: hybrid of dominance probability and adaptive segment mutation\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    if n_solutions > 1:\n        # Calculate dominance probability for each solution\n        dominance = np.zeros(n_solutions)\n        for i in range(n_solutions):\n            for j in range(n_solutions):\n                if i != j:\n                    if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                       (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                        dominance[i] += 1\n            dominance[i] /= (n_solutions - 1)\n\n        # Combine with adaptive segment mutation potential\n        segment_lengths = np.random.randint(2, min(10, len(archive[0][0])), size=n_solutions)\n        selection_scores = dominance * (1 + 0.1 * segment_lengths / len(archive[0][0]))\n        selected_idx = np.argmax(selection_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Creative local search: adaptive node insertion with segment reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive node insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]\n\n        # Step 2: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost or random.random() < 0.3:  # Allow some randomness\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 3: Path relinking with adaptive segment selection\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            common_nodes = np.intersect1d(new_solution, other_solution)\n            if len(common_nodes) > 0:\n                node = random.choice(common_nodes)\n                pos_in_new = np.where(new_solution == node)[0][0]\n                pos_in_other = np.where(other_solution == node)[0][0]\n                segment_length = random.randint(1, min(5, n-1))\n                new_segment = other_solution[pos_in_other:pos_in_other+segment_length]\n                new_segment = new_segment[~np.isin(new_segment, new_solution)]\n                if len(new_segment) > 0:\n                    new_solution = np.insert(new_solution, pos_in_new, new_segment)\n                    new_solution = new_solution[:n]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.906788570311386,
            3.9677045345306396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: hybrid of dominance probability and adaptive segment mutation\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    if n_solutions > 1:\n        # Calculate dominance probability for each solution\n        dominance = np.zeros(n_solutions)\n        for i in range(n_solutions):\n            for j in range(n_solutions):\n                if i != j:\n                    if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                       (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                        dominance[i] += 1\n            dominance[i] /= (n_solutions - 1)\n\n        # Combine with adaptive segment mutation potential\n        segment_lengths = np.random.randint(2, min(10, len(archive[0][0])), size=n_solutions)\n        selection_scores = dominance * (1 + 0.1 * segment_lengths / len(archive[0][0]))\n        selected_idx = np.argmax(selection_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Creative local search: adaptive node insertion with segment reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive node insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]\n\n        # Step 2: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost or random.random() < 0.3:  # Allow some randomness\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 3: Path relinking with adaptive segment selection\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            common_nodes = np.intersect1d(new_solution, other_solution)\n            if len(common_nodes) > 0:\n                node = random.choice(common_nodes)\n                pos_in_new = np.where(new_solution == node)[0][0]\n                pos_in_other = np.where(other_solution == node)[0][0]\n                segment_length = random.randint(1, min(5, n-1))\n                new_segment = other_solution[pos_in_other:pos_in_other+segment_length]\n                new_segment = new_segment[~np.isin(new_segment, new_solution)]\n                if len(new_segment) > 0:\n                    new_solution = np.insert(new_solution, pos_in_new, new_segment)\n                    new_solution = new_solution[:n]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment inversion and multi-objective node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion and multi-objective node relocation\n    if n > 3:\n        # Step 1: Adaptive segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        inverted_cost = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] + distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n        if inverted_cost < original_cost:\n            new_solution[a:b+1] = inverted_segment\n\n        # Step 2: Multi-objective node relocation\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8739552609529216,
            0.36771267652511597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion and multi-objective node relocation\n    if n > 3:\n        # Step 1: Adaptive segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        inverted_cost = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] + distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n        if inverted_cost < original_cost:\n            new_solution[a:b+1] = inverted_segment\n\n        # Step 2: Multi-objective node relocation\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the solution with the highest combined objective value from the archive, then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, applies a hybrid local search combining random segment reversal and edge insertion, and ensures the solution remains feasible by checking uniqueness of nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9497127688044613,
            0.24232995510101318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert a randomly selected node at a random position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding-distance-aware selection that prioritizes solutions in sparsely populated regions of the Pareto front, then applies a hybrid local search combining adaptive edge reversal and path relinking to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions in sparsely populated regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with minimum crowding distance\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge reversal and path relinking\n    if n > 3:\n        # Step 1: Adaptive edge reversal (reverse a segment based on its improvement potential)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        reversed_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Path relinking (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection that prioritizes solutions with high variation in their objective values, then applies a hybrid local search combining adaptive node insertion with a novel \"objective-balanced\" edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate objective diversity for each solution\n        diversity = np.std(objectives, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node insertion with objective-balanced edge reversal\n    if n > 3:\n        # Step 1: Adaptive node insertion (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n        # Step 2: Objective-balanced edge reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate balanced cost\n        original_cost = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]) * 0.5\n        reversed_cost = (distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]) * 0.5\n\n        # Consider both objectives in reversal decision\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n        else:\n            # Alternative: reverse based on individual objective improvements\n            obj1_improvement = (distance_matrix_1[segment[-1], segment[0]] - distance_matrix_1[reversed_segment[-1], reversed_segment[0]]) > 0\n            obj2_improvement = (distance_matrix_2[segment[-1], segment[0]] - distance_matrix_2[reversed_segment[-1], reversed_segment[0]]) > 0\n            if obj1_improvement or obj2_improvement:\n                new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9334348588483291,
            2.021667718887329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate objective diversity for each solution\n        diversity = np.std(objectives, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node insertion with objective-balanced edge reversal\n    if n > 3:\n        # Step 1: Adaptive node insertion (insert a node from another solution)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            node_to_insert = random.choice(other_solution)\n            if node_to_insert not in new_solution:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node_to_insert)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n\n        # Step 2: Objective-balanced edge reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate balanced cost\n        original_cost = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]) * 0.5\n        reversed_cost = (distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]) * 0.5\n\n        # Consider both objectives in reversal decision\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n        else:\n            # Alternative: reverse based on individual objective improvements\n            obj1_improvement = (distance_matrix_1[segment[-1], segment[0]] - distance_matrix_1[reversed_segment[-1], reversed_segment[0]]) > 0\n            obj2_improvement = (distance_matrix_2[segment[-1], segment[0]] - distance_matrix_2[reversed_segment[-1], reversed_segment[0]]) > 0\n            if obj1_improvement or obj2_improvement:\n                new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment swap and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a segment with adaptive size and check feasibility\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{A novel adaptive hybrid local search algorithm that intelligently selects promising solutions from the archive and applies a combination of segment swapping, edge reversal, and insertion-based perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selection_probs = (1 / (1 + objectives)) / sum(1 / (1 + objectives))\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n\n    if j - i > 1 and l - k > 1:\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Edge reversal with adaptive segment size\n    m = np.random.randint(0, n)\n    p = np.random.randint(0, n)\n    if m > p:\n        m, p = p, m\n    if p - m > 1:\n        new_solution[m:p] = new_solution[m:p][::-1]\n\n    # Insertion-based perturbation\n    q = np.random.randint(0, n)\n    r = np.random.randint(0, n)\n    if q != r:\n        node = new_solution[r]\n        new_solution = np.concatenate([new_solution[:r], new_solution[r+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6853610674082049,
            0.157218337059021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selection_probs = (1 / (1 + objectives)) / sum(1 / (1 + objectives))\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n\n    if j - i > 1 and l - k > 1:\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Edge reversal with adaptive segment size\n    m = np.random.randint(0, n)\n    p = np.random.randint(0, n)\n    if m > p:\n        m, p = p, m\n    if p - m > 1:\n        new_solution[m:p] = new_solution[m:p][::-1]\n\n    # Insertion-based perturbation\n    q = np.random.randint(0, n)\n    r = np.random.randint(0, n)\n    if q != r:\n        node = new_solution[r]\n        new_solution = np.concatenate([new_solution[:r], new_solution[r+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{A novel bi-objective TSP algorithm that intelligently selects a base solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge reversal, segment insertion, and node swapping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment insertion, and node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n        # Insert a segment at a different position\n        k = np.random.randint(0, n)\n        if k != i:\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+2:]])\n            insert_pos = np.random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Swap two nodes\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8206114429635704,
            0.2624261975288391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal, segment insertion, and node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Reverse a segment\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n        # Insert a segment at a different position\n        k = np.random.randint(0, n)\n        if k != i:\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+2:]])\n            insert_pos = np.random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Swap two nodes\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8989528121838117,
            0.3710687756538391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: random segment inversion and edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n\n        # Reverse two randomly selected edges\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a novel hybrid local search combining adaptive path fragmentation and multi-objective node reinsertion with backtracking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good objective improvement potential and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized_objectives\n    structural_diversity = np.array([np.sum(np.abs(np.diff(archive[i][0]))) for i in range(len(archive))])\n    scores = np.mean(improvement_potential, axis=1) + structural_diversity / np.max(structural_diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive path fragmentation and multi-objective node reinsertion with backtracking\n    if n > 3:\n        # Step 1: Adaptive path fragmentation\n        fragment_size = max(2, min(5, n // 3))\n        start = random.randint(0, n - fragment_size)\n        fragment = new_solution[start:start+fragment_size]\n\n        # Step 2: Multi-objective node reinsertion with backtracking\n        for node in fragment:\n            # Remove node from current position\n            pos = np.where(new_solution == node)[0][0]\n            new_solution = np.delete(new_solution, pos)\n\n            # Find best insertion position considering both objectives\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                temp_solution = np.insert(new_solution, i, node)\n                cost = (sum(distance_matrix_1[temp_solution[j], temp_solution[(j+1)%(n-1)]] for j in range(n-1)) +\n                        sum(distance_matrix_2[temp_solution[j], temp_solution[(j+1)%(n-1)]] for j in range(n-1)))\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            # Insert node at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n            # Backtrack if no improvement\n            if best_pos == pos:\n                new_solution = np.delete(new_solution, best_pos)\n                new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6313933572311838,
            11.358697593212128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good objective improvement potential and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized_objectives\n    structural_diversity = np.array([np.sum(np.abs(np.diff(archive[i][0]))) for i in range(len(archive))])\n    scores = np.mean(improvement_potential, axis=1) + structural_diversity / np.max(structural_diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive path fragmentation and multi-objective node reinsertion with backtracking\n    if n > 3:\n        # Step 1: Adaptive path fragmentation\n        fragment_size = max(2, min(5, n // 3))\n        start = random.randint(0, n - fragment_size)\n        fragment = new_solution[start:start+fragment_size]\n\n        # Step 2: Multi-objective node reinsertion with backtracking\n        for node in fragment:\n            # Remove node from current position\n            pos = np.where(new_solution == node)[0][0]\n            new_solution = np.delete(new_solution, pos)\n\n            # Find best insertion position considering both objectives\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                temp_solution = np.insert(new_solution, i, node)\n                cost = (sum(distance_matrix_1[temp_solution[j], temp_solution[(j+1)%(n-1)]] for j in range(n-1)) +\n                        sum(distance_matrix_2[temp_solution[j], temp_solution[(j+1)%(n-1)]] for j in range(n-1)))\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            # Insert node at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n            # Backtrack if no improvement\n            if best_pos == pos:\n                new_solution = np.delete(new_solution, best_pos)\n                new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement, then applies a novel hybrid local search combining edge insertion with adaptive segment rotation, ensuring feasibility by validating the resulting tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with adaptive segment rotation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j before position i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Rotate a segment to explore different configurations\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        segment = new_solution[k:l]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:l] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective improvement potential metric, then applies a novel hybrid local search combining adaptive segment reversal with probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.prod(objectives, axis=1)  # Product of objectives as improvement metric\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal with probabilistic edge swapping\n    if n > 3:\n        # Step 1: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] + distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Probabilistic edge swapping\n        for _ in range(min(3, n//2)):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                if random.random() < 0.5:  # 50% chance to swap edges\n                    new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7162905503948888,
            0.24251145124435425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.prod(objectives, axis=1)  # Product of objectives as improvement metric\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal with probabilistic edge swapping\n    if n > 3:\n        # Step 1: Adaptive segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] + distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Step 2: Probabilistic edge swapping\n        for _ in range(min(3, n//2)):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                if random.random() < 0.5:  # 50% chance to swap edges\n                    new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, performs a hybrid local search by combining segment swapping and edge reversal with adaptive segment selection, and ensures feasibility by validating the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap and edge reversal with adaptive segment selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Swap two segments of the tour with adaptive segment selection\n        segment1 = new_solution[i:j]\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Reverse a random segment to explore different paths with adaptive segment size\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k > l:\n        k, l = l, k\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive, applies a hybrid local search combining edge cross-exchange and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge cross-exchange combined with adaptive segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge cross-exchange\n    if abs(i - j) > 1 and abs(k - l) > 1 and not (i <= k <= j and i <= l <= j):\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Adaptive segment reversal\n    if np.random.random() < 0.3:\n        m = np.random.randint(2, n//2)\n        start = np.random.randint(0, n - m)\n        new_solution[start:start+m] = new_solution[start:start+m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel hybrid selection criterion combining objective diversity and solution quality, then applies a novel local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = np.random.randint(0, n)\n    m = np.random.randint(2, min(6, n//2))\n    segment = new_solution[k:k+m]\n    rotated_segment = np.roll(segment, np.random.randint(1, m))\n    new_solution[k:k+m] = rotated_segment\n\n    # Multi-objective edge insertion\n    if np.random.random() < 0.4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate insertion cost in both objectives\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] - distance_matrix_1[new_solution[(i-1)%n], new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] - distance_matrix_2[new_solution[(i-1)%n], new_solution[i]]\n\n            # Only insert if both objectives improve\n            if cost1 < 0 and cost2 < 0:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0076553718992194,
            0.2626499533653259
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = np.random.randint(0, n)\n    m = np.random.randint(2, min(6, n//2))\n    segment = new_solution[k:k+m]\n    rotated_segment = np.roll(segment, np.random.randint(1, m))\n    new_solution[k:k+m] = rotated_segment\n\n    # Multi-objective edge insertion\n    if np.random.random() < 0.4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate insertion cost in both objectives\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] - distance_matrix_1[new_solution[(i-1)%n], new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] - distance_matrix_2[new_solution[(i-1)%n], new_solution[i]]\n\n            # Only insert if both objectives improve\n            if cost1 < 0 and cost2 < 0:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: adaptive segment rotation and edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 2:\n        # Rotate a segment and insert it at a new position\n        segment = new_solution[i:j]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n        # Insert a randomly selected edge from another part of the tour\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], edge, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest improvement potential, then applies a hybrid local search combining segment inversion and edge relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected = archive[0][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relocate an edge\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8946257227023506,
            0.2747190594673157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected = archive[0][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    if j - i > 1:\n        # Invert a segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Relocate an edge\n        k = np.random.randint(0, n)\n        if k < i or k > j:\n            edge = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], edge])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective-aware and diversity-preserving criterion, then applies a novel hybrid local search combining adaptive segment rotation and multi-objective edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with good combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.mean(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and multi-objective edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        rotated_cost = sum(distance_matrix_1[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] + distance_matrix_2[rotated_segment[i], rotated_segment[(i+1)%len(rotated_segment)]] for i in range(len(rotated_segment)))\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n        # Step 2: Multi-objective edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for node in other_solution:\n                if node not in new_solution:\n                    best_pos = 0\n                    min_cost = float('inf')\n                    for pos in range(n):\n                        temp_solution = np.insert(new_solution, pos, node)\n                        cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_solution = np.insert(new_solution, best_pos, node)\n                    new_solution = new_solution[:n]\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining adaptive segment reversal and multi-objective node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet([1, 1])\n    weighted_scores = np.dot(objectives, weights)\n    diversity_scores = np.array([np.sum(sol[0] != archive[0][0]) for sol in archive])\n    combined_scores = weighted_scores + 0.5 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] + distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for i in range(n):\n                for j in range(i+1, n):\n                    temp_solution = new_solution.copy()\n                    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                    cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    if cost1 < sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and cost2 < sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)):\n                        new_solution = temp_solution\n                        break\n\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.5441959002012621,
            11.397842705249786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet([1, 1])\n    weighted_scores = np.dot(objectives, weights)\n    diversity_scores = np.array([np.sum(sol[0] != archive[0][0]) for sol in archive])\n    combined_scores = weighted_scores + 0.5 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        original_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] + distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] + distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            for i in range(n):\n                for j in range(i+1, n):\n                    temp_solution = new_solution.copy()\n                    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                    cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    if cost1 < sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and cost2 < sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)):\n                        new_solution = temp_solution\n                        break\n\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    }
]