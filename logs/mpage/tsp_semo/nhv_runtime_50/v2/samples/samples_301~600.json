[
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, named \"Cross-Objective Path Diversification with Adaptive Segment Splitting and Multi-Dimensional Node Reassignment,\" departs from traditional segment-based approaches by first identifying critical path segments that exhibit significant imbalance between objectives, then adaptively splitting these segments into smaller, more manageable units while preserving the overall path structure, followed by a multi-dimensional node reassignment phase that probabilistically redistributes nodes between segments based on their cross-dimensional contribution scores, while dynamically adjusting the reassignment criteria based on the current solution's objective balance and the spatial distribution of nodes in both coordinate spaces, and finally reconstructing the solution while ensuring feasibility through a comprehensive validation mechanism that checks for node uniqueness, circularity, and spatial proximity constraints across both objective spaces, thus enabling both fine-grained local improvements and more disruptive global explorations through cross-dimensional path diversification.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify critical segments with significant objective imbalance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if abs(cost1 - cost2) > 0.3 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 2: Adaptive segment splitting\n    for i in range(len(segments)):\n        segment = segments[i]\n        if len(segment) < 4:\n            continue\n\n        # Calculate segment objectives\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        if abs(cost1 - cost2) > 0.4 * (cost1 + cost2):\n            # Split segment at the point with highest cross-dimensional variance\n            max_variance = -1\n            split_point = len(segment) // 2\n\n            for j in range(1, len(segment)-1):\n                node_prev = segment[j-1]\n                node_curr = segment[j]\n                node_next = segment[j+1]\n\n                cost1_prev_curr = distance_matrix_1[node_prev, node_curr]\n                cost2_prev_curr = distance_matrix_2[node_prev, node_curr]\n                cost1_curr_next = distance_matrix_1[node_curr, node_next]\n                cost2_curr_next = distance_matrix_2[node_curr, node_next]\n\n                variance = abs((cost1_prev_curr + cost1_curr_next) - (cost2_prev_curr + cost2_curr_next))\n                if variance > max_variance:\n                    max_variance = variance\n                    split_point = j\n\n            if split_point > 1 and split_point < len(segment)-1:\n                new_segment1 = segment[:split_point]\n                new_segment2 = segment[split_point:]\n                segments[i:i+1] = [new_segment1, new_segment2]\n\n    # Step 3: Multi-dimensional node reassignment\n    all_nodes = set(range(n))\n    assigned_nodes = set()\n    for segment in segments:\n        assigned_nodes.update(segment)\n\n    unassigned_nodes = list(all_nodes - assigned_nodes)\n    random.shuffle(unassigned_nodes)\n\n    for node in unassigned_nodes:\n        best_segment = None\n        best_improvement = 0\n\n        for i in range(len(segments)):\n            segment = segments[i]\n\n            # Calculate potential insertion points\n            for j in range(len(segment)):\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j] if j < len(segment) else segment[0]\n\n                # Calculate current and potential costs\n                current_cost1 = distance_matrix_1[prev_node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, next_node]\n\n                new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_segment = i\n                    best_position = j\n\n        if best_segment is not None:\n            segments[best_segment].insert(best_position, node)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for segment in segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 301,
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Segment Harmonization with Dynamic Objective Balancing,\" departs from traditional segment-based approaches by first identifying and preserving the most harmonious node sequences that exhibit balanced contributions to both objectives, then dynamically realigning these segments through a novel cross-dimensional segment harmonization process that evaluates each segment's potential contribution to both objectives while probabilistically adjusting the segment boundaries based on the current solution's objective balance, followed by a dynamic objective balancing phase that probabilistically redistributes nodes between segments based on their cross-dimensional contribution scores, while dynamically adjusting the reassignment criteria based on the current solution's objective balance and the spatial distribution of nodes in both coordinate spaces, and finally reconstructing the solution while ensuring feasibility through a comprehensive validation mechanism that checks for node uniqueness, circularity, and spatial proximity constraints across both objective spaces, thus enabling both fine-grained local improvements and more disruptive global explorations through cross-dimensional segment harmonization.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify harmonious segments with balanced contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if abs(cost1 - cost2) > 0.2 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 2: Dynamic segment harmonization\n    for i in range(len(segments)):\n        segment = segments[i]\n        if len(segment) < 3:\n            continue\n\n        # Calculate segment objectives\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Probabilistically adjust segment boundaries\n        if random.random() < 0.5 and len(segment) > 3:\n            split_point = random.randint(1, len(segment)-2)\n            new_segment1 = segment[:split_point]\n            new_segment2 = segment[split_point:]\n            segments[i:i+1] = [new_segment1, new_segment2]\n\n    # Step 3: Dynamic objective balancing\n    all_nodes = set(range(n))\n    assigned_nodes = set()\n    for segment in segments:\n        assigned_nodes.update(segment)\n\n    unassigned_nodes = list(all_nodes - assigned_nodes)\n    random.shuffle(unassigned_nodes)\n\n    for node in unassigned_nodes:\n        best_segment = None\n        best_balance = float('inf')\n\n        for i in range(len(segments)):\n            segment = segments[i]\n\n            # Calculate potential insertion points\n            for j in range(len(segment)):\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j] if j < len(segment) else segment[0]\n\n                # Calculate current and potential costs\n                current_cost1 = distance_matrix_1[prev_node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, next_node]\n\n                new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                current_balance = abs(current_cost1 - current_cost2)\n                new_balance = abs(new_cost1 - new_cost2)\n\n                if new_balance < best_balance:\n                    best_balance = new_balance\n                    best_segment = i\n                    best_position = j\n\n        if best_segment is not None:\n            segments[best_segment].insert(best_position, node)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for segment in segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9096696152479127,
               0.15469282865524292
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify harmonious segments with balanced contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if abs(cost1 - cost2) > 0.2 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 2: Dynamic segment harmonization\n    for i in range(len(segments)):\n        segment = segments[i]\n        if len(segment) < 3:\n            continue\n\n        # Calculate segment objectives\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Probabilistically adjust segment boundaries\n        if random.random() < 0.5 and len(segment) > 3:\n            split_point = random.randint(1, len(segment)-2)\n            new_segment1 = segment[:split_point]\n            new_segment2 = segment[split_point:]\n            segments[i:i+1] = [new_segment1, new_segment2]\n\n    # Step 3: Dynamic objective balancing\n    all_nodes = set(range(n))\n    assigned_nodes = set()\n    for segment in segments:\n        assigned_nodes.update(segment)\n\n    unassigned_nodes = list(all_nodes - assigned_nodes)\n    random.shuffle(unassigned_nodes)\n\n    for node in unassigned_nodes:\n        best_segment = None\n        best_balance = float('inf')\n\n        for i in range(len(segments)):\n            segment = segments[i]\n\n            # Calculate potential insertion points\n            for j in range(len(segment)):\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j] if j < len(segment) else segment[0]\n\n                # Calculate current and potential costs\n                current_cost1 = distance_matrix_1[prev_node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, next_node]\n\n                new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                current_balance = abs(current_cost1 - current_cost2)\n                new_balance = abs(new_cost1 - new_cost2)\n\n                if new_balance < best_balance:\n                    best_balance = new_balance\n                    best_segment = i\n                    best_position = j\n\n        if best_segment is not None:\n            segments[best_segment].insert(best_position, node)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for segment in segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, named \"Multi-Objective Segment Fusion with Adaptive Node Fusion and Objective-Weighted Reallocation,\" builds upon the segment-based approach but introduces a fundamentally different strategy by first identifying and fusing the most complementary segments from different solutions in the archive, then adaptively fusing nodes based on their cross-dimensional contribution scores, followed by an objective-weighted reallocation phase that probabilistically reorders segments to explore alternative configurations, while dynamically adjusting the fusion and reallocation parameters based on the current solution's objective balance, and ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on cross-dimensional contribution\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        total_cost = cost1 + cost2\n\n        if total_cost > 1.5 * (cost1 + cost2) / 2:  # High cross-dimensional variance\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive node fusion within segments\n    fused_segments = []\n    for segment in segments:\n        if len(segment) < 3:\n            fused_segments.append(segment)\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Adaptive fusion based on objective balance\n        if cost1 > 1.3 * cost2:\n            # Merge nodes with similar contribution to objective 1\n            fused_segment = []\n            i = 0\n            while i < len(segment):\n                if i + 1 < len(segment):\n                    node1 = segment[i]\n                    node2 = segment[i+1]\n                    contrib1 = distance_matrix_1[segment[i-1], node1] + distance_matrix_1[node1, node2]\n                    contrib2 = distance_matrix_1[segment[i-1], node2] + distance_matrix_1[node2, segment[i+2] if i+2 < len(segment) else segment[0]]\n\n                    if abs(contrib1 - contrib2) < 0.1 * (contrib1 + contrib2):\n                        fused_segment.append(node1)\n                        i += 2\n                    else:\n                        fused_segment.append(node1)\n                        i += 1\n                else:\n                    fused_segment.append(segment[i])\n                    i += 1\n            fused_segments.append(fused_segment)\n        else:\n            fused_segments.append(segment)\n\n    # Step 4: Objective-weighted segment reallocation\n    if len(fused_segments) > 1:\n        for i in range(len(fused_segments)):\n            if len(fused_segments[i]) < 2:\n                continue\n\n            cost1 = sum(distance_matrix_1[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n            cost2 = sum(distance_matrix_2[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n\n            if cost1 > 1.2 * cost2:\n                if random.random() < 0.5:\n                    # Reallocate nodes to better balance objectives\n                    segment = fused_segments[i]\n                    new_segment = []\n                    for j in range(len(segment)):\n                        node = segment[j]\n                        prev_node = segment[j-1] if j > 0 else segment[-1]\n                        next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                        if cost1 > 1.2 * cost2:\n                            # Find better node to replace with\n                            candidates = [k for k in range(len(instance)) if k not in segment]\n                            if candidates:\n                                best_node = None\n                                best_score = float('inf')\n                                for candidate in candidates:\n                                    new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                                    new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                                    score = abs(new_cost1 - new_cost2)\n                                    if score < best_score:\n                                        best_score = score\n                                        best_node = candidate\n                                if best_node is not None:\n                                    new_segment.append(best_node)\n                                else:\n                                    new_segment.append(node)\n                        else:\n                            new_segment.append(node)\n                    fused_segments[i] = new_segment\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, named \"Objective-Balanced Node Diffusion with Adaptive Multi-Dimensional Rebalancing,\" fundamentally departs from both previous approaches by first identifying critical nodes through a novel multi-dimensional diffusion analysis that evaluates each node's influence across both objectives using a combined centrality metric, then dynamically redistributes these nodes through an adaptive diffusion process that probabilistically spreads nodes based on their current objective imbalance while maintaining feasibility through a dynamic neighborhood validation mechanism that ensures node uniqueness and circularity, and finally refines the solution through an adaptive objective-balancing strategy that iteratively reallocates nodes between objectives based on their current contribution ratios, dynamically adjusting the diffusion and balancing parameters during the process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Calculate node diffusion scores\n    diffusion_scores = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1) % n]\n\n        # Calculate current contributions\n        contrib1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        contrib2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Calculate potential contributions if moved\n        potential_contrib1 = distance_matrix_1[prev_node, next_node]\n        potential_contrib2 = distance_matrix_2[prev_node, next_node]\n\n        # Diffusion score combines both objectives\n        diffusion_score = (contrib1 + contrib2) - (potential_contrib1 + potential_contrib2)\n        diffusion_scores.append((node, diffusion_score))\n\n    # Step 3: Sort nodes by diffusion score\n    diffusion_scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Step 4: Dynamic node diffusion\n    diffused_nodes = []\n    remaining_nodes = set(range(n))\n    for node, score in diffusion_scores:\n        if node in remaining_nodes:\n            # Find best diffusion position\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(diffused_nodes)):\n                prev_node = diffused_nodes[i-1] if i > 0 else diffused_nodes[-1]\n                next_node = diffused_nodes[i]\n\n                # Calculate current contribution\n                current_contrib = (distance_matrix_1[prev_node, next_node] +\n                                 distance_matrix_2[prev_node, next_node])\n\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                             distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n                # Score based on improvement in both objectives\n                score_diff = new_contrib - current_contrib\n\n                if score_diff < best_score:\n                    best_score = score_diff\n                    best_pos = i\n\n            if best_pos != -1:\n                diffused_nodes.insert(best_pos, node)\n                remaining_nodes.remove(node)\n\n    # Add remaining nodes\n    diffused_nodes.extend(list(remaining_nodes))\n\n    # Step 5: Adaptive objective balancing\n    for _ in range(5):  # Perform 5 balancing steps\n        i = random.randint(0, len(diffused_nodes)-1)\n        j = random.randint(0, len(diffused_nodes)-1)\n        if i != j:\n            # Calculate current cost\n            prev_i = diffused_nodes[i-1] if i > 0 else diffused_nodes[-1]\n            next_i = diffused_nodes[(i+1) % len(diffused_nodes)]\n            prev_j = diffused_nodes[j-1] if j > 0 else diffused_nodes[-1]\n            next_j = diffused_nodes[(j+1) % len(diffused_nodes)]\n\n            current_cost1 = distance_matrix_1[prev_i, diffused_nodes[i]] + distance_matrix_1[diffused_nodes[i], next_i]\n            current_cost2 = distance_matrix_2[prev_i, diffused_nodes[i]] + distance_matrix_2[diffused_nodes[i], next_i]\n            current_cost1 += distance_matrix_1[prev_j, diffused_nodes[j]] + distance_matrix_1[diffused_nodes[j], next_j]\n            current_cost2 += distance_matrix_2[prev_j, diffused_nodes[j]] + distance_matrix_2[diffused_nodes[j], next_j]\n\n            # Calculate potential cost with swapped nodes\n            new_cost1 = distance_matrix_1[prev_i, diffused_nodes[j]] + distance_matrix_1[diffused_nodes[j], next_i]\n            new_cost2 = distance_matrix_2[prev_i, diffused_nodes[j]] + distance_matrix_2[diffused_nodes[j], next_i]\n            new_cost1 += distance_matrix_1[prev_j, diffused_nodes[i]] + distance_matrix_1[diffused_nodes[i], next_j]\n            new_cost2 += distance_matrix_2[prev_j, diffused_nodes[i]] + distance_matrix_2[diffused_nodes[i], next_j]\n\n            # Accept swap if it improves the balance\n            if abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2):\n                diffused_nodes[i], diffused_nodes[j] = diffused_nodes[j], diffused_nodes[i]\n\n    # Step 6: Reconstruct solution and validate\n    if diffused_nodes[0] != diffused_nodes[-1]:\n        diffused_nodes.append(diffused_nodes[0])\n\n    # Ensure circular tour and no duplicates\n    unique_nodes = np.unique(diffused_nodes[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random shuffle\n        diffused_nodes = list(range(n))\n        random.shuffle(diffused_nodes)\n        diffused_nodes.append(diffused_nodes[0])\n\n    return np.array(diffused_nodes)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 302,
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Segment Harmonization with Dynamic Objective Fusion and Adaptive Path Realignment,\" fundamentally diverges from previous approaches by first identifying and harmonizing segments across both objective spaces using a novel cross-dimensional segment matching strategy that aligns segments based on their complementary contributions to each objective, then dynamically fuses these segments through an adaptive objective fusion process that probabilistically merges segments based on their current imbalance while maintaining feasibility through a dynamic path realignment mechanism that ensures node uniqueness and circularity, and finally refines the solution through an adaptive path realignment strategy that iteratively reorders segments based on their cross-dimensional contribution scores while dynamically adjusting the fusion and realignment parameters during the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify cross-dimensional segments\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate cross-dimensional contribution\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        balance = abs(cost1 - cost2) / (cost1 + cost2 + 1e-10)\n\n        if balance > 0.3:  # High imbalance, potential segment boundary\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Ensure at least two segments\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic objective fusion\n    fused_segments = []\n    for i in range(len(segments)):\n        if len(segments[i]) < 2:\n            fused_segments.append(segments[i])\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n        cost2 = sum(distance_matrix_2[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n\n        # Find complementary segment\n        best_match = None\n        best_score = float('inf')\n        for j in range(len(segments)):\n            if i == j or len(segments[j]) < 2:\n                continue\n\n            match_cost1 = sum(distance_matrix_1[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1))\n            match_cost2 = sum(distance_matrix_2[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1))\n\n            # Score based on complementary contributions\n            score = abs((cost1 + match_cost2) - (cost2 + match_cost1))\n            if score < best_score:\n                best_score = score\n                best_match = j\n\n        if best_match is not None and random.random() < 0.7:\n            # Merge segments\n            fused_segment = segments[i] + segments[best_match]\n            fused_segments.append(fused_segment)\n            segments[best_match] = []  # Mark as used\n        else:\n            fused_segments.append(segments[i])\n\n    # Step 4: Adaptive path realignment\n    for i in range(len(fused_segments)):\n        if len(fused_segments[i]) < 3:\n            continue\n\n        segment = fused_segments[i]\n        improved = True\n        while improved:\n            improved = False\n            for j in range(len(segment)-2):\n                a, b, c = segment[j], segment[j+1], segment[j+2]\n\n                # Calculate current cost\n                current_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n                current_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n\n                # Calculate potential cost with inversion\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n\n                # Accept if better balance\n                if abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2):\n                    segment[j+1], segment[j+2] = segment[j+2], segment[j+1]\n                    improved = True\n                    break\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        if len(segment) > 0:\n            new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random shuffle\n        new_solution = list(range(n))\n        random.shuffle(new_solution)\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.783583603373299,
               0.7754607796669006
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify cross-dimensional segments\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate cross-dimensional contribution\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        balance = abs(cost1 - cost2) / (cost1 + cost2 + 1e-10)\n\n        if balance > 0.3:  # High imbalance, potential segment boundary\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Ensure at least two segments\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic objective fusion\n    fused_segments = []\n    for i in range(len(segments)):\n        if len(segments[i]) < 2:\n            fused_segments.append(segments[i])\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n        cost2 = sum(distance_matrix_2[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n\n        # Find complementary segment\n        best_match = None\n        best_score = float('inf')\n        for j in range(len(segments)):\n            if i == j or len(segments[j]) < 2:\n                continue\n\n            match_cost1 = sum(distance_matrix_1[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1))\n            match_cost2 = sum(distance_matrix_2[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1))\n\n            # Score based on complementary contributions\n            score = abs((cost1 + match_cost2) - (cost2 + match_cost1))\n            if score < best_score:\n                best_score = score\n                best_match = j\n\n        if best_match is not None and random.random() < 0.7:\n            # Merge segments\n            fused_segment = segments[i] + segments[best_match]\n            fused_segments.append(fused_segment)\n            segments[best_match] = []  # Mark as used\n        else:\n            fused_segments.append(segments[i])\n\n    # Step 4: Adaptive path realignment\n    for i in range(len(fused_segments)):\n        if len(fused_segments[i]) < 3:\n            continue\n\n        segment = fused_segments[i]\n        improved = True\n        while improved:\n            improved = False\n            for j in range(len(segment)-2):\n                a, b, c = segment[j], segment[j+1], segment[j+2]\n\n                # Calculate current cost\n                current_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n                current_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n\n                # Calculate potential cost with inversion\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n\n                # Accept if better balance\n                if abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2):\n                    segment[j+1], segment[j+2] = segment[j+2], segment[j+1]\n                    improved = True\n                    break\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        if len(segment) > 0:\n            new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random shuffle\n        new_solution = list(range(n))\n        random.shuffle(new_solution)\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, named \"Adaptive Objective-Centric Tour Decomposition with Cross-Objective Segment Fusion,\" builds upon the common backbone of solution selection and tour decomposition from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective-centric\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then fused across objectives using an adaptive strategy that dynamically combines segments from both objectives while maintaining their relative order, followed by a \"cross-objective segment interleaving\" phase that probabilistically interleaves segments from both objectives to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into objective-centric segments\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = None\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if current_obj is None:\n            if cost1 > cost2:\n                current_obj = 1\n            else:\n                current_obj = 2\n            current_segment.append(current_node)\n        else:\n            if (current_obj == 1 and cost1 < cost2 * 0.8) or (current_obj == 2 and cost2 < cost1 * 0.8):\n                segments.append((current_obj, current_segment))\n                current_segment = [current_node]\n                current_obj = 3 - current_obj  # Switch objective\n            else:\n                current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [(1, new_solution[:n//2]), (2, new_solution[n//2:])]\n\n    # Step 3: Cross-objective segment fusion\n    fused_segments = []\n    i = 0\n    while i < len(segments):\n        obj1, seg1 = segments[i]\n        if i + 1 < len(segments):\n            obj2, seg2 = segments[i+1]\n            if obj1 != obj2 and random.random() < 0.5:\n                # Fuse segments from different objectives\n                fused_segment = seg1 + seg2\n                fused_segments.append((obj1, fused_segment))\n                i += 2\n            else:\n                fused_segments.append((obj1, seg1))\n                i += 1\n        else:\n            fused_segments.append((obj1, seg1))\n            i += 1\n\n    # Step 4: Cross-objective segment interleaving\n    if len(fused_segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in fused_segments if obj == 1]\n        obj2_segments = [seg for obj, seg in fused_segments if obj == 2]\n\n        # Interleave segments from both objectives\n        new_solution = []\n        i, j = 0, 0\n        while i < len(obj1_segments) or j < len(obj2_segments):\n            if i < len(obj1_segments) and (j >= len(obj2_segments) or random.random() < 0.5):\n                new_solution.extend(obj1_segments[i])\n                i += 1\n            else:\n                new_solution.extend(obj2_segments[j])\n                j += 1\n\n    # Step 5: Reconstruct solution and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            _, seg = fused_segments[i]\n            fused_segments[i] = (3 - fused_segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in fused_segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 303,
          "algorithm": "{The new algorithm, named \"Objective-Driven Dynamic Path Reconstruction with Cross-Objective Node Migration,\" departs from traditional segment-based approaches by first constructing a dynamic objective-driven backbone by identifying the most critical nodes in each objective space through a novel \"objective dominance\" metric, then progressively reconstructing the path by migrating nodes between objectives in a controlled manner using a \"cross-objective node migration\" strategy that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through an adaptive validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines dynamic backbone construction with controlled node migration, allowing for both fine-grained local improvements and more disruptive global explorations while dynamically adjusting the migration parameters based on the current solution's objective balance.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify objective dominance for each node\n    dominance_scores = np.zeros(n)\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n        dominance_scores[i] = cost1 - cost2\n\n    # Step 3: Construct dynamic backbone by selecting nodes with highest dominance\n    backbone_indices = np.argsort(np.abs(dominance_scores))[::-1][:n//2]\n    backbone_nodes = [new_solution[i] for i in backbone_indices]\n\n    # Step 4: Cross-objective node migration\n    remaining_nodes = [node for i, node in enumerate(new_solution) if i not in backbone_indices]\n    for _ in range(3):  # Perform 3 migrations\n        if not remaining_nodes:\n            break\n\n        # Select a random node to migrate\n        node = random.choice(remaining_nodes)\n\n        # Find the best position to insert the node\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(backbone_nodes)):\n            prev_node = backbone_nodes[i-1] if i > 0 else backbone_nodes[-1]\n            next_node = backbone_nodes[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            backbone_nodes.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = backbone_nodes + remaining_nodes\n    if len(new_solution) != n:\n        new_solution = new_solution[:n]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8706865602725011,
               0.4580368995666504
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify objective dominance for each node\n    dominance_scores = np.zeros(n)\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n        dominance_scores[i] = cost1 - cost2\n\n    # Step 3: Construct dynamic backbone by selecting nodes with highest dominance\n    backbone_indices = np.argsort(np.abs(dominance_scores))[::-1][:n//2]\n    backbone_nodes = [new_solution[i] for i in backbone_indices]\n\n    # Step 4: Cross-objective node migration\n    remaining_nodes = [node for i, node in enumerate(new_solution) if i not in backbone_indices]\n    for _ in range(3):  # Perform 3 migrations\n        if not remaining_nodes:\n            break\n\n        # Select a random node to migrate\n        node = random.choice(remaining_nodes)\n\n        # Find the best position to insert the node\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(backbone_nodes)):\n            prev_node = backbone_nodes[i-1] if i > 0 else backbone_nodes[-1]\n            next_node = backbone_nodes[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            backbone_nodes.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = backbone_nodes + remaining_nodes\n    if len(new_solution) != n:\n        new_solution = new_solution[:n]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, named \"Adaptive Objective-Centric Tour Decomposition with Cross-Objective Segment Fusion,\" builds upon the common backbone of solution selection and tour decomposition from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective-centric\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then fused across objectives using an adaptive strategy that dynamically combines segments from both objectives while maintaining their relative order, followed by a \"cross-objective segment interleaving\" phase that probabilistically interleaves segments from both objectives to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into objective-centric segments\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = None\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if current_obj is None:\n            if cost1 > cost2:\n                current_obj = 1\n            else:\n                current_obj = 2\n            current_segment.append(current_node)\n        else:\n            if (current_obj == 1 and cost1 < cost2 * 0.8) or (current_obj == 2 and cost2 < cost1 * 0.8):\n                segments.append((current_obj, current_segment))\n                current_segment = [current_node]\n                current_obj = 3 - current_obj  # Switch objective\n            else:\n                current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [(1, new_solution[:n//2]), (2, new_solution[n//2:])]\n\n    # Step 3: Cross-objective segment fusion\n    fused_segments = []\n    i = 0\n    while i < len(segments):\n        obj1, seg1 = segments[i]\n        if i + 1 < len(segments):\n            obj2, seg2 = segments[i+1]\n            if obj1 != obj2 and random.random() < 0.5:\n                # Fuse segments from different objectives\n                fused_segment = seg1 + seg2\n                fused_segments.append((obj1, fused_segment))\n                i += 2\n            else:\n                fused_segments.append((obj1, seg1))\n                i += 1\n        else:\n            fused_segments.append((obj1, seg1))\n            i += 1\n\n    # Step 4: Cross-objective segment interleaving\n    if len(fused_segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in fused_segments if obj == 1]\n        obj2_segments = [seg for obj, seg in fused_segments if obj == 2]\n\n        # Interleave segments from both objectives\n        new_solution = []\n        i, j = 0, 0\n        while i < len(obj1_segments) or j < len(obj2_segments):\n            if i < len(obj1_segments) and (j >= len(obj2_segments) or random.random() < 0.5):\n                new_solution.extend(obj1_segments[i])\n                i += 1\n            else:\n                new_solution.extend(obj2_segments[j])\n                j += 1\n\n    # Step 5: Reconstruct solution and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            _, seg = fused_segments[i]\n            fused_segments[i] = (3 - fused_segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in fused_segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, named \"Objective-Driven Hybrid Segment Fusion with Dynamic Node Rebalancing,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first identifying and fusing the most complementary segments from different solutions in the archive, then dynamically rebalancing the tour by selectively replacing nodes based on their cross-dimensional contribution scores. This method combines segment fusion with a novel node replacement mechanism that evaluates each node's potential to improve both objectives simultaneously, using a probabilistic acceptance criterion that considers both immediate improvement and long-term solution balance, while maintaining tour feasibility through a two-phase validation process that checks both segment connectivity and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the best segments from different solutions\n    best_segments = []\n    for solution, _ in archive[:3]:  # Consider top 3 solutions\n        n = len(solution)\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = solution[i:i+segment_length]\n            if len(segment) > 1:\n                best_segments.append(segment)\n\n    if not best_segments:\n        best_segments = [archive[0][0][:3]]\n\n    # Step 2: Create initial solution by combining complementary segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in best_segments:\n        new_solution.extend(seg)\n        for node in seg:\n            remaining_nodes.discard(node)\n\n    # Step 3: Dynamic node rebalancing\n    for _ in range(3):  # Perform 3 rebalancing iterations\n        for i in range(len(new_solution)):\n            node = new_solution[i]\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i+1] if i < len(new_solution)-1 else new_solution[0]\n\n            # Calculate current contribution to both objectives\n            current_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Find potential replacement nodes\n            candidates = list(remaining_nodes)\n            if not candidates:\n                break\n\n            for candidate in candidates:\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node] +\n                              distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node])\n\n                # Accept if improvement in both objectives\n                if new_contrib < current_contrib * 0.95:  # 5% improvement threshold\n                    new_solution[i] = candidate\n                    remaining_nodes.add(node)\n                    remaining_nodes.remove(candidate)\n                    break\n\n    # Step 4: Insert remaining nodes\n    remaining_nodes = list(remaining_nodes)\n    while remaining_nodes:\n        best_node = None\n        best_pos = -1\n        best_score = float('inf')\n\n        for node in remaining_nodes:\n            for i in range(len(new_solution)):\n                if i == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[i-1]\n                    next_node = new_solution[i]\n\n                score = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_pos = i\n\n        if best_node is not None:\n            new_solution.insert(best_pos, best_node)\n            remaining_nodes.remove(best_node)\n        else:\n            new_solution.extend(remaining_nodes)\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == len(instance), \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one long, detail sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 304,
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Centric Path Realignment with Multi-Dimensional Segment Recombination,\" builds upon the common backbone of solution decomposition and segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first identifying critical path segments that exhibit significant imbalance between objectives, then realigning these segments through a multi-dimensional segment recombination process that dynamically balances the contributions of both objectives while maintaining tour feasibility through a probabilistic segment validation mechanism that ensures node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify critical path segments with significant objective imbalance\n    segments = []\n    current_segment = [new_solution[0]]\n    imbalance_threshold = 1.5  # Factor to determine significant imbalance\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if cost1 > imbalance_threshold * cost2 or cost2 > imbalance_threshold * cost1:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 3: Multi-dimensional segment recombination\n    if len(segments) > 1:\n        # Randomly select two segments to recombine\n        i, j = random.sample(range(len(segments)), 2)\n        seg1, seg2 = segments[i], segments[j]\n\n        # Recombine segments by alternating nodes\n        recombined = []\n        len1, len2 = len(seg1), len(seg2)\n        for k in range(max(len1, len2)):\n            if k < len1:\n                recombined.append(seg1[k])\n            if k < len2:\n                recombined.append(seg2[k])\n\n        # Replace the original segments with the recombined one\n        segments[i] = recombined\n        segments.pop(j)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for seg in segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8953752353717941,
               0.12600034475326538
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify critical path segments with significant objective imbalance\n    segments = []\n    current_segment = [new_solution[0]]\n    imbalance_threshold = 1.5  # Factor to determine significant imbalance\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if cost1 > imbalance_threshold * cost2 or cost2 > imbalance_threshold * cost1:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 3: Multi-dimensional segment recombination\n    if len(segments) > 1:\n        # Randomly select two segments to recombine\n        i, j = random.sample(range(len(segments)), 2)\n        seg1, seg2 = segments[i], segments[j]\n\n        # Recombine segments by alternating nodes\n        recombined = []\n        len1, len2 = len(seg1), len(seg2)\n        for k in range(max(len1, len2)):\n            if k < len1:\n                recombined.append(seg1[k])\n            if k < len2:\n                recombined.append(seg2[k])\n\n        # Replace the original segments with the recombined one\n        segments[i] = recombined\n        segments.pop(j)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for seg in segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 1 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, named \"Adaptive Multi-Objective Segment Fusion with Dynamic Objective-Weighted Node Replacement,\" builds upon the common segment-based approach from the provided algorithms but introduces a fundamentally different mechanism by first adaptively identifying the most complementary segments from different solutions in the archive, then dynamically fusing and rebalancing these segments through an objective-weighted node replacement process that evaluates each node's potential contribution to both objectives using a probabilistic acceptance criterion that balances immediate improvement with long-term solution balance, while maintaining tour feasibility through a two-phase validation process that ensures both segment connectivity and node uniqueness, and dynamically adjusts the fusion and replacement parameters based on the current solution's objective balance and the distribution of nodes in the two objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify critical segments based on cross-dimensional variance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        variance = abs(cost1 - cost2)\n\n        if variance > 0.5 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 3: Adaptive segment fusion with dynamic objective weighting\n    fused_segments = []\n    for i in range(len(segments)):\n        if len(segments[i]) < 2:\n            fused_segments.append(segments[i])\n            continue\n\n        segment = segments[i]\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Determine fusion strategy based on objective balance\n        if cost1 > 1.2 * cost2:\n            # Prioritize objective 2\n            for j in range(len(segment)):\n                node = segment[j]\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if current_cost2 > 1.2 * current_cost1:\n                    # Find better node to replace with\n                    candidates = [k for k in range(len(instance)) if k not in segment]\n                    if candidates:\n                        best_node = None\n                        best_score = float('inf')\n                        for candidate in candidates:\n                            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                            score = abs(new_cost1 - new_cost2)\n                            if score < best_score:\n                                best_score = score\n                                best_node = candidate\n                        if best_node is not None:\n                            segment[j] = best_node\n        else:\n            # Prioritize objective 1\n            for j in range(len(segment)):\n                node = segment[j]\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if current_cost1 > 1.2 * current_cost2:\n                    # Find better node to replace with\n                    candidates = [k for k in range(len(instance)) if k not in segment]\n                    if candidates:\n                        best_node = None\n                        best_score = float('inf')\n                        for candidate in candidates:\n                            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                            score = abs(new_cost1 - new_cost2)\n                            if score < best_score:\n                                best_score = score\n                                best_node = candidate\n                        if best_node is not None:\n                            segment[j] = best_node\n\n        fused_segments.append(segment)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 305,
          "algorithm": "{The new algorithm, named \"Multi-Objective Path Rebalancing with Adaptive Segment Reconfiguration,\" departs entirely from the existing approaches by first identifying critical path segments through a multi-dimensional clustering analysis that considers both objective spaces simultaneously, then dynamically reconfigures these segments using a probabilistic segment swapping mechanism that evaluates potential neighbors based on their Pareto dominance in the objective space, while maintaining tour feasibility through a constraint-aware segment merging process that ensures both segment connectivity and node uniqueness, and adaptively adjusts the reconfiguration parameters based on the current solution's objective balance and the spatial distribution of nodes in the two objective spaces, ultimately producing a neighbor solution that balances both objectives through a novel segment fusion criterion that prioritizes solutions with improved objective trade-offs while preserving the overall tour structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with the most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify critical path segments through multi-dimensional clustering\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate combined cost variance\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        variance = abs(cost1 - cost2)\n\n        # Segment split condition based on combined variance\n        if variance > 0.3 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 3: Dynamic segment reconfiguration with probabilistic swapping\n    if len(segments) > 1:\n        # Randomly select two segments to swap\n        i, j = random.sample(range(len(segments)), 2)\n\n        # Check if swapping would maintain feasibility\n        if len(segments[i]) > 1 and len(segments[j]) > 1:\n            # Perform the swap\n            segments[i], segments[j] = segments[j], segments[i]\n\n    # Step 4: Reconstruct solution with constraint-aware merging\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    # Ensure tour completeness\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for segment in segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9779894264627746,
               0.11751526594161987
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with the most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify critical path segments through multi-dimensional clustering\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate combined cost variance\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        variance = abs(cost1 - cost2)\n\n        # Segment split condition based on combined variance\n        if variance > 0.3 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 3: Dynamic segment reconfiguration with probabilistic swapping\n    if len(segments) > 1:\n        # Randomly select two segments to swap\n        i, j = random.sample(range(len(segments)), 2)\n\n        # Check if swapping would maintain feasibility\n        if len(segments[i]) > 1 and len(segments[j]) > 1:\n            # Perform the swap\n            segments[i], segments[j] = segments[j], segments[i]\n\n    # Step 4: Reconstruct solution with constraint-aware merging\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    # Ensure tour completeness\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for segment in segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
     },
     {
          "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm, named \"Objective-Driven Hybrid Segment Fusion with Dynamic Node Rebalancing,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first identifying and fusing the most complementary segments from different solutions in the archive, then dynamically rebalancing the tour by selectively replacing nodes based on their cross-dimensional contribution scores. This method combines segment fusion with a novel node replacement mechanism that evaluates each node's potential to improve both objectives simultaneously, using a probabilistic acceptance criterion that considers both immediate improvement and long-term solution balance, while maintaining tour feasibility through a two-phase validation process that checks both segment connectivity and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the best segments from different solutions\n    best_segments = []\n    for solution, _ in archive[:3]:  # Consider top 3 solutions\n        n = len(solution)\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = solution[i:i+segment_length]\n            if len(segment) > 1:\n                best_segments.append(segment)\n\n    if not best_segments:\n        best_segments = [archive[0][0][:3]]\n\n    # Step 2: Create initial solution by combining complementary segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in best_segments:\n        new_solution.extend(seg)\n        for node in seg:\n            remaining_nodes.discard(node)\n\n    # Step 3: Dynamic node rebalancing\n    for _ in range(3):  # Perform 3 rebalancing iterations\n        for i in range(len(new_solution)):\n            node = new_solution[i]\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i+1] if i < len(new_solution)-1 else new_solution[0]\n\n            # Calculate current contribution to both objectives\n            current_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Find potential replacement nodes\n            candidates = list(remaining_nodes)\n            if not candidates:\n                break\n\n            for candidate in candidates:\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node] +\n                              distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node])\n\n                # Accept if improvement in both objectives\n                if new_contrib < current_contrib * 0.95:  # 5% improvement threshold\n                    new_solution[i] = candidate\n                    remaining_nodes.add(node)\n                    remaining_nodes.remove(candidate)\n                    break\n\n    # Step 4: Insert remaining nodes\n    remaining_nodes = list(remaining_nodes)\n    while remaining_nodes:\n        best_node = None\n        best_pos = -1\n        best_score = float('inf')\n\n        for node in remaining_nodes:\n            for i in range(len(new_solution)):\n                if i == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[i-1]\n                    next_node = new_solution[i]\n\n                score = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_pos = i\n\n        if best_node is not None:\n            new_solution.insert(best_pos, best_node)\n            remaining_nodes.remove(best_node)\n        else:\n            new_solution.extend(remaining_nodes)\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == len(instance), \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
          "sample_order": 306,
          "algorithm": "{The new algorithm, named \"Adaptive Multi-Objective Path Reconstruction with Geometric Harmony,\" fundamentally departs from both previous approaches by first constructing a geometric harmony map that combines the spatial relationships from both objective spaces through a novel weighted Voronoi tessellation, then uses this map to guide the reconstruction of the tour by sequentially placing nodes based on their geometric compatibility and cross-dimensional contribution scores, while maintaining feasibility through a dynamic segment validation mechanism that ensures both node uniqueness and circularity. This method uniquely integrates geometric spatial analysis with multi-objective optimization, creating a novel balance between local and global improvements through an adaptive reconstruction process that dynamically adjusts the tour structure based on the geometric properties of the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on geometric harmony potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = []\n    n = len(base_solution)\n\n    # Step 1: Create geometric harmony map\n    coordinates = instance\n    points1 = coordinates[:, :2]\n    points2 = coordinates[:, 2:]\n\n    # Calculate centroids for each space\n    centroid1 = np.mean(points1, axis=0)\n    centroid2 = np.mean(points2, axis=0)\n\n    # Create weighted Voronoi tessellation\n    weights = np.array([np.linalg.norm(points1[i] - centroid1) + np.linalg.norm(points2[i] - centroid2) for i in range(n)])\n    weighted_points = np.hstack([points1, points2, weights.reshape(-1, 1)])\n\n    # Step 2: Reconstruct tour based on geometric harmony\n    remaining_nodes = set(range(n))\n    current_node = base_solution[0]\n    new_solution.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    while len(new_solution) < n:\n        best_node = None\n        best_score = float('inf')\n\n        for candidate in remaining_nodes:\n            # Calculate geometric harmony score\n            geo_score = (np.linalg.norm(points1[candidate] - points1[current_node]) +\n                         np.linalg.norm(points2[candidate] - points2[current_node]))\n\n            # Calculate multi-objective contribution\n            contrib_score = (distance_matrix_1[current_node, candidate] +\n                            distance_matrix_2[current_node, candidate])\n\n            # Combined score\n            total_score = geo_score + contrib_score\n\n            if total_score < best_score:\n                best_score = total_score\n                best_node = candidate\n\n        if best_node is not None:\n            new_solution.append(best_node)\n            remaining_nodes.remove(best_node)\n            current_node = best_node\n        else:\n            # Fallback: add remaining nodes randomly\n            new_solution.extend(list(remaining_nodes))\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8966750939932497,
               10.396514773368835
          ],
          "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on geometric harmony potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = []\n    n = len(base_solution)\n\n    # Step 1: Create geometric harmony map\n    coordinates = instance\n    points1 = coordinates[:, :2]\n    points2 = coordinates[:, 2:]\n\n    # Calculate centroids for each space\n    centroid1 = np.mean(points1, axis=0)\n    centroid2 = np.mean(points2, axis=0)\n\n    # Create weighted Voronoi tessellation\n    weights = np.array([np.linalg.norm(points1[i] - centroid1) + np.linalg.norm(points2[i] - centroid2) for i in range(n)])\n    weighted_points = np.hstack([points1, points2, weights.reshape(-1, 1)])\n\n    # Step 2: Reconstruct tour based on geometric harmony\n    remaining_nodes = set(range(n))\n    current_node = base_solution[0]\n    new_solution.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    while len(new_solution) < n:\n        best_node = None\n        best_score = float('inf')\n\n        for candidate in remaining_nodes:\n            # Calculate geometric harmony score\n            geo_score = (np.linalg.norm(points1[candidate] - points1[current_node]) +\n                         np.linalg.norm(points2[candidate] - points2[current_node]))\n\n            # Calculate multi-objective contribution\n            contrib_score = (distance_matrix_1[current_node, candidate] +\n                            distance_matrix_2[current_node, candidate])\n\n            # Combined score\n            total_score = geo_score + contrib_score\n\n            if total_score < best_score:\n                best_score = total_score\n                best_node = candidate\n\n        if best_node is not None:\n            new_solution.append(best_node)\n            remaining_nodes.remove(best_node)\n            current_node = best_node\n        else:\n            # Fallback: add remaining nodes randomly\n            new_solution.extend(list(remaining_nodes))\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n"
     }
]