[
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies an \"adaptive k-opt\" local search that dynamically selects between 2-opt and 3-opt moves based on the current solution's characteristics, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    obj1_std = np.std(obj1_values)\n    obj2_std = np.std(obj2_values)\n    diversity_scores = [(obj1_values[i] / obj1_std) + (obj2_values[i] / obj2_std) for i in range(len(objectives))]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt local search\n    if n > 3:\n        # Randomly select between 2-opt and 3-opt\n        k_opt_type = random.choice([2, 3])\n\n        if k_opt_type == 2:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_1[new_solution[i], new_solution[j]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_2[new_solution[i], new_solution[j]])\n\n                improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n                if improvement < 0:\n                    # Reverse the segment between i and j-1\n                    new_solution[i:j] = new_solution[i:j][::-1]\n\n        else:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            if j - i > 1 and k - j > 1:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_1[new_solution[i], new_solution[k-1]] +\n                             distance_matrix_1[new_solution[j], new_solution[k]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_2[new_solution[i], new_solution[k-1]] +\n                             distance_matrix_2[new_solution[j], new_solution[k]])\n\n                improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n                if improvement < 0:\n                    # Apply the 3-opt move\n                    new_solution[i:j] = new_solution[i:j][::-1]\n                    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0351249330946433,
            0.5475942492485046
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion\" local search that inverts contiguous segments of the tour while considering both objective spaces to balance improvements across both dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Select two distinct random positions\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = min(3, n - b - 1)  # Limit segment length to 3 for practicality\n\n        # Determine inversion range\n        start = a\n        end = b + segment_length\n\n        # Calculate old and new costs for both objectives\n        old_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        new_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.032172648026389,
            0.3723459243774414
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating its potential for improvement, then applies a hybrid local search combining 2-opt with a novel node reinsertion strategy to explore non-dominated regions, ensuring feasibility by validating the tour structure before returning the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt with node reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt move\n\n    # Node reinsertion\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0066041589623453,
            0.06425052881240845
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    }
]