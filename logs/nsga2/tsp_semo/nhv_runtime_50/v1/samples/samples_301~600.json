[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This novel algorithm combines adaptive multi-segment reversal with dynamic hub-and-spoke node reallocation, where it intelligently reverses multiple non-overlapping segments of the tour while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    num_segments = max(2, min(4, n // 5))\n\n    # Adaptive multi-segment reversal\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Reverse segments with probability based on their combined objective impact\n    for i in range(len(segments)):\n        seg_cost1 = sum(distance_matrix_1[segments[i][j-1], segments[i][j]] for j in range(1, len(segments[i])))\n        seg_cost2 = sum(distance_matrix_2[segments[i][j-1], segments[i][j]] for j in range(1, len(segments[i])))\n        seg_total = seg_cost1 + seg_cost2\n\n        if random.random() < 0.5 * (1 - min(seg_total / (n * 100), 0.9)):  # Higher probability for worse segments\n            segments[i] = segments[i][::-1]\n\n    # Reconstruct the solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Dynamic hub-and-spoke node reallocation\n    for _ in range(2):\n        # Select a hub node (potential center of the tour)\n        hub = random.randint(0, n - 1)\n        hub_node = new_solution[hub]\n\n        # Find nodes that are close to the hub in both objective spaces\n        close_nodes = []\n        for i in range(n):\n            if i != hub:\n                dist1 = distance_matrix_1[hub_node, new_solution[i]]\n                dist2 = distance_matrix_2[hub_node, new_solution[i]]\n                if dist1 + dist2 < (distance_matrix_1.mean() + distance_matrix_2.mean()) * 0.7:\n                    close_nodes.append(i)\n\n        if len(close_nodes) >= 2:\n            # Reallocate nodes around the hub\n            selected = sorted(random.sample(close_nodes, min(3, len(close_nodes))))\n            for i in range(len(selected)):\n                new_solution[selected[i]], new_solution[(hub + i + 1) % n] = new_solution[(hub + i + 1) % n], new_solution[selected[i]]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8099462588717014,
            1.7183440327644348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    num_segments = max(2, min(4, n // 5))\n\n    # Adaptive multi-segment reversal\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Reverse segments with probability based on their combined objective impact\n    for i in range(len(segments)):\n        seg_cost1 = sum(distance_matrix_1[segments[i][j-1], segments[i][j]] for j in range(1, len(segments[i])))\n        seg_cost2 = sum(distance_matrix_2[segments[i][j-1], segments[i][j]] for j in range(1, len(segments[i])))\n        seg_total = seg_cost1 + seg_cost2\n\n        if random.random() < 0.5 * (1 - min(seg_total / (n * 100), 0.9)):  # Higher probability for worse segments\n            segments[i] = segments[i][::-1]\n\n    # Reconstruct the solution from segments\n    new_solution = np.concatenate(segments)\n\n    # Dynamic hub-and-spoke node reallocation\n    for _ in range(2):\n        # Select a hub node (potential center of the tour)\n        hub = random.randint(0, n - 1)\n        hub_node = new_solution[hub]\n\n        # Find nodes that are close to the hub in both objective spaces\n        close_nodes = []\n        for i in range(n):\n            if i != hub:\n                dist1 = distance_matrix_1[hub_node, new_solution[i]]\n                dist2 = distance_matrix_2[hub_node, new_solution[i]]\n                if dist1 + dist2 < (distance_matrix_1.mean() + distance_matrix_2.mean()) * 0.7:\n                    close_nodes.append(i)\n\n        if len(close_nodes) >= 2:\n            # Reallocate nodes around the hub\n            selected = sorted(random.sample(close_nodes, min(3, len(close_nodes))))\n            for i in range(len(selected)):\n                new_solution[selected[i]], new_solution[(hub + i + 1) % n] = new_solution[(hub + i + 1) % n], new_solution[selected[i]]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This novel algorithm uses adaptive multi-objective segment reordering with dynamic node prioritization, where it intelligently reorders segments based on their combined objective impact while strategically prioritizing nodes for insertion using a weighted score function, ensuring feasibility through a comprehensive segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reordering\n    for _ in range(3):\n        # Select a segment to reorder\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Reorder the segment based on combined objective impact\n        reordered_segment = []\n        remaining_nodes = list(segment)\n\n        while remaining_nodes:\n            best_node = None\n            best_score = float('inf')\n\n            for node in remaining_nodes:\n                if not reordered_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = reordered_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                # Weighted score function: prioritize nodes with better combined impact\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = 0.6 * cost1 + 0.4 * cost2  # Different weight for objectives\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            reordered_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = reordered_segment\n\n    # Dynamic node prioritization for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.966630012119219,
            0.6455778479576111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reordering\n    for _ in range(3):\n        # Select a segment to reorder\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Reorder the segment based on combined objective impact\n        reordered_segment = []\n        remaining_nodes = list(segment)\n\n        while remaining_nodes:\n            best_node = None\n            best_score = float('inf')\n\n            for node in remaining_nodes:\n                if not reordered_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = reordered_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                # Weighted score function: prioritize nodes with better combined impact\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = 0.6 * cost1 + 0.4 * cost2  # Different weight for objectives\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            reordered_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = reordered_segment\n\n    # Dynamic node prioritization for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore high-quality solutions in both objective spaces by intelligently reordering nodes while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Randomly select a node to remove and reinsert\n        node_index = random.randint(0, n-1)\n        node = new_solution[node_index]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_index)\n\n        # Find insertion position that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for i in range(n-1):\n            # Try inserting at position i\n            temp_sol = np.insert(new_solution, i, node)\n\n            # Calculate total cost in both objectives\n            cost1 = sum(distance_matrix_1[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path reversal for further refinement\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n-1)\n        end = random.randint(start, min(start+5, n-1))\n\n        if end - start > 1:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7903835868793939,
            9.228606224060059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Randomly select a node to remove and reinsert\n        node_index = random.randint(0, n-1)\n        node = new_solution[node_index]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_index)\n\n        # Find insertion position that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for i in range(n-1):\n            # Try inserting at position i\n            temp_sol = np.insert(new_solution, i, node)\n\n            # Calculate total cost in both objectives\n            cost1 = sum(distance_matrix_1[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path reversal for further refinement\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n-1)\n        end = random.randint(start, min(start+5, n-1))\n\n        if end - start > 1:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    }
]