[
    {
        "algorithm": "{This algorithm selects the most diverse solution from the archive based on the maximum of objectives, then applies a \"segmented crossover\" operator that combines segments from two randomly selected solutions, followed by a \"adaptive reversal\" that reverses segments based on their current position in the tour to explore different configurations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: max(x[1]))\n    base_solution = archive[-1][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(1, len(archive))][0].copy()\n\n        # Segmented crossover\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if crossover causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive reversal\n    if n > 3:\n        reversal_point = np.random.randint(1, n-2)\n        if reversal_point < n//2:\n            new_solution[reversal_point:] = new_solution[reversal_point:][::-1]\n        else:\n            new_solution[:reversal_point] = new_solution[:reversal_point][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9007001667518985,
            0.0945250391960144
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects the most diverse solution from the archive based on the maximum of objectives, then applies a \"segmented crossover\" operator that combines segments from two randomly selected solutions, followed by a \"adaptive reversal\" that reverses segments based on their current position in the tour to explore different configurations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: max(x[1]))\n    base_solution = archive[-1][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(1, len(archive))][0].copy()\n\n        # Segmented crossover\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if crossover causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive reversal\n    if n > 3:\n        reversal_point = np.random.randint(1, n-2)\n        if reversal_point < n//2:\n            new_solution[reversal_point:] = new_solution[reversal_point:][::-1]\n        else:\n            new_solution[:reversal_point] = new_solution[:reversal_point][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9007001667518985,
            0.0945250391960144
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects the most diverse solution from the archive based on the maximum of objectives, then applies a \"segmented crossover\" operator that combines segments from two randomly selected solutions, followed by a \"adaptive reversal\" that reverses segments based on their current position in the tour to explore different configurations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: max(x[1]))\n    base_solution = archive[-1][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(1, len(archive))][0].copy()\n\n        # Segmented crossover\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if crossover causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive reversal\n    if n > 3:\n        reversal_point = np.random.randint(1, n-2)\n        if reversal_point < n//2:\n            new_solution[reversal_point:] = new_solution[reversal_point:][::-1]\n        else:\n            new_solution[:reversal_point] = new_solution[:reversal_point][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9007001667518985,
            0.0945250391960144
        ]
    },
    {
        "algorithm": "{This algorithm selects the most diverse solution from the archive based on the maximum of objectives, then applies a \"segmented crossover\" operator that combines segments from two randomly selected solutions, followed by a \"adaptive reversal\" that reverses segments based on their current position in the tour to explore different configurations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: max(x[1]))\n    base_solution = archive[-1][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(1, len(archive))][0].copy()\n\n        # Segmented crossover\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if crossover causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive reversal\n    if n > 3:\n        reversal_point = np.random.randint(1, n-2)\n        if reversal_point < n//2:\n            new_solution[reversal_point:] = new_solution[reversal_point:][::-1]\n        else:\n            new_solution[:reversal_point] = new_solution[:reversal_point][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9007001667518985,
            0.0945250391960144
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel \"multi-objective segment crossover\" operator that combines segments from multiple solutions in the archive, followed by an \"adaptive segment mutation\" that modifies segments based on their contribution to both objectives, ensuring feasibility while exploring diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives and compute a combined score\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized[:, 0] + normalized[:, 1] - 0.5 * np.std(normalized, axis=1)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment crossover\n    if n > 4 and len(archive) > 1:\n        # Select another solution from archive\n        other_idx = np.random.randint(0, len(archive))\n        while other_idx == selected_idx and len(archive) > 1:\n            other_idx = np.random.randint(0, len(archive))\n        other_solution = archive[other_idx][0]\n\n        # Find segments that contribute differently to each objective\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Find corresponding segment in other solution\n        other_segment = other_solution[np.where(np.isin(other_solution, segment))[0]]\n\n        # Combine segments based on objective contributions\n        combined_segment = np.concatenate([segment, other_segment])\n        combined_segment = np.unique(combined_segment)\n\n        # Insert combined segment at random position\n        insert_pos = np.random.randint(1, n)\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            combined_segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, combined_segment)\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple insertion if duplicates occur\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_end:],\n                segment\n            ])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Adaptive segment mutation\n    if n > 3:\n        # Select segment based on its contribution to both objectives\n        seg_start = np.random.randint(1, n-1)\n        seg_end = np.random.randint(seg_start+1, n)\n\n        # Calculate segment cost in both objectives\n        def segment_cost(sol, start, end, dist_mat):\n            cost = 0\n            for i in range(start, end-1):\n                cost += dist_mat[sol[i], sol[i+1]]\n            cost += dist_mat[sol[end-1], sol[start]]\n            return cost\n\n        cost1 = segment_cost(new_solution, seg_start, seg_end, distance_matrix_1)\n        cost2 = segment_cost(new_solution, seg_start, seg_end, distance_matrix_2)\n\n        # Decide mutation based on which objective is more critical\n        if cost1 > cost2 * 1.2:  # First objective is more critical\n            # Reverse segment to reduce first objective cost\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        elif cost2 > cost1 * 1.2:  # Second objective is more critical\n            # Rotate segment to reduce second objective cost\n            new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], 1)\n        else:  # Both objectives are balanced\n            # Randomly choose between reverse and rotate\n            if np.random.rand() < 0.5:\n                new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n            else:\n                new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.9649220163944144,
            0.20292329788208008
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high variance in objective values, then applies a hybrid \"distance-aware segment exchange\" operator that exchanges segments between the base solution and a randomly generated solution, followed by a \"multi-objective segment insertion\" that inserts segments from either objective space into the tour, ensuring feasibility and potentially improving the solution in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Generate random solution for segment exchange\n    random_solution = np.random.permutation(new_solution)\n\n    # Distance-aware segment exchange\n    if n > 4:\n        seg_start = np.random.randint(1, n-3)\n        seg_end = np.random.randint(seg_start+1, n-2)\n\n        # Compare segments from both solutions\n        base_segment = new_solution[seg_start:seg_end]\n        random_segment = random_solution[seg_start:seg_end]\n\n        # Choose better segment based on distance matrices\n        base_cost = distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end]]\n        random_cost = distance_matrix_1[random_solution[seg_start-1], random_solution[seg_start]] + distance_matrix_1[random_solution[seg_end-1], random_solution[seg_end]]\n\n        if random_cost < base_cost:\n            new_solution[seg_start:seg_end] = random_segment\n\n    # Multi-objective segment insertion\n    if n > 5:\n        # Select segment based on which objective it improves\n        obj1_segment = np.random.choice(range(1, n-2), size=2, replace=False)\n        obj2_segment = np.random.choice(range(1, n-2), size=2, replace=False)\n\n        # Insert segments from both objectives\n        insert_pos1 = np.random.randint(1, n-1)\n        insert_pos2 = np.random.randint(1, n-1)\n\n        # Insert segments while maintaining feasibility\n        new_solution = np.insert(new_solution, insert_pos1, new_solution[obj1_segment[0]])\n        new_solution = np.insert(new_solution, insert_pos2, new_solution[obj2_segment[1]])\n\n        # Remove duplicates if any\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n            for node in missing_nodes:\n                new_solution = np.append(new_solution, node)\n\n    return new_solution[1:n+1]  # Ensure correct length\n\n",
        "score": [
            -0.9227536644693372,
            0.15186536312103271
        ]
    }
]