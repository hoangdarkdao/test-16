[
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9693267478510855,
            0.278140664100647
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9821663842915196,
            0.28467029333114624
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and neighborhood diversity, then applies a hybrid local search combining 3-opt and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Weighted selection based on normalized objective values\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        weights = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1]\n        selected = random.choices(archive, weights=weights, k=1)[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Apply 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n        # Apply node relocation\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8938683617300458,
            0.257185697555542
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8311942081231796,
            0.23212707042694092
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8136722395928158,
            0.21144700050354004
        ]
    },
    {
        "algorithm": "{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9808021754597421,
            1.2174485325813293
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal and guided node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8646445057843833,
            0.2499745488166809
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9693267478510855,
            0.278140664100647
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9821663842915196,
            0.28467029333114624
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9693267478510855,
            0.278140664100647
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9693267478510855,
            0.278140664100647
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9693267478510855,
            0.278140664100647
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9693267478510855,
            0.278140664100647
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ]
    }
]