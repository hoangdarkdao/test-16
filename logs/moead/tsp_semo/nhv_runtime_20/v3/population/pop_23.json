[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9032423157374491,
            0.20829319953918457
        ]
    },
    {
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0186994856988998,
            1.5465465188026428
        ]
    }
]