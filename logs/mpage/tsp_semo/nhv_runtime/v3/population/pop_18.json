[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n\n    # Step 1: Randomly select two non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Step 2: Relocate the segment between a and b to after c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Step 3: Apply 2-opt on the relocated segment\n    i, j = sorted(np.random.choice(range(len(segment)), 2, replace=False))\n    segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.6753597224650268,
               0.0938725471496582
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a hierarchical local search approach that combines a multi-objective-aware node clustering strategy with a novel edge contraction-expansion mechanism. It first identifies clusters of nodes based on their proximity in both objective spaces, then selectively contracts edges between distant clusters while expanding edges within clusters, followed by a probabilistic node reordering that prioritizes edges with balanced distance improvements across objectives. The method incorporates a dynamic cluster size adjustment based on the current solution's objective balance, ensuring exploration of diverse neighborhoods while maintaining feasibility through careful validation and fallback mechanisms.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1]) / (objectives.sum(axis=1) + 1e-6)\n    weights = 1.0 / (obj_balance + 1e-6)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Cluster nodes based on both distance matrices\n    cluster_size = max(3, min(8, n // 3))\n    clusters = []\n    remaining = set(range(n))\n    while remaining:\n        center = np.random.choice(list(remaining))\n        cluster = [center]\n        remaining.remove(center)\n        for _ in range(cluster_size - 1):\n            if not remaining:\n                break\n            closest = min(remaining, key=lambda x: distance_matrix_1[center, x] + distance_matrix_2[center, x])\n            cluster.append(closest)\n            remaining.remove(closest)\n        clusters.append(cluster)\n\n    # Step 3: Edge contraction-expansion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n        # Contract edges between cluster nodes\n        for i in range(len(cluster)):\n            for j in range(i+1, len(cluster)):\n                a, b = cluster[i], cluster[j]\n                if a > b:\n                    a, b = b, a\n                # Check if swapping a and b improves both objectives\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        # Expand edges within cluster\n        for i in range(len(cluster)-1):\n            a, b = cluster[i], cluster[i+1]\n            if a > b:\n                a, b = b, a\n            # Check if moving b after a improves both objectives\n            if b != (a+1)%n:\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    # Move b after a\n                    node = new_solution[b]\n                    new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n                    insert_pos = np.where(new_solution == new_solution[a])[0][0] + 1\n                    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Probabilistic node reordering based on objective balance\n    obj1, obj2 = archive[selected_idx][1]\n    if abs(obj1 - obj2) > 0.2 * (obj1 + obj2):\n        # More aggressive reordering when objectives are unbalanced\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            # Check if swapping segments improves both objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            if delta1 + delta2 < 0:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 5: Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -1.0807467550296899,
               0.6731994152069092
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol_i, obj_i))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Step 2: Select a solution based on objective values and diversity\n    objectives = np.array([obj for _, obj in pareto_front])\n    normalized_obj = objectives / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = []\n    for sol, _ in pareto_front:\n        unique_edges = set()\n        for i in range(len(sol)):\n            unique_edges.add((min(sol[i], sol[(i+1)%len(sol)]), max(sol[i], sol[(i+1)%len(sol)])))\n        diversity_scores.append(len(unique_edges))\n    diversity_scores = np.array(diversity_scores) / (np.max(diversity_scores) + 1e-10)\n\n    selection_scores = 0.7 * (1 - normalized_obj[:, 0]) + 0.3 * diversity_scores\n    selected_idx = np.argmax(selection_scores)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Step 3: Multi-segment crossover operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two random segments from the base solution\n    seg1_start = np.random.randint(0, n)\n    seg1_length = np.random.randint(2, min(4, n//2))\n    seg1_end = (seg1_start + seg1_length) % n\n\n    seg2_start = np.random.randint(0, n)\n    while abs(seg2_start - seg1_start) < 2 or abs(seg2_start - seg1_end) < 2:\n        seg2_start = np.random.randint(0, n)\n    seg2_length = np.random.randint(2, min(4, n//2))\n    seg2_end = (seg2_start + seg2_length) % n\n\n    # Extract segments\n    if seg1_start < seg1_end:\n        seg1 = new_solution[seg1_start:seg1_end]\n    else:\n        seg1 = np.concatenate([new_solution[seg1_start:], new_solution[:seg1_end]])\n\n    if seg2_start < seg2_end:\n        seg2 = new_solution[seg2_start:seg2_end]\n    else:\n        seg2 = np.concatenate([new_solution[seg2_start:], new_solution[:seg2_end]])\n\n    # Select a third segment from another solution in the archive\n    other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n    seg3_start = np.random.randint(0, n)\n    seg3_length = np.random.randint(2, min(4, n//2))\n    seg3_end = (seg3_start + seg3_length) % n\n\n    if seg3_start < seg3_end:\n        seg3 = other_sol[seg3_start:seg3_end]\n    else:\n        seg3 = np.concatenate([other_sol[seg3_start:], other_sol[:seg3_end]])\n\n    # Combine segments to form new solution\n    remaining_nodes = set(range(n)) - set(seg1) - set(seg2) - set(seg3)\n    new_solution = np.concatenate([seg1, seg2, seg3, np.array(list(remaining_nodes))])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0059111292081795,
               0.346810519695282
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a \"multi-objective tour decomposition and recombination\" strategy that first selects a solution from the archive based on a novel \"objective diversity metric\" which prioritizes solutions with unbalanced improvements in either objective, then decomposes the tour into overlapping segments using a \"dual-objective segment clustering\" approach that groups nodes based on their connection costs in both objectives, followed by a \"probabilistic segment merging and splitting\" process that intelligently combines and divides segments while incorporating a \"cross-objective segment transposition\" mechanism that moves segments between different positions in the tour based on their potential to improve the underperforming objective, with the recombination decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment transposition if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Objective diversity selection\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dual-objective segment clustering\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate average costs in current segment\n        if len(current_segment) > 1:\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n        else:\n            avg_cost1 = avg_cost2 = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or len(current_segment) >= 4:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Probabilistic segment merging and splitting\n    new_segments = []\n    for segment in segments:\n        if len(segment) > 3 and np.random.random() < 0.3:\n            # Split segment\n            split_point = len(segment) // 2\n            new_segments.append(segment[:split_point])\n            new_segments.append(segment[split_point:])\n        else:\n            new_segments.append(segment)\n\n    # Cross-objective segment transposition\n    if len(new_segments) > 2:\n        # Find the underperforming objective\n        obj1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1))\n        obj2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1))\n        if obj1 > obj2:\n            # Improve objective 1\n            for i in range(len(new_segments)):\n                for j in range(i+1, len(new_segments)):\n                    if len(new_segments[i]) + len(new_segments[j]) <= 5:\n                        # Merge segments\n                        merged = new_segments[i] + new_segments[j]\n                        new_segments = [s for idx, s in enumerate(new_segments) if idx != i and idx != j]\n                        new_segments.insert(i, merged)\n                        break\n        else:\n            # Improve objective 2\n            for i in range(len(new_segments)):\n                if len(new_segments[i]) > 1 and np.random.random() < 0.5:\n                    # Transpose segment\n                    transposed = new_segments[i][::-1]\n                    new_segments[i] = transposed\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in new_segments:\n        new_solution.extend(segment)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple segment transposition\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = base_solution[i:j+1]\n        transposed = segment[::-1]\n        new_solution = np.concatenate([base_solution[:i], transposed, base_solution[j+1:]])\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8771806977717593,
               0.10162442922592163
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search operations by combining a novel segment permutation strategy with a dynamic edge reassembly mechanism. It first selects a solution from the archive using a diversity-aware selection mechanism that prioritizes solutions with high variance in objective improvements, then applies a hybrid local search that involves permuting a randomly selected segment using a custom permutation pattern and inserting it into a different position in the tour, while also performing a dynamic edge reassembly operation that reconstructs edges between non-adjacent segments based on a probabilistic model that considers both distance matrices to explore promising regions of the solution space. The algorithm ensures feasibility by verifying no duplicates or missing nodes and includes a fallback mechanism to a simple segment permutation if the solution becomes invalid, with the permutation pattern dynamically adjusted based on the current solution's properties.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weights = obj_variance / np.sum(obj_variance)\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment permutation and dynamic edge reassembly\n    # Step 1: Select a random segment to permute\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1]\n\n    # Create a custom permutation pattern based on distance matrices\n    segment_distances = distance_matrix_1[segment, :][:, segment] + distance_matrix_2[segment, :][:, segment]\n    permutation = np.argsort(np.sum(segment_distances, axis=1))\n    permuted_segment = segment[permutation]\n\n    # Step 2: Insert the permuted segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], permuted_segment, base_solution[k:]])\n\n    # Step 3: Dynamic edge reassembly between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n\n        # Probabilistic reassembly based on distance matrices\n        a_distances = distance_matrix_1[segment_a, :] + distance_matrix_2[segment_a, :]\n        b_distances = distance_matrix_1[segment_b, :] + distance_matrix_2[segment_b, :]\n\n        a_prob = np.exp(-np.sum(a_distances, axis=1) / np.sum(a_distances))\n        b_prob = np.exp(-np.sum(b_distances, axis=1) / np.sum(b_distances))\n\n        a_permutation = np.argsort(a_prob)\n        b_permutation = np.argsort(b_prob)\n\n        new_solution[a:b] = segment_a[a_permutation]\n        new_solution[b:] = segment_b[b_permutation]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment permutation with dynamic pattern\n        segment = base_solution[i:j+1]\n        segment_distances = distance_matrix_1[segment, :][:, segment] + distance_matrix_2[segment, :][:, segment]\n        permutation = np.argsort(np.sum(segment_distances, axis=1))\n        new_solution[i:j+1] = segment[permutation]\n\n    return new_solution\n\n",
          "score": [
               -1.0044109690536933,
               0.21091383695602417
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a \"multi-objective tour partitioning and reassembly\" strategy that first selects a solution from the archive based on a dynamic objective balance metric, then partitions the tour into non-overlapping segments using a novel \"objective-aware partitioning\" approach that considers both objectives' characteristics, followed by a probabilistic reassembly process that intelligently merges and splits segments while incorporating a \"dual-objective segment inversion\" mechanism that flips segments based on their potential to improve both objectives simultaneously, with the reassembly decisions guided by a weighted combination of segment-specific costs and their connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment inversion if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic objective balance selection\n    objectives = np.array([obj for _, obj in archive])\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmin(obj_balance)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Objective-aware partitioning\n    partitions = []\n    current_partition = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_partition[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate average costs in current partition\n        if len(current_partition) > 1:\n            avg_cost1 = sum(distance_matrix_1[current_partition[j], current_partition[j+1]] for j in range(len(current_partition)-1)) / (len(current_partition)-1)\n            avg_cost2 = sum(distance_matrix_2[current_partition[j], current_partition[j+1]] for j in range(len(current_partition)-1)) / (len(current_partition)-1)\n        else:\n            avg_cost1 = avg_cost2 = 0\n\n        # Decide whether to start new partition\n        if (cost1 > 1.2 * avg_cost1 and cost2 > 1.2 * avg_cost2) or len(current_partition) >= 3:\n            partitions.append(current_partition)\n            current_partition = [node]\n        else:\n            current_partition.append(node)\n    partitions.append(current_partition)\n\n    # Probabilistic reassembly with dual-objective inversion\n    new_solution = []\n    remaining_nodes = set(range(n))\n    current_node = base_solution[0]\n    new_solution.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    for partition in partitions:\n        if not remaining_nodes.intersection(partition):\n            continue\n\n        # Calculate partition costs\n        part_cost1 = sum(distance_matrix_1[partition[i], partition[i+1]] for i in range(len(partition)-1))\n        part_cost2 = sum(distance_matrix_2[partition[i], partition[i+1]] for i in range(len(partition)-1))\n\n        # Calculate connection cost\n        last_in_new = new_solution[-1]\n        first_in_part = partition[0]\n        conn_cost1 = distance_matrix_1[last_in_new, first_in_part]\n        conn_cost2 = distance_matrix_2[last_in_new, first_in_part]\n\n        # Decide whether to invert partition\n        if (part_cost1 > 1.5 * conn_cost1 and part_cost2 > 1.5 * conn_cost2) and np.random.random() < 0.4:\n            partition = partition[::-1]\n\n        # Add partition to solution\n        for node in partition:\n            if node in remaining_nodes:\n                new_solution.append(node)\n                remaining_nodes.remove(node)\n        current_node = partition[-1]\n\n    # Add remaining nodes with nearest neighbor\n    while remaining_nodes:\n        candidates = list(remaining_nodes)\n        nearest = min(candidates, key=lambda x: distance_matrix_1[current_node, x] + distance_matrix_2[current_node, x])\n        new_solution.append(nearest)\n        remaining_nodes.remove(nearest)\n        current_node = nearest\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(new_solution) == n + 1 and len(np.unique(new_solution[:-1])) == n\n\n    # Fallback mechanism\n    if len(np.unique(new_solution[:-1])) != n:\n        # Simple segment inversion as fallback\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9253067550655157,
               0.11493051052093506
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search by combining segment-based manipulation with a novel path inversion strategy. It first selects a solution from the archive using a weighted objective function that prioritizes solutions with balanced improvements in both objectives, then applies a hybrid local search that involves inverting a randomly selected segment of the tour and inserting it at a different position, while also performing a novel path inversion operation that reverses the order of edges between non-adjacent segments to explore diverse solutions. The algorithm ensures feasibility by verifying no duplicates or missing nodes, and includes a fallback mechanism to a simple segment inversion if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.array([0.5, 0.5])\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment inversion and insertion with path inversion\n    # Step 1: Select a random segment to invert\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1]\n    inverted_segment = segment[::-1]\n\n    # Step 2: Insert the inverted segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], inverted_segment, base_solution[k:]])\n\n    # Step 3: Perform path inversion between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n        inverted_a = segment_a[::-1]\n        inverted_b = segment_b[::-1]\n        new_solution[a:b] = inverted_a\n        new_solution[b:] = inverted_b\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment inversion\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.9088239710243505,
               0.10778272151947021
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a \"multi-objective adaptive segment inversion and relocation\" strategy that dynamically identifies and inverts segments based on their potential to improve both objectives simultaneously, while simultaneously relocating these segments to positions that optimize the weighted combination of both objectives, using a probabilistic approach that balances exploration of new segments with exploitation of high-potential segments, all while maintaining solution feasibility through comprehensive validation and ensuring connectivity through a segment-specific inversion mechanism that preserves the tour's structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10\n    obj_weights = 1 / obj_range\n    obj_weights /= np.sum(obj_weights)\n\n    weighted_scores = np.dot(objectives, obj_weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    if n > 3:\n        # Identify segments with high potential for improvement\n        segments = []\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = base_solution[i:i+segment_length]\n            segments.append(segment)\n\n        # Calculate segment costs\n        segment_costs = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            segment_costs.append((seg_cost1, seg_cost2))\n\n        # Adaptive segment inversion and relocation\n        for i in range(len(segments)):\n            if np.random.random() < 0.4:\n                # Invert segment if it has high potential\n                if obj_weights[0] * segment_costs[i][0] + obj_weights[1] * segment_costs[i][1] > np.mean(weighted_scores):\n                    segments[i] = segments[i][::-1]\n\n                # Relocate segment to a new position\n                j = np.random.randint(0, len(segments))\n                if i != j:\n                    segments.insert(j, segments.pop(i))\n\n        # Reconstruct solution\n        new_solution = np.concatenate(segments)\n        new_solution = np.append(new_solution, new_solution[0])\n\n    # Validate solution\n    assert len(new_solution) == n + 1 and len(np.unique(new_solution[:-1])) == n\n\n    return new_solution\n\n",
          "score": [
               -1.0043024455829204,
               0.11589115858078003
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search operations by combining segment-based manipulation with a novel edge rotation strategy. It first selects a solution from the archive using a weighted objective function that prioritizes solutions with balanced improvements in both objectives, then applies a hybrid local search that involves rotating a randomly selected segment by a fixed number of positions and inserting it into a different position in the tour, while also performing a novel edge rotation operation that cyclically permutes edges between non-adjacent segments to explore diverse solutions. The algorithm ensures feasibility by verifying no duplicates or missing nodes, and includes a fallback mechanism to a simple segment rotation if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment rotation and insertion with edge rotation\n    # Step 1: Select a random segment to rotate\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n\n    # Step 2: Insert the rotated segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], rotated_segment, base_solution[k:]])\n\n    # Step 3: Perform edge rotation between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n        rotation_a = np.random.randint(1, len(segment_a))\n        rotation_b = np.random.randint(1, len(segment_b))\n        new_solution[a:b] = np.roll(segment_a, rotation_a)\n        new_solution[b:] = np.roll(segment_b, rotation_b)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment rotation\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        rotation = np.random.randint(1, j - i + 1)\n        new_solution[i:j+1] = np.roll(base_solution[i:j+1], rotation)\n\n    return new_solution\n\n",
          "score": [
               -0.9354692806128575,
               0.13754773139953613
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of manipulating solution segments while introducing a novel \"objective-aware segment merging and splitting\" strategy that dynamically adapts to the current search state by first selecting a solution from the archive using a hybrid objective prioritization that combines both objectives with adaptive weights, then decomposes the tour into segments while preserving their relative order, and finally reconstructs the tour by probabilistically merging adjacent segments to create larger segments and then splitting these segments into smaller segments based on a weighted combination of the segments' individual costs in both objectives and their potential connection costs, while incorporating a segment-specific inversion mechanism that flips segments with high potential for improving both objectives simultaneously, and ensuring feasibility through a comprehensive validation process that verifies no duplicates or missing nodes, with a fallback mechanism to a simple segment rotation if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid objective prioritization with adaptive weights\n    objectives = np.array([obj for _, obj in archive])\n    obj_weights = np.array([0.5, 0.5])  # Initial equal weights\n    if len(archive) > 1:\n        obj_std = np.std(objectives, axis=0)\n        obj_weights = obj_std / np.sum(obj_std)\n\n    weighted_scores = np.dot(objectives, obj_weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition with order preservation\n    segment_length = max(2, n // 4)\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = base_solution[i:i+segment_length]\n        segments.append(segment)\n\n    # Objective-aware segment merging and splitting\n    merged_segments = []\n    i = 0\n    while i < len(segments):\n        if i < len(segments) - 1:\n            seg1 = segments[i]\n            seg2 = segments[i+1]\n\n            # Calculate segment costs\n            seg1_cost1 = sum(distance_matrix_1[seg1[j], seg1[j+1]] for j in range(len(seg1)-1))\n            seg1_cost2 = sum(distance_matrix_2[seg1[j], seg1[j+1]] for j in range(len(seg1)-1))\n            seg2_cost1 = sum(distance_matrix_1[seg2[j], seg2[j+1]] for j in range(len(seg2)-1))\n            seg2_cost2 = sum(distance_matrix_2[seg2[j], seg2[j+1]] for j in range(len(seg2)-1))\n\n            # Calculate connection cost\n            last_in_seg1 = seg1[-1]\n            first_in_seg2 = seg2[0]\n            connection_cost1 = distance_matrix_1[last_in_seg1, first_in_seg2]\n            connection_cost2 = distance_matrix_2[last_in_seg1, first_in_seg2]\n\n            # Decide whether to merge segments\n            merge_prob = 0.4 * (1 - (obj_weights[0] * (seg1_cost1 + seg2_cost1) + obj_weights[1] * (seg1_cost2 + seg2_cost2)) /\n                              (obj_weights[0] * (distance_matrix_1.max()*2) + obj_weights[1] * (distance_matrix_2.max()*2)))\n\n            if np.random.random() < merge_prob:\n                merged = np.concatenate([seg1, seg2])\n                merged_segments.append(merged)\n                i += 2\n                continue\n\n        merged_segments.append(segments[i])\n        i += 1\n\n    # Reconstruct solution with probabilistic segment splitting\n    new_solution = []\n    remaining_nodes = set(range(n))\n    current_node = base_solution[0]\n    new_solution.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    for seg in merged_segments:\n        if not remaining_nodes.intersection(seg):\n            continue\n\n        # Calculate segment costs\n        seg_cost1 = sum(distance_matrix_1[seg[j], seg[j+1]] for j in range(len(seg)-1))\n        seg_cost2 = sum(distance_matrix_2[seg[j], seg[j+1]] for j in range(len(seg)-1))\n\n        # Decide whether to split segment\n        split_prob = 0.3 * (1 - (obj_weights[0] * seg_cost1 + obj_weights[1] * seg_cost2) /\n                          (obj_weights[0] * distance_matrix_1.max() + obj_weights[1] * distance_matrix_2.max()))\n\n        if np.random.random() < split_prob and len(seg) > 2:\n            split_point = len(seg) // 2\n            seg1 = seg[:split_point]\n            seg2 = seg[split_point:]\n\n            # Add first part\n            for node in seg1:\n                if node in remaining_nodes:\n                    new_solution.append(node)\n                    remaining_nodes.remove(node)\n            current_node = seg1[-1]\n\n            # Add second part\n            for node in seg2:\n                if node in remaining_nodes:\n                    new_solution.append(node)\n                    remaining_nodes.remove(node)\n            current_node = seg2[-1]\n        else:\n            # Add entire segment\n            for node in seg:\n                if node in remaining_nodes:\n                    new_solution.append(node)\n                    remaining_nodes.remove(node)\n            current_node = seg[-1]\n\n        # Probabilistic segment inversion\n        if np.random.random() < 0.25:\n            inv_seg = seg[::-1]\n            for node in inv_seg:\n                if node in remaining_nodes:\n                    new_solution.append(node)\n                    remaining_nodes.remove(node)\n            current_node = inv_seg[-1]\n\n    # Add remaining nodes with nearest neighbor\n    while remaining_nodes:\n        candidates = list(remaining_nodes)\n        nearest = min(candidates, key=lambda x: (obj_weights[0] * distance_matrix_1[current_node, x] +\n                                              obj_weights[1] * distance_matrix_2[current_node, x]))\n        new_solution.append(nearest)\n        remaining_nodes.remove(nearest)\n        current_node = nearest\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple segment rotation\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        rotation = np.random.randint(1, j - i + 1)\n        new_solution[i:j+1] = np.roll(base_solution[i:j+1], rotation)\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9637931084213491,
               0.1952330470085144
          ]
     }
]