[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high ratio of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Swap two edges if it improves both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate new objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n           (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n            new_solution = candidate\n            break\n\n    # Segment reversal: Reverse a random segment if it improves the solution\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new objectives\n    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    # Accept if both objectives improve or one improves significantly\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n       (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n       (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               7.938052437621909,
               4.974250410098344
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating each solution's potential for improvement using a combination of objective values and diversity measures. It then applies a novel hybrid local search operator that combines a modified version of the Lin-Kernighan heuristic with a variable-length segment relocation strategy. The operator randomly selects a segment of nodes in the tour and relocates it to a new position while considering both objective spaces, ensuring feasibility by maintaining the TSP constraints. The selection of the segment length and insertion point is guided by a probabilistic approach that balances exploration and exploitation, favoring segments that show high potential for reducing both objectives. The function returns the new neighbor solution after validating its feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([(cost1 + cost2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2)) for _, (cost1, cost2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length (1 to n//2)\n    segment_length = random.randint(1, n // 2)\n\n    # Randomly select a starting position for the segment\n    start_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Find the best insertion position considering both objectives\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for insert_pos in range(len(new_solution)):\n        # Insert the segment at the current position\n        candidate = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Combine the costs with a weighted sum\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = insert_pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
          "score": [
               6.11088345881558,
               5.468006696741405
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of focusing on diverse solutions from the first provided algorithm with a novel local search operator that integrates both path inversion and node relocation, guided by a hybrid objective improvement criterion that considers both individual objective improvements and their combined trade-offs. It first partitions the archive into clusters based on both objective values and spatial diversity, then selects a representative solution from the least explored cluster. The local search operator dynamically selects multiple non-overlapping segments from the solution, applies inversion with probability based on local objective improvements, and then performs targeted node relocations to further optimize the tour, with the search guided by a hybrid acceptance criterion that balances individual objective improvements with their combined trade-offs to ensure feasible and high-quality solutions are generated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.cluster import KMeans\n    import random\n\n    # Cluster-based selection\n    objectives = np.array([obj for _, obj in archive])\n    coords = instance[archive[0][0], :2]\n    diversity = np.array([np.std(coords[:, 0]), np.std(coords[:, 1])])\n\n    cluster_data = np.hstack([objectives, diversity.reshape(1, -1).repeat(len(archive), axis=0)])\n    n_clusters = min(3, len(archive))\n    kmeans = KMeans(n_clusters=n_clusters)\n    labels = kmeans.fit_predict(cluster_data)\n\n    cluster_sizes = np.bincount(labels)\n    least_cluster = np.argmin(cluster_sizes)\n    candidates = [i for i, label in enumerate(labels) if label == least_cluster]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment inversion with node relocation\n    num_segments = min(3, n // 4)\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n    segments = [(segment_indices[i], segment_indices[i+1]) for i in range(0, len(segment_indices), 2)]\n    segments.sort(key=lambda x: x[1]-x[0], reverse=True)\n\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        if random.random() < 0.6:\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n\n            inverted_segment = segment[::-1]\n            temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= 1.1 * current_cost2) or \\\n               (new_cost1 <= 1.1 * current_cost1 and new_cost2 < current_cost2):\n                new_solution = temp_solution\n\n    # Node relocation with trade-off consideration\n    for _ in range(5):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        candidate_positions = list(range(n))\n        candidate_positions.remove(node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in candidate_positions:\n            temp_sol = np.delete(new_solution, node_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            combined_score = 0.7 * cost1 + 0.3 * cost2\n            if combined_score < best_score:\n                best_pos = pos\n                best_score = combined_score\n\n        if best_pos is not None:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.041981799207054,
               7.326106261285743
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto front analysis with a novel multi-objective segment relocation strategy that dynamically selects and repositions segments of the tour based on their contribution to both objectives, using a hybrid acceptance criterion that balances improvement in both objectives while maintaining solution feasibility through a constrained segment relocation mechanism. The segment relocation dynamically adjusts the segment length and position based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided edge reversal mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best trade-off using Pareto front analysis\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective segment relocation\n    for _ in range(5):\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(n - segment_length)\n        end = start + segment_length\n\n        # Extract the segment\n        segment = base_solution[start:end]\n\n        # Remove the segment\n        temp_solution = np.concatenate([base_solution[:start], base_solution[end:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(len(temp_solution)):\n            # Insert segment at position i\n            candidate = np.insert(temp_solution, i, segment)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Multi-objective comparison\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_pos = i\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        # Insert segment at best position\n        new_solution = np.insert(temp_solution, best_pos, segment)\n\n    # Guided edge reversal\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n        # Calculate costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if at least one objective improves or both improve with controlled trade-off\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.733596318190619,
               5.825750634336084
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto-based solution selection with a novel multi-objective tour fragmentation and reassembly strategy that intelligently splits the tour into contiguous segments, evaluates their objective contributions, and reassembles them in a way that maximizes improvements in both objectives while maintaining solution feasibility through a constrained segment merging mechanism. The reassembly process dynamically adjusts segment boundaries based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided segment rotation mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best Pareto trade-off\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective tour fragmentation and reassembly\n    for _ in range(5):\n        # Randomly select two cut points to split the tour into three segments\n        cut1, cut2 = sorted(random.sample(range(1, n), 2))\n        segment1 = base_solution[:cut1]\n        segment2 = base_solution[cut1:cut2]\n        segment3 = base_solution[cut2:]\n\n        # Try different reassembly orders\n        candidates = [\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment3, segment2, segment1]),\n            np.concatenate([segment1, segment2[::-1], segment3]),\n            np.concatenate([segment2[::-1], segment1, segment3])\n        ]\n\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_candidate = candidate\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    # Guided segment rotation\n    for _ in range(5):\n        # Select a segment to rotate\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Try different rotation amounts\n        for rotation in range(1, segment_length):\n            candidate = new_solution.copy()\n            segment = candidate[start:end]\n            rotated_segment = np.roll(segment, rotation)\n            candidate[start:end] = rotated_segment\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.520469626016764,
               5.163588701139817
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a multi-objective adaptive path refinement strategy that dynamically combines the strengths of both provided approaches by first identifying critical path segments through a hybrid clustering and Pareto-based analysis, then applies a novel adaptive segment refinement process that alternates between cluster-aware reordering and guided segment rotation, with each operation weighted by its potential objective improvement and spatial coherence, while maintaining feasibility through a constrained segment merging mechanism that ensures valid tour structures, and finally refines the solution through an iterative adaptive optimization process that dynamically adjusts the balance between exploration and exploitation based on the current Pareto front characteristics.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best Pareto trade-off\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Cluster-based path refinement\n    from sklearn.cluster import KMeans\n    n_clusters = max(2, len(base_solution) // 5)\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.hstack((coords1, coords2))\n\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n    clusters = kmeans.fit_predict(combined_coords)\n\n    cluster_groups = {}\n    for node, cluster in zip(base_solution, clusters):\n        if cluster not in cluster_groups:\n            cluster_groups[cluster] = []\n        cluster_groups[cluster].append(node)\n\n    # Adaptive segment refinement\n    for _ in range(5):\n        # Select a cluster to refine\n        cluster_to_refine = np.random.choice(list(cluster_groups.keys()))\n        nodes_in_cluster = cluster_groups[cluster_to_refine]\n\n        if len(nodes_in_cluster) < 2:\n            continue\n\n        # Find the positions of these nodes in the current solution\n        positions = [i for i, node in enumerate(new_solution) if node in nodes_in_cluster]\n\n        if len(positions) < 2:\n            continue\n\n        # Try different segment operations\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Option 1: Reverse the segment\n        candidate = new_solution.copy()\n        segment = candidate[positions[0]:positions[-1]+1]\n        candidate[positions[0]:positions[-1]+1] = segment[::-1]\n\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n            best_candidate = candidate\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n        # Option 2: Rotate the segment\n        for rotation in range(1, len(positions)):\n            candidate = new_solution.copy()\n            segment = candidate[positions[0]:positions[-1]+1]\n            rotated_segment = np.roll(segment, rotation)\n            candidate[positions[0]:positions[-1]+1] = rotated_segment\n\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_candidate = candidate\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    # Final adaptive optimization\n    for _ in range(3):\n        # Randomly select two cut points to split the tour into three segments\n        cut1, cut2 = sorted(random.sample(range(1, n), 2))\n        segment1 = new_solution[:cut1]\n        segment2 = new_solution[cut1:cut2]\n        segment3 = new_solution[cut2:]\n\n        # Try different reassembly orders\n        candidates = [\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment3, segment2, segment1]),\n            np.concatenate([segment1, segment2[::-1], segment3]),\n            np.concatenate([segment2[::-1], segment1, segment3])\n        ]\n\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Adaptive acceptance criteria based on current Pareto front\n            if len(pareto_front) > 0:\n                avg_obj1 = sum(obj[0] for _, obj in pareto_front) / len(pareto_front)\n                avg_obj2 = sum(obj[1] for _, obj in pareto_front) / len(pareto_front)\n\n                if (cost1 < best_cost1 and cost2 <= avg_obj2 * 1.1) or (cost2 < best_cost2 and cost1 <= avg_obj1 * 1.1):\n                    best_candidate = candidate\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n            else:\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_candidate = candidate\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    return new_solution\n\n",
          "score": [
               5.505195001264278,
               6.001408081349817
          ]
     },
     {
          "algorithm": "{The new algorithm combines adaptive Pareto front analysis with a novel multi-objective tour partitioning and merging strategy that dynamically identifies critical path segments, evaluates their contribution to both objectives using a weighted multi-criteria decision analysis, and intelligently merges them through a constrained hierarchical reassembly process that prioritizes non-dominated segments while respecting the bi-objective trade-off through a guided segment inversion mechanism that maintains solution feasibility by ensuring proper node connectivity and tour closure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Adaptive Pareto front analysis with weighted selection\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Weighted selection based on objective importance\n        weights = [0.6, 0.4] if np.random.random() < 0.5 else [0.4, 0.6]\n        weighted_scores = [(weights[0] * obj[0] + weights[1] * obj[1], sol) for sol, obj in pareto_front]\n        best_solution = min(weighted_scores, key=lambda x: x[0])[1]\n        base_solution = best_solution.copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective tour partitioning and merging\n    for _ in range(3):\n        # Identify critical path segments\n        segment_length = np.random.randint(2, min(6, n // 3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = base_solution[start:end]\n\n        # Evaluate segment contribution using weighted criteria\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        total_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        total_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        # Determine if segment is critical for either objective\n        is_critical1 = segment_cost1 / total_cost1 > 0.15\n        is_critical2 = segment_cost2 / total_cost2 > 0.15\n\n        if is_critical1 or is_critical2:\n            # Remove segment and find best merge position\n            temp_solution = np.concatenate([base_solution[:start], base_solution[end:]])\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(temp_solution)):\n                # Try inserting segment at position i and its reverse\n                candidates = [\n                    np.insert(temp_solution, i, segment),\n                    np.insert(temp_solution, i, segment[::-1])\n                ]\n\n                for candidate in candidates:\n                    candidate_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    candidate_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Weighted score for multi-objective evaluation\n                    score = weights[0] * candidate_cost1 + weights[1] * candidate_cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_pos = i\n                        best_candidate = candidate\n\n            if best_pos != -1:\n                new_solution = best_candidate\n\n    # Guided segment inversion with feasibility check\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], inverted_segment, new_solution[j+1:]])\n\n        # Check feasibility (no duplicates)\n        if len(np.unique(candidate)) == n:\n            # Calculate costs\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if weighted score improves\n            current_score = weights[0] * current_cost1 + weights[1] * current_cost2\n            new_score = weights[0] * new_cost1 + weights[1] * new_cost2\n\n            if new_score < current_score:\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.768311943976004,
               5.679366257236675
          ]
     },
     {
          "algorithm": "{The new algorithm combines the segment-based optimization approach from the first provided algorithm with the cluster-based selection strategy from the second, but replaces the inversion and relocation operators with a novel \"objective-aware segment merging\" process. It first partitions the base solution into segments based on both objective spaces' local topologies, then selects representative segments from diverse clusters in the objective space, and merges them in an adaptive fashion that considers the trade-off between objectives while maintaining feasibility through a dynamic segment reordering mechanism that ensures no nodes are skipped or revisited. The merging process uses a hybrid objective improvement criterion that prioritizes segments improving at least one objective while maintaining or improving the other, with the entire process guided by a spatial diversity measure to ensure comprehensive exploration of the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.cluster import KMeans\n    import random\n\n    # Select base solution with best combined objective\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Calculate segment objectives\n    def segment_objectives(segment):\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        return (cost1, cost2)\n\n    # Decompose tour into segments\n    n = len(base_solution)\n    min_segment = max(3, n // 5)\n    max_segment = min(10, n // 2)\n    segments = []\n    current_start = 0\n\n    while current_start < n:\n        segment_length = random.randint(min_segment, max_segment)\n        segment_end = min(current_start + segment_length, n)\n        segments.append(base_solution[current_start:segment_end])\n        current_start = segment_end\n\n    # Cluster segments by objectives\n    segment_costs = np.array([segment_objectives(seg) for seg in segments])\n    if len(segments) > 1:\n        n_clusters = min(3, len(segments))\n        kmeans = KMeans(n_clusters=n_clusters)\n        labels = kmeans.fit_predict(segment_costs)\n\n        # Select representative segments from each cluster\n        selected_segments = []\n        for cluster in range(n_clusters):\n            cluster_indices = [i for i, label in enumerate(labels) if label == cluster]\n            if cluster_indices:\n                selected_segments.append(segments[random.choice(cluster_indices)])\n    else:\n        selected_segments = segments\n\n    # Objective-aware segment merging\n    new_solution = []\n    for seg in selected_segments:\n        if not new_solution:\n            new_solution = list(seg)\n        else:\n            # Find best merge position considering both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for pos in range(len(new_solution) + 1):\n                # Try inserting segment at position pos\n                temp_sol = new_solution[:pos] + list(seg) + new_solution[pos:]\n\n                # Calculate new total costs\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%len(temp_sol)]] for i in range(len(temp_sol)))\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%len(temp_sol)]] for i in range(len(temp_sol)))\n\n                # Hybrid objective score\n                score = 0.5 * cost1 + 0.5 * cost2\n\n                if score < best_score:\n                    best_pos = pos\n                    best_score = score\n\n            new_solution = new_solution[:best_pos] + list(seg) + new_solution[best_pos:]\n\n    # Dynamic segment reordering for feasibility\n    for _ in range(2):\n        if len(new_solution) < 3:\n            break\n\n        # Select random segment to reorder\n        seg_start = random.randint(0, len(new_solution) - 3)\n        seg_length = random.randint(2, min(5, len(new_solution) - seg_start - 1))\n        seg_end = seg_start + seg_length\n\n        segment = new_solution[seg_start:seg_end]\n\n        # Try different orderings\n        candidates = [\n            segment,  # original\n            segment[::-1],  # reversed\n            segment[-1:] + segment[:-1],  # rotated right\n            segment[1:] + segment[:1]  # rotated left\n        ]\n\n        best_order = segment\n        best_score = float('inf')\n\n        for candidate in candidates:\n            temp_sol = new_solution[:seg_start] + candidate + new_solution[seg_end:]\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%len(temp_sol)]] for i in range(len(temp_sol)))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%len(temp_sol)]] for i in range(len(temp_sol)))\n\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_order = candidate\n                best_score = score\n\n        new_solution = new_solution[:seg_start] + best_order + new_solution[seg_end:]\n\n    return np.array(new_solution)\n\n",
          "score": [
               5.898850561041737,
               5.561746469784979
          ]
     },
     {
          "algorithm": "{The new algorithm combines an adaptive multi-objective clustering approach with a novel hierarchical segment reassembly strategy that dynamically identifies and preserves high-quality sub-tours from the Pareto front solutions, while intelligently breaking and reconnecting them through a constrained node permutation mechanism that prioritizes non-dominated segments based on their contribution to both objectives, using a weighted multi-criteria evaluation to guide the reassembly process while maintaining solution feasibility by ensuring proper node connectivity and tour closure through a guided segment inversion and merging mechanism that adaptively adjusts the segment size and merge position based on the current trade-off between objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Adaptive multi-objective clustering with weighted selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    cluster_centers = np.array([[0.25, 0.75], [0.5, 0.5], [0.75, 0.25]])\n    distances = np.linalg.norm(normalized_obj[:, None] - cluster_centers, axis=2)\n    cluster_assignments = np.argmin(distances, axis=1)\n\n    # Select from the most promising cluster (middle cluster)\n    cluster_indices = np.where(cluster_assignments == 1)[0]\n    if len(cluster_indices) > 0:\n        selected_idx = np.random.choice(cluster_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hierarchical segment reassembly with dynamic segment size\n    for _ in range(4):\n        segment_size = np.random.randint(2, min(5, n // 4))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        segment = base_solution[start:end]\n\n        # Evaluate segment contribution using weighted criteria\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        total_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        total_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        # Weighted importance based on current trade-off\n        weight1 = segment_cost1 / (total_cost1 + 1e-6)\n        weight2 = segment_cost2 / (total_cost2 + 1e-6)\n        weights = [weight1, weight2] if weight1 > weight2 else [weight2, weight1]\n\n        # Remove segment and find best merge position\n        temp_solution = np.concatenate([base_solution[:start], base_solution[end:]])\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(temp_solution)):\n            # Try inserting segment at position i and its reverse\n            candidates = [\n                np.insert(temp_solution, i, segment),\n                np.insert(temp_solution, i, segment[::-1])\n            ]\n\n            for candidate in candidates:\n                candidate_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                candidate_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                score = weights[0] * candidate_cost1 + weights[1] * candidate_cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n                    best_candidate = candidate\n\n        if best_pos != -1:\n            new_solution = best_candidate\n\n    # Guided segment inversion with adaptive acceptance\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], inverted_segment, new_solution[j+1:]])\n\n        # Check feasibility\n        if len(np.unique(candidate)) == n:\n            # Calculate weighted score\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Adaptive weights based on current trade-off\n            weight1 = new_cost1 / (current_cost1 + 1e-6)\n            weight2 = new_cost2 / (current_cost2 + 1e-6)\n            weights = [weight1, weight2] if weight1 > weight2 else [weight2, weight1]\n\n            current_score = weights[0] * current_cost1 + weights[1] * current_cost2\n            new_score = weights[0] * new_cost1 + weights[1] * new_cost2\n\n            if new_score < current_score:\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.382759568727223,
               6.525019920193785
          ]
     },
     {
          "algorithm": "{The novel algorithm employs a multi-phase approach that first identifies the most diverse solution in the archive using a novel diversity metric that combines both objective values and topological features, then applies a hybrid local search operator that combines a probabilistic node exchange mechanism with a constrained geometric transformation strategy. The operator selectively exchanges nodes based on their relative positions in both objective spaces, while applying a geometric transformation that warps the tour in a way that preserves feasibility and maximizes improvements in both objectives, with the transformation parameters dynamically adjusted based on the local topology and objective trade-offs. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and incorporates a guided diversification mechanism to escape local optima while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most diverse solution based on both objectives and topological features\n    diversity_scores = []\n    for sol, obj in archive:\n        # Calculate objective diversity\n        obj_diversity = (obj[0] - obj[1]) / (obj[0] + obj[1]) if (obj[0] + obj[1]) > 0 else 0\n\n        # Calculate topological diversity (average distance between consecutive nodes)\n        topo_diversity = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) / len(sol)\n\n        # Combine both diversity measures\n        diversity_scores.append(abs(obj_diversity) + topo_diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search operator\n    for _ in range(5):\n        # Probabilistic node exchange mechanism\n        exchange_prob = 0.3\n        for i in range(n):\n            if random.random() < exchange_prob:\n                j = random.randint(0, n-1)\n                if i != j:\n                    # Swap nodes\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                    # Calculate new costs\n                    cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives improve or one improves significantly\n                    old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n\n                    if not ((cost1 < old_cost1 and cost2 <= old_cost2 * 1.05) or (cost2 < old_cost2 and cost1 <= old_cost1 * 1.05)):\n                        # Revert if not accepted\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Geometric transformation strategy\n        if random.random() < 0.5:\n            # Select a segment of nodes\n            segment_length = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_length)\n            end = start + segment_length\n\n            # Apply a geometric transformation (rotation) to the segment\n            segment = new_solution[start:end]\n            rotation = random.randint(1, segment_length-1)\n            rotated_segment = np.roll(segment, rotation)\n            new_solution[start:end] = rotated_segment\n\n            # Check feasibility and cost\n            cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n\n            if not ((cost1 < old_cost1 and cost2 <= old_cost2 * 1.05) or (cost2 < old_cost2 and cost1 <= old_cost1 * 1.05)):\n                # Revert if not accepted\n                new_solution[start:end] = base_solution[start:end]\n\n    # Guided diversification mechanism\n    if random.random() < 0.3:\n        # Select a random segment and reverse it\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
          "score": [
               8.509521446306293,
               5.4677328138881
          ]
     }
]